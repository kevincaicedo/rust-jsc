/* automatically generated by rust-bindgen 0.69.4 */
#![allow(warnings)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const JSC_OBJC_API_ENABLED: u32 = 0;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140000;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __AVAILABILITY_MACROS_USES_AVAILABILITY: u32 = 1;
pub const __IPHONE_COMPAT_VERSION: u32 = 40000;
pub const __COREFOUNDATION_COREFOUNDATION__: u32 = 1;
pub const __COREFOUNDATION__: u32 = 1;
pub const DYNAMIC_TARGETS_ENABLED: u32 = 0;
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_MACCATALYST: u32 = 0;
pub const TARGET_OS_UIKITFORMAC: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_RTKIT: u32 = 0;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_CPU_ARM64: u32 = 1;
pub const TARGET_OS_VISION: u32 = 0;
pub const TARGET_OS_DRIVERKIT: u32 = 0;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_WINDOWS: u32 = 0;
pub const TARGET_OS_LINUX: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 0;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MESSAGES: u32 = 6;
pub const _LC_LAST: u32 = 7;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _JBLEN: u32 = 48;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __COREFOUNDATION_CFBASE__: u32 = 1;
pub const __COREFOUNDATION_CFAVAILABILITY__: u32 = 1;
pub const API_TO_BE_DEPRECATED: u32 = 100000;
pub const API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const UNIVERSAL_INTERFACES_VERSION: u32 = 1024;
pub const PRAGMA_IMPORT: u32 = 0;
pub const PRAGMA_ONCE: u32 = 0;
pub const PRAGMA_STRUCT_PACK: u32 = 1;
pub const PRAGMA_STRUCT_PACKPUSH: u32 = 1;
pub const PRAGMA_STRUCT_ALIGN: u32 = 0;
pub const PRAGMA_ENUM_PACK: u32 = 0;
pub const PRAGMA_ENUM_ALWAYSINT: u32 = 0;
pub const PRAGMA_ENUM_OPTIONS: u32 = 0;
pub const TYPE_EXTENDED: u32 = 0;
pub const TYPE_LONGDOUBLE_IS_DOUBLE: u32 = 0;
pub const TYPE_LONGLONG: u32 = 1;
pub const FUNCTION_PASCAL: u32 = 0;
pub const FUNCTION_DECLSPEC: u32 = 0;
pub const FUNCTION_WIN32CC: u32 = 0;
pub const TARGET_API_MAC_OS8: u32 = 0;
pub const TARGET_API_MAC_CARBON: u32 = 1;
pub const TARGET_API_MAC_OSX: u32 = 1;
pub const TARGET_CARBON: u32 = 1;
pub const OLDROUTINENAMES: u32 = 0;
pub const OPAQUE_TOOLBOX_STRUCTS: u32 = 1;
pub const OPAQUE_UPP_TYPES: u32 = 1;
pub const ACCESSOR_CALLS_ARE_FUNCTIONS: u32 = 1;
pub const CALL_NOT_IN_CARBON: u32 = 0;
pub const MIXEDMODE_CALLS_ARE_FUNCTIONS: u32 = 1;
pub const ALLOW_OBSOLETE_CARBON_MACMEMORY: u32 = 0;
pub const ALLOW_OBSOLETE_CARBON_OSUTILS: u32 = 0;
pub const kInvalidID: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const kCFCoreFoundationVersionNumber10_0: f64 = 196.4;
pub const kCFCoreFoundationVersionNumber10_0_3: f64 = 196.5;
pub const kCFCoreFoundationVersionNumber10_1: f64 = 226.0;
pub const kCFCoreFoundationVersionNumber10_1_1: f64 = 226.0;
pub const kCFCoreFoundationVersionNumber10_1_2: f64 = 227.2;
pub const kCFCoreFoundationVersionNumber10_1_3: f64 = 227.2;
pub const kCFCoreFoundationVersionNumber10_1_4: f64 = 227.3;
pub const kCFCoreFoundationVersionNumber10_2: f64 = 263.0;
pub const kCFCoreFoundationVersionNumber10_2_1: f64 = 263.1;
pub const kCFCoreFoundationVersionNumber10_2_2: f64 = 263.1;
pub const kCFCoreFoundationVersionNumber10_2_3: f64 = 263.3;
pub const kCFCoreFoundationVersionNumber10_2_4: f64 = 263.3;
pub const kCFCoreFoundationVersionNumber10_2_5: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_2_6: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_2_7: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_2_8: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_3: f64 = 299.0;
pub const kCFCoreFoundationVersionNumber10_3_1: f64 = 299.0;
pub const kCFCoreFoundationVersionNumber10_3_2: f64 = 299.0;
pub const kCFCoreFoundationVersionNumber10_3_3: f64 = 299.3;
pub const kCFCoreFoundationVersionNumber10_3_4: f64 = 299.31;
pub const kCFCoreFoundationVersionNumber10_3_5: f64 = 299.31;
pub const kCFCoreFoundationVersionNumber10_3_6: f64 = 299.32;
pub const kCFCoreFoundationVersionNumber10_3_7: f64 = 299.33;
pub const kCFCoreFoundationVersionNumber10_3_8: f64 = 299.33;
pub const kCFCoreFoundationVersionNumber10_3_9: f64 = 299.35;
pub const kCFCoreFoundationVersionNumber10_4: f64 = 368.0;
pub const kCFCoreFoundationVersionNumber10_4_1: f64 = 368.1;
pub const kCFCoreFoundationVersionNumber10_4_2: f64 = 368.11;
pub const kCFCoreFoundationVersionNumber10_4_3: f64 = 368.18;
pub const kCFCoreFoundationVersionNumber10_4_4_Intel: f64 = 368.26;
pub const kCFCoreFoundationVersionNumber10_4_4_PowerPC: f64 = 368.25;
pub const kCFCoreFoundationVersionNumber10_4_5_Intel: f64 = 368.26;
pub const kCFCoreFoundationVersionNumber10_4_5_PowerPC: f64 = 368.25;
pub const kCFCoreFoundationVersionNumber10_4_6_Intel: f64 = 368.26;
pub const kCFCoreFoundationVersionNumber10_4_6_PowerPC: f64 = 368.25;
pub const kCFCoreFoundationVersionNumber10_4_7: f64 = 368.27;
pub const kCFCoreFoundationVersionNumber10_4_8: f64 = 368.27;
pub const kCFCoreFoundationVersionNumber10_4_9: f64 = 368.28;
pub const kCFCoreFoundationVersionNumber10_4_10: f64 = 368.28;
pub const kCFCoreFoundationVersionNumber10_4_11: f64 = 368.31;
pub const kCFCoreFoundationVersionNumber10_5: f64 = 476.0;
pub const kCFCoreFoundationVersionNumber10_5_1: f64 = 476.0;
pub const kCFCoreFoundationVersionNumber10_5_2: f64 = 476.1;
pub const kCFCoreFoundationVersionNumber10_5_3: f64 = 476.13;
pub const kCFCoreFoundationVersionNumber10_5_4: f64 = 476.14;
pub const kCFCoreFoundationVersionNumber10_5_5: f64 = 476.15;
pub const kCFCoreFoundationVersionNumber10_5_6: f64 = 476.17;
pub const kCFCoreFoundationVersionNumber10_5_7: f64 = 476.18;
pub const kCFCoreFoundationVersionNumber10_5_8: f64 = 476.19;
pub const kCFCoreFoundationVersionNumber10_6: f64 = 550.0;
pub const kCFCoreFoundationVersionNumber10_6_1: f64 = 550.0;
pub const kCFCoreFoundationVersionNumber10_6_2: f64 = 550.13;
pub const kCFCoreFoundationVersionNumber10_6_3: f64 = 550.19;
pub const kCFCoreFoundationVersionNumber10_6_4: f64 = 550.29;
pub const kCFCoreFoundationVersionNumber10_6_5: f64 = 550.42;
pub const kCFCoreFoundationVersionNumber10_6_6: f64 = 550.42;
pub const kCFCoreFoundationVersionNumber10_6_7: f64 = 550.42;
pub const kCFCoreFoundationVersionNumber10_6_8: f64 = 550.43;
pub const kCFCoreFoundationVersionNumber10_7: f64 = 635.0;
pub const kCFCoreFoundationVersionNumber10_7_1: f64 = 635.0;
pub const kCFCoreFoundationVersionNumber10_7_2: f64 = 635.15;
pub const kCFCoreFoundationVersionNumber10_7_3: f64 = 635.19;
pub const kCFCoreFoundationVersionNumber10_7_4: f64 = 635.21;
pub const kCFCoreFoundationVersionNumber10_7_5: f64 = 635.21;
pub const kCFCoreFoundationVersionNumber10_8: f64 = 744.0;
pub const kCFCoreFoundationVersionNumber10_8_1: f64 = 744.0;
pub const kCFCoreFoundationVersionNumber10_8_2: f64 = 744.12;
pub const kCFCoreFoundationVersionNumber10_8_3: f64 = 744.18;
pub const kCFCoreFoundationVersionNumber10_8_4: f64 = 744.19;
pub const kCFCoreFoundationVersionNumber10_9: f64 = 855.11;
pub const kCFCoreFoundationVersionNumber10_9_1: f64 = 855.11;
pub const kCFCoreFoundationVersionNumber10_9_2: f64 = 855.14;
pub const kCFCoreFoundationVersionNumber10_10: f64 = 1151.16;
pub const kCFCoreFoundationVersionNumber10_10_1: f64 = 1151.16;
pub const kCFCoreFoundationVersionNumber10_10_2: u32 = 1152;
pub const kCFCoreFoundationVersionNumber10_10_3: f64 = 1153.18;
pub const kCFCoreFoundationVersionNumber10_10_4: f64 = 1153.18;
pub const kCFCoreFoundationVersionNumber10_10_5: f64 = 1153.18;
pub const kCFCoreFoundationVersionNumber10_10_Max: u32 = 1199;
pub const kCFCoreFoundationVersionNumber10_11: u32 = 1253;
pub const kCFCoreFoundationVersionNumber10_11_1: f64 = 1255.1;
pub const kCFCoreFoundationVersionNumber10_11_2: f64 = 1256.14;
pub const kCFCoreFoundationVersionNumber10_11_3: f64 = 1256.14;
pub const kCFCoreFoundationVersionNumber10_11_4: f64 = 1258.1;
pub const kCFCoreFoundationVersionNumber10_11_Max: u32 = 1299;
pub const ISA_PTRAUTH_DISCRIMINATOR: u32 = 27361;
pub const __COREFOUNDATION_CFARRAY__: u32 = 1;
pub const __COREFOUNDATION_CFBAG__: u32 = 1;
pub const __COREFOUNDATION_CFBINARYHEAP__: u32 = 1;
pub const __COREFOUNDATION_CFBITVECTOR__: u32 = 1;
pub const __COREFOUNDATION_CFBYTEORDER__: u32 = 1;
pub const CF_USE_OSBYTEORDER_H: u32 = 1;
pub const __COREFOUNDATION_CFCALENDAR__: u32 = 1;
pub const __COREFOUNDATION_CFLOCALE__: u32 = 1;
pub const __COREFOUNDATION_CFDICTIONARY__: u32 = 1;
pub const __COREFOUNDATION_CFNOTIFICATIONCENTER__: u32 = 1;
pub const __COREFOUNDATION_CFDATE__: u32 = 1;
pub const __COREFOUNDATION_CFTIMEZONE__: u32 = 1;
pub const __COREFOUNDATION_CFDATA__: u32 = 1;
pub const __COREFOUNDATION_CFSTRING__: u32 = 1;
pub const __COREFOUNDATION_CFCHARACTERSET__: u32 = 1;
pub const __COREFOUNDATION_CFERROR__: u32 = 1;
pub const kCFStringEncodingInvalidId: u32 = 4294967295;
pub const __kCFStringInlineBufferLength: u32 = 64;
pub const __COREFOUNDATION_CFCGTYPES__: u32 = 1;
pub const CGFLOAT_IS_DOUBLE: u32 = 1;
pub const CGFLOAT_DEFINED: u32 = 1;
pub const CGVECTOR_DEFINED: u32 = 1;
pub const __COREFOUNDATION_CFDATEFORMATTER__: u32 = 1;
pub const __COREFOUNDATION_CFNUMBER__: u32 = 1;
pub const __COREFOUNDATION_CFNUMBERFORMATTER__: u32 = 1;
pub const __COREFOUNDATION_CFPREFERENCES__: u32 = 1;
pub const __COREFOUNDATION_CFPROPERTYLIST__: u32 = 1;
pub const __COREFOUNDATION_CFSTREAM__: u32 = 1;
pub const __COREFOUNDATION_CFURL__: u32 = 1;
pub const __COREFOUNDATION_CFRUNLOOP__: u32 = 1;
pub const MACH_PORT_NULL: u32 = 0;
pub const MACH_PORT_TYPE_DNREQUEST: u32 = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: u32 = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: u32 = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: u32 = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: u32 = 1;
pub const MACH_PORT_QLIMIT_ZERO: u32 = 0;
pub const MACH_PORT_QLIMIT_BASIC: u32 = 5;
pub const MACH_PORT_QLIMIT_SMALL: u32 = 16;
pub const MACH_PORT_QLIMIT_LARGE: u32 = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: u32 = 65534;
pub const MACH_PORT_QLIMIT_MIN: u32 = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: u32 = 5;
pub const MACH_PORT_QLIMIT_MAX: u32 = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: u32 = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: u32 = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: u32 = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: u32 = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: u32 = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: u32 = 32;
pub const MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE: u32 = 64;
pub const MACH_PORT_STATUS_FLAG_NO_GRANT: u32 = 128;
pub const MACH_PORT_LIMITS_INFO: u32 = 1;
pub const MACH_PORT_RECEIVE_STATUS: u32 = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: u32 = 3;
pub const MACH_PORT_TEMPOWNER: u32 = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: u32 = 5;
pub const MACH_PORT_DENAP_RECEIVER: u32 = 6;
pub const MACH_PORT_INFO_EXT: u32 = 7;
pub const MACH_PORT_GUARD_INFO: u32 = 8;
pub const MACH_PORT_SERVICE_THROTTLED: u32 = 9;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: u32 = 1;
pub const MACH_PORT_SERVICE_THROTTLED_COUNT: u32 = 1;
pub const MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN: u32 = 255;
pub const MPO_CONTEXT_AS_GUARD: u32 = 1;
pub const MPO_QLIMIT: u32 = 2;
pub const MPO_TEMPOWNER: u32 = 4;
pub const MPO_IMPORTANCE_RECEIVER: u32 = 8;
pub const MPO_INSERT_SEND_RIGHT: u32 = 16;
pub const MPO_STRICT: u32 = 32;
pub const MPO_DENAP_RECEIVER: u32 = 64;
pub const MPO_IMMOVABLE_RECEIVE: u32 = 128;
pub const MPO_FILTER_MSG: u32 = 256;
pub const MPO_TG_BLOCK_TRACKING: u32 = 512;
pub const MPO_SERVICE_PORT: u32 = 1024;
pub const MPO_CONNECTION_PORT: u32 = 2048;
pub const MPO_REPLY_PORT: u32 = 4096;
pub const MPO_ENFORCE_REPLY_PORT_SEMANTICS: u32 = 8192;
pub const MPO_PROVISIONAL_REPLY_PORT: u32 = 16384;
pub const MPO_PROVISIONAL_ID_PROT_OPTOUT: u32 = 32768;
pub const GUARD_TYPE_MACH_PORT: u32 = 1;
pub const MAX_FATAL_kGUARD_EXC_CODE: u32 = 128;
pub const MPG_FLAGS_NONE: u32 = 0;
pub const MAX_OPTIONAL_kGUARD_EXC_CODE: u32 = 524288;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP: u64 = 72057594037927936;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT: u64 = 144115188075855872;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER: u64 = 288230376151711744;
pub const MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR: u64 = 576460752303423488;
pub const MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA: u64 = 1152921504606846976;
pub const MPG_FLAGS_STRICT_REPLY_MASK: i64 = -72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DEALLOC: u64 = 72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DESTROY: u64 = 144115188075855872;
pub const MPG_FLAGS_MOD_REFS_PINNED_COPYIN: u64 = 288230376151711744;
pub const MPG_FLAGS_IMMOVABLE_PINNED: u64 = 72057594037927936;
pub const MPG_STRICT: u32 = 1;
pub const MPG_IMMOVABLE_RECEIVE: u32 = 2;
pub const __COREFOUNDATION_CFSOCKET__: u32 = 1;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: u32 = 200112;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_NOFOLLOW_ANY: u32 = 536870912;
pub const O_EXEC: u32 = 1073741824;
pub const O_SEARCH: u32 = 1074790400;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const AT_REALDEV: u32 = 512;
pub const AT_FDONLY: u32 = 1024;
pub const AT_SYMLINK_NOFOLLOW_ANY: u32 = 2048;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const O_DP_AUTHENTICATE: u32 = 4;
pub const AUTH_OPEN_NOAUTHFD: i32 = -1;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_OFD_SETLK: u32 = 90;
pub const F_OFD_SETLKW: u32 = 91;
pub const F_OFD_GETLK: u32 = 92;
pub const F_OFD_SETLKWTIMEOUT: u32 = 93;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const F_SPECULATIVE_READ: u32 = 101;
pub const F_GETPATH_NOFIRMLINK: u32 = 102;
pub const F_ADDFILESIGS_INFO: u32 = 103;
pub const F_ADDFILESUPPL: u32 = 104;
pub const F_GETSIGSINFO: u32 = 105;
pub const F_SETLEASE: u32 = 106;
pub const F_GETLEASE: u32 = 107;
pub const F_TRANSFEREXTENTS: u32 = 110;
pub const F_ATTRIBUTION_TAG: u32 = 111;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_ALLOCATEPERSIST: u32 = 8;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const USER_FSIGNATURES_CDHASH_LEN: u32 = 20;
pub const GETSIGSINFO_PLATFORM_BINARY: u32 = 1;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const ATTRIBUTION_NAME_MAX: u32 = 255;
pub const F_CREATE_TAG: u32 = 1;
pub const F_DELETE_TAG: u32 = 2;
pub const F_QUERY_TAG: u32 = 4;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const DISPATCH_API_VERSION: u32 = 20181008;
pub const OS_OBJECT_HAVE_OBJC_SUPPORT: u32 = 0;
pub const OS_OBJECT_USE_OBJC: u32 = 0;
pub const OS_OBJECT_SWIFT3: u32 = 0;
pub const OS_OBJECT_USE_OBJC_RETAIN_RELEASE: u32 = 0;
pub const __OS_WORKGROUP_ATTR_SIZE__: u32 = 60;
pub const __OS_WORKGROUP_INTERVAL_DATA_SIZE__: u32 = 56;
pub const __OS_WORKGROUP_JOIN_TOKEN_SIZE__: u32 = 36;
pub const _OS_WORKGROUP_ATTR_SIG_DEFAULT_INIT: u32 = 799564724;
pub const _OS_WORKGROUP_ATTR_SIG_EMPTY_INIT: u32 = 799564740;
pub const _OS_WORKGROUP_INTERVAL_DATA_SIG_INIT: u32 = 1386695757;
pub const DISPATCH_SWIFT3_OVERLAY: u32 = 0;
pub const TIME_MICROS_MAX: u32 = 1000000;
pub const SYSTEM_CLOCK: u32 = 0;
pub const CALENDAR_CLOCK: u32 = 1;
pub const REALTIME_CLOCK: u32 = 0;
pub const CLOCK_GET_TIME_RES: u32 = 1;
pub const CLOCK_ALARM_CURRES: u32 = 3;
pub const CLOCK_ALARM_MINRES: u32 = 4;
pub const CLOCK_ALARM_MAXRES: u32 = 5;
pub const NSEC_PER_USEC: u32 = 1000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const ALRMTYPE: u32 = 255;
pub const TIME_ABSOLUTE: u32 = 0;
pub const TIME_RELATIVE: u32 = 1;
pub const MSEC_PER_SEC: u32 = 1000;
pub const DISPATCH_TIME_NOW: u32 = 0;
pub const DISPATCH_TIME_FOREVER: i32 = -1;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const DISPATCH_APPLY_AUTO_AVAILABLE: u32 = 1;
pub const DISPATCH_QUEUE_PRIORITY_HIGH: u32 = 2;
pub const DISPATCH_QUEUE_PRIORITY_DEFAULT: u32 = 0;
pub const DISPATCH_QUEUE_PRIORITY_LOW: i32 = -2;
pub const DISPATCH_QUEUE_PRIORITY_BACKGROUND: i32 = -32768;
pub const KERN_SUCCESS: u32 = 0;
pub const KERN_INVALID_ADDRESS: u32 = 1;
pub const KERN_PROTECTION_FAILURE: u32 = 2;
pub const KERN_NO_SPACE: u32 = 3;
pub const KERN_INVALID_ARGUMENT: u32 = 4;
pub const KERN_FAILURE: u32 = 5;
pub const KERN_RESOURCE_SHORTAGE: u32 = 6;
pub const KERN_NOT_RECEIVER: u32 = 7;
pub const KERN_NO_ACCESS: u32 = 8;
pub const KERN_MEMORY_FAILURE: u32 = 9;
pub const KERN_MEMORY_ERROR: u32 = 10;
pub const KERN_ALREADY_IN_SET: u32 = 11;
pub const KERN_NOT_IN_SET: u32 = 12;
pub const KERN_NAME_EXISTS: u32 = 13;
pub const KERN_ABORTED: u32 = 14;
pub const KERN_INVALID_NAME: u32 = 15;
pub const KERN_INVALID_TASK: u32 = 16;
pub const KERN_INVALID_RIGHT: u32 = 17;
pub const KERN_INVALID_VALUE: u32 = 18;
pub const KERN_UREFS_OVERFLOW: u32 = 19;
pub const KERN_INVALID_CAPABILITY: u32 = 20;
pub const KERN_RIGHT_EXISTS: u32 = 21;
pub const KERN_INVALID_HOST: u32 = 22;
pub const KERN_MEMORY_PRESENT: u32 = 23;
pub const KERN_MEMORY_DATA_MOVED: u32 = 24;
pub const KERN_MEMORY_RESTART_COPY: u32 = 25;
pub const KERN_INVALID_PROCESSOR_SET: u32 = 26;
pub const KERN_POLICY_LIMIT: u32 = 27;
pub const KERN_INVALID_POLICY: u32 = 28;
pub const KERN_INVALID_OBJECT: u32 = 29;
pub const KERN_ALREADY_WAITING: u32 = 30;
pub const KERN_DEFAULT_SET: u32 = 31;
pub const KERN_EXCEPTION_PROTECTED: u32 = 32;
pub const KERN_INVALID_LEDGER: u32 = 33;
pub const KERN_INVALID_MEMORY_CONTROL: u32 = 34;
pub const KERN_INVALID_SECURITY: u32 = 35;
pub const KERN_NOT_DEPRESSED: u32 = 36;
pub const KERN_TERMINATED: u32 = 37;
pub const KERN_LOCK_SET_DESTROYED: u32 = 38;
pub const KERN_LOCK_UNSTABLE: u32 = 39;
pub const KERN_LOCK_OWNED: u32 = 40;
pub const KERN_LOCK_OWNED_SELF: u32 = 41;
pub const KERN_SEMAPHORE_DESTROYED: u32 = 42;
pub const KERN_RPC_SERVER_TERMINATED: u32 = 43;
pub const KERN_RPC_TERMINATE_ORPHAN: u32 = 44;
pub const KERN_RPC_CONTINUE_ORPHAN: u32 = 45;
pub const KERN_NOT_SUPPORTED: u32 = 46;
pub const KERN_NODE_DOWN: u32 = 47;
pub const KERN_NOT_WAITING: u32 = 48;
pub const KERN_OPERATION_TIMED_OUT: u32 = 49;
pub const KERN_CODESIGN_ERROR: u32 = 50;
pub const KERN_POLICY_STATIC: u32 = 51;
pub const KERN_INSUFFICIENT_BUFFER_SIZE: u32 = 52;
pub const KERN_DENIED: u32 = 53;
pub const KERN_MISSING_KC: u32 = 54;
pub const KERN_INVALID_KC: u32 = 55;
pub const KERN_NOT_FOUND: u32 = 56;
pub const KERN_RETURN_MAX: u32 = 256;
pub const MACH_MSGH_BITS_ZERO: u32 = 0;
pub const MACH_MSGH_BITS_REMOTE_MASK: u32 = 31;
pub const MACH_MSGH_BITS_LOCAL_MASK: u32 = 7936;
pub const MACH_MSGH_BITS_VOUCHER_MASK: u32 = 2031616;
pub const MACH_MSGH_BITS_PORTS_MASK: u32 = 2039583;
pub const MACH_MSGH_BITS_COMPLEX: u32 = 2147483648;
pub const MACH_MSGH_BITS_USER: u32 = 2149523231;
pub const MACH_MSGH_BITS_RAISEIMP: u32 = 536870912;
pub const MACH_MSGH_BITS_DENAP: u32 = 536870912;
pub const MACH_MSGH_BITS_IMPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_DENAPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_CIRCULAR: u32 = 268435456;
pub const MACH_MSGH_BITS_USED: u32 = 2954829599;
pub const MACH_MSG_TYPE_MOVE_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_MOVE_SEND: u32 = 17;
pub const MACH_MSG_TYPE_MOVE_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_COPY_SEND: u32 = 19;
pub const MACH_MSG_TYPE_MAKE_SEND: u32 = 20;
pub const MACH_MSG_TYPE_MAKE_SEND_ONCE: u32 = 21;
pub const MACH_MSG_TYPE_COPY_RECEIVE: u32 = 22;
pub const MACH_MSG_TYPE_DISPOSE_RECEIVE: u32 = 24;
pub const MACH_MSG_TYPE_DISPOSE_SEND: u32 = 25;
pub const MACH_MSG_TYPE_DISPOSE_SEND_ONCE: u32 = 26;
pub const MACH_MSG_PHYSICAL_COPY: u32 = 0;
pub const MACH_MSG_VIRTUAL_COPY: u32 = 1;
pub const MACH_MSG_ALLOCATE: u32 = 2;
pub const MACH_MSG_OVERWRITE: u32 = 3;
pub const MACH_MSG_GUARD_FLAGS_NONE: u32 = 0;
pub const MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE: u32 = 1;
pub const MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND: u32 = 2;
pub const MACH_MSG_GUARD_FLAGS_MASK: u32 = 3;
pub const MACH_MSG_PORT_DESCRIPTOR: u32 = 0;
pub const MACH_MSG_OOL_DESCRIPTOR: u32 = 1;
pub const MACH_MSG_OOL_PORTS_DESCRIPTOR: u32 = 2;
pub const MACH_MSG_OOL_VOLATILE_DESCRIPTOR: u32 = 3;
pub const MACH_MSG_GUARDED_PORT_DESCRIPTOR: u32 = 4;
pub const MACH_MSG_DESCRIPTOR_MAX: u32 = 4;
pub const MACH_MSG_TRAILER_FORMAT_0: u32 = 0;
pub const MACH_MSGH_KIND_NORMAL: u32 = 0;
pub const MACH_MSGH_KIND_NOTIFICATION: u32 = 1;
pub const MACH_MSG_TYPE_PORT_NONE: u32 = 0;
pub const MACH_MSG_TYPE_PORT_NAME: u32 = 15;
pub const MACH_MSG_TYPE_PORT_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_PORT_SEND: u32 = 17;
pub const MACH_MSG_TYPE_PORT_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_LAST: u32 = 22;
pub const MACH_MSG_OPTION_NONE: u32 = 0;
pub const MACH_SEND_MSG: u32 = 1;
pub const MACH_RCV_MSG: u32 = 2;
pub const MACH_RCV_LARGE: u32 = 4;
pub const MACH_RCV_LARGE_IDENTITY: u32 = 8;
pub const MACH_SEND_TIMEOUT: u32 = 16;
pub const MACH_SEND_OVERRIDE: u32 = 32;
pub const MACH_SEND_INTERRUPT: u32 = 64;
pub const MACH_SEND_NOTIFY: u32 = 128;
pub const MACH_SEND_ALWAYS: u32 = 65536;
pub const MACH_SEND_FILTER_NONFATAL: u32 = 65536;
pub const MACH_SEND_TRAILER: u32 = 131072;
pub const MACH_SEND_NOIMPORTANCE: u32 = 262144;
pub const MACH_SEND_NODENAP: u32 = 262144;
pub const MACH_SEND_IMPORTANCE: u32 = 524288;
pub const MACH_SEND_SYNC_OVERRIDE: u32 = 1048576;
pub const MACH_SEND_PROPAGATE_QOS: u32 = 2097152;
pub const MACH_SEND_SYNC_USE_THRPRI: u32 = 2097152;
pub const MACH_SEND_KERNEL: u32 = 4194304;
pub const MACH_SEND_SYNC_BOOTSTRAP_CHECKIN: u32 = 8388608;
pub const MACH_RCV_TIMEOUT: u32 = 256;
pub const MACH_RCV_NOTIFY: u32 = 0;
pub const MACH_RCV_INTERRUPT: u32 = 1024;
pub const MACH_RCV_VOUCHER: u32 = 2048;
pub const MACH_RCV_OVERWRITE: u32 = 0;
pub const MACH_RCV_GUARDED_DESC: u32 = 4096;
pub const MACH_RCV_SYNC_WAIT: u32 = 16384;
pub const MACH_RCV_SYNC_PEEK: u32 = 32768;
pub const MACH_MSG_STRICT_REPLY: u32 = 512;
pub const MACH_RCV_TRAILER_NULL: u32 = 0;
pub const MACH_RCV_TRAILER_SEQNO: u32 = 1;
pub const MACH_RCV_TRAILER_SENDER: u32 = 2;
pub const MACH_RCV_TRAILER_AUDIT: u32 = 3;
pub const MACH_RCV_TRAILER_CTX: u32 = 4;
pub const MACH_RCV_TRAILER_AV: u32 = 7;
pub const MACH_RCV_TRAILER_LABELS: u32 = 8;
pub const MACH_RCV_TRAILER_MASK: u32 = 251658240;
pub const MACH_MSG_SUCCESS: u32 = 0;
pub const MACH_MSG_MASK: u32 = 15872;
pub const MACH_MSG_IPC_SPACE: u32 = 8192;
pub const MACH_MSG_VM_SPACE: u32 = 4096;
pub const MACH_MSG_IPC_KERNEL: u32 = 2048;
pub const MACH_MSG_VM_KERNEL: u32 = 1024;
pub const MACH_SEND_IN_PROGRESS: u32 = 268435457;
pub const MACH_SEND_INVALID_DATA: u32 = 268435458;
pub const MACH_SEND_INVALID_DEST: u32 = 268435459;
pub const MACH_SEND_TIMED_OUT: u32 = 268435460;
pub const MACH_SEND_INVALID_VOUCHER: u32 = 268435461;
pub const MACH_SEND_INTERRUPTED: u32 = 268435463;
pub const MACH_SEND_MSG_TOO_SMALL: u32 = 268435464;
pub const MACH_SEND_INVALID_REPLY: u32 = 268435465;
pub const MACH_SEND_INVALID_RIGHT: u32 = 268435466;
pub const MACH_SEND_INVALID_NOTIFY: u32 = 268435467;
pub const MACH_SEND_INVALID_MEMORY: u32 = 268435468;
pub const MACH_SEND_NO_BUFFER: u32 = 268435469;
pub const MACH_SEND_TOO_LARGE: u32 = 268435470;
pub const MACH_SEND_INVALID_TYPE: u32 = 268435471;
pub const MACH_SEND_INVALID_HEADER: u32 = 268435472;
pub const MACH_SEND_INVALID_TRAILER: u32 = 268435473;
pub const MACH_SEND_INVALID_CONTEXT: u32 = 268435474;
pub const MACH_SEND_INVALID_OPTIONS: u32 = 268435475;
pub const MACH_SEND_INVALID_RT_OOL_SIZE: u32 = 268435477;
pub const MACH_SEND_NO_GRANT_DEST: u32 = 268435478;
pub const MACH_SEND_MSG_FILTERED: u32 = 268435479;
pub const MACH_SEND_AUX_TOO_SMALL: u32 = 268435480;
pub const MACH_SEND_AUX_TOO_LARGE: u32 = 268435481;
pub const MACH_RCV_IN_PROGRESS: u32 = 268451841;
pub const MACH_RCV_INVALID_NAME: u32 = 268451842;
pub const MACH_RCV_TIMED_OUT: u32 = 268451843;
pub const MACH_RCV_TOO_LARGE: u32 = 268451844;
pub const MACH_RCV_INTERRUPTED: u32 = 268451845;
pub const MACH_RCV_PORT_CHANGED: u32 = 268451846;
pub const MACH_RCV_INVALID_NOTIFY: u32 = 268451847;
pub const MACH_RCV_INVALID_DATA: u32 = 268451848;
pub const MACH_RCV_PORT_DIED: u32 = 268451849;
pub const MACH_RCV_IN_SET: u32 = 268451850;
pub const MACH_RCV_HEADER_ERROR: u32 = 268451851;
pub const MACH_RCV_BODY_ERROR: u32 = 268451852;
pub const MACH_RCV_INVALID_TYPE: u32 = 268451853;
pub const MACH_RCV_SCATTER_SMALL: u32 = 268451854;
pub const MACH_RCV_INVALID_TRAILER: u32 = 268451855;
pub const MACH_RCV_IN_PROGRESS_TIMED: u32 = 268451857;
pub const MACH_RCV_INVALID_REPLY: u32 = 268451858;
pub const MACH_RCV_INVALID_ARGUMENTS: u32 = 268451859;
pub const DISPATCH_MACH_SEND_DEAD: u32 = 1;
pub const DISPATCH_MEMORYPRESSURE_NORMAL: u32 = 1;
pub const DISPATCH_MEMORYPRESSURE_WARN: u32 = 2;
pub const DISPATCH_MEMORYPRESSURE_CRITICAL: u32 = 4;
pub const DISPATCH_PROC_EXIT: u32 = 2147483648;
pub const DISPATCH_PROC_FORK: u32 = 1073741824;
pub const DISPATCH_PROC_EXEC: u32 = 536870912;
pub const DISPATCH_PROC_SIGNAL: u32 = 134217728;
pub const DISPATCH_VNODE_DELETE: u32 = 1;
pub const DISPATCH_VNODE_WRITE: u32 = 2;
pub const DISPATCH_VNODE_EXTEND: u32 = 4;
pub const DISPATCH_VNODE_ATTRIB: u32 = 8;
pub const DISPATCH_VNODE_LINK: u32 = 16;
pub const DISPATCH_VNODE_RENAME: u32 = 32;
pub const DISPATCH_VNODE_REVOKE: u32 = 64;
pub const DISPATCH_VNODE_FUNLOCK: u32 = 256;
pub const DISPATCH_TIMER_STRICT: u32 = 1;
pub const DISPATCH_ONCE_INLINE_FASTPATH: u32 = 1;
pub const DISPATCH_IO_STREAM: u32 = 0;
pub const DISPATCH_IO_RANDOM: u32 = 1;
pub const DISPATCH_IO_STOP: u32 = 1;
pub const DISPATCH_IO_STRICT_INTERVAL: u32 = 1;
pub const __COREFOUNDATION_CFSET__: u32 = 1;
pub const __COREFOUNDATION_CFSTRINGENCODINGEXT__: u32 = 1;
pub const __COREFOUNDATION_CFTREE__: u32 = 1;
pub const __COREFOUNDATION_CFURLACCESS__: u32 = 1;
pub const __COREFOUNDATION_CFUUID__: u32 = 1;
pub const __COREFOUNDATION_CFUTILITIES__: u32 = 1;
pub const __COREFOUNDATION_CFBUNDLE__: u32 = 1;
pub const CPU_STATE_MAX: u32 = 4;
pub const CPU_STATE_USER: u32 = 0;
pub const CPU_STATE_SYSTEM: u32 = 1;
pub const CPU_STATE_IDLE: u32 = 2;
pub const CPU_STATE_NICE: u32 = 3;
pub const CPU_ARCH_MASK: u32 = 4278190080;
pub const CPU_ARCH_ABI64: u32 = 16777216;
pub const CPU_ARCH_ABI64_32: u32 = 33554432;
pub const CPU_SUBTYPE_MASK: u32 = 4278190080;
pub const CPU_SUBTYPE_LIB64: u32 = 2147483648;
pub const CPU_SUBTYPE_PTRAUTH_ABI: u32 = 2147483648;
pub const CPU_SUBTYPE_INTEL_FAMILY_MAX: u32 = 15;
pub const CPU_SUBTYPE_INTEL_MODEL_ALL: u32 = 0;
pub const CPU_SUBTYPE_ARM64_PTR_AUTH_MASK: u32 = 251658240;
pub const CPUFAMILY_UNKNOWN: u32 = 0;
pub const CPUFAMILY_POWERPC_G3: u32 = 3471054153;
pub const CPUFAMILY_POWERPC_G4: u32 = 2009171118;
pub const CPUFAMILY_POWERPC_G5: u32 = 3983988906;
pub const CPUFAMILY_INTEL_6_13: u32 = 2855483691;
pub const CPUFAMILY_INTEL_PENRYN: u32 = 2028621756;
pub const CPUFAMILY_INTEL_NEHALEM: u32 = 1801080018;
pub const CPUFAMILY_INTEL_WESTMERE: u32 = 1463508716;
pub const CPUFAMILY_INTEL_SANDYBRIDGE: u32 = 1418770316;
pub const CPUFAMILY_INTEL_IVYBRIDGE: u32 = 526772277;
pub const CPUFAMILY_INTEL_HASWELL: u32 = 280134364;
pub const CPUFAMILY_INTEL_BROADWELL: u32 = 1479463068;
pub const CPUFAMILY_INTEL_SKYLAKE: u32 = 939270559;
pub const CPUFAMILY_INTEL_KABYLAKE: u32 = 260141638;
pub const CPUFAMILY_INTEL_ICELAKE: u32 = 943936839;
pub const CPUFAMILY_INTEL_COMETLAKE: u32 = 486055998;
pub const CPUFAMILY_ARM_9: u32 = 3878847406;
pub const CPUFAMILY_ARM_11: u32 = 2415272152;
pub const CPUFAMILY_ARM_XSCALE: u32 = 1404044789;
pub const CPUFAMILY_ARM_12: u32 = 3172666089;
pub const CPUFAMILY_ARM_13: u32 = 214503012;
pub const CPUFAMILY_ARM_14: u32 = 2517073649;
pub const CPUFAMILY_ARM_15: u32 = 2823887818;
pub const CPUFAMILY_ARM_SWIFT: u32 = 506291073;
pub const CPUFAMILY_ARM_CYCLONE: u32 = 933271106;
pub const CPUFAMILY_ARM_TYPHOON: u32 = 747742334;
pub const CPUFAMILY_ARM_TWISTER: u32 = 2465937352;
pub const CPUFAMILY_ARM_HURRICANE: u32 = 1741614739;
pub const CPUFAMILY_ARM_MONSOON_MISTRAL: u32 = 3894312694;
pub const CPUFAMILY_ARM_VORTEX_TEMPEST: u32 = 131287967;
pub const CPUFAMILY_ARM_LIGHTNING_THUNDER: u32 = 1176831186;
pub const CPUFAMILY_ARM_FIRESTORM_ICESTORM: u32 = 458787763;
pub const CPUFAMILY_ARM_BLIZZARD_AVALANCHE: u32 = 3660830781;
pub const CPUFAMILY_ARM_EVEREST_SAWTOOTH: u32 = 2271604202;
pub const CPUFAMILY_ARM_IBIZA: u32 = 4197663070;
pub const CPUFAMILY_ARM_PALMA: u32 = 1912690738;
pub const CPUFAMILY_ARM_COLL: u32 = 678884789;
pub const CPUFAMILY_ARM_LOBOS: u32 = 1598941843;
pub const CPUFAMILY_ARM_DONAN: u32 = 1867590060;
pub const CPUSUBFAMILY_UNKNOWN: u32 = 0;
pub const CPUSUBFAMILY_ARM_HP: u32 = 1;
pub const CPUSUBFAMILY_ARM_HG: u32 = 2;
pub const CPUSUBFAMILY_ARM_M: u32 = 3;
pub const CPUSUBFAMILY_ARM_HS: u32 = 4;
pub const CPUSUBFAMILY_ARM_HC_HD: u32 = 5;
pub const CPUSUBFAMILY_ARM_HA: u32 = 6;
pub const CPUFAMILY_INTEL_6_23: u32 = 2028621756;
pub const CPUFAMILY_INTEL_6_26: u32 = 1801080018;
pub const __COREFOUNDATION_CFMESSAGEPORT__: u32 = 1;
pub const __COREFOUNDATION_CFPLUGIN__: u32 = 1;
pub const COREFOUNDATION_CFPLUGINCOM_SEPARATE: u32 = 1;
pub const __COREFOUNDATION_CFMACHPORT__: u32 = 1;
pub const __COREFOUNDATION_CFATTRIBUTEDSTRING__: u32 = 1;
pub const __COREFOUNDATION_CFURLENUMERATOR__: u32 = 1;
pub const __COREFOUNDATION_CFFILESECURITY__: u32 = 1;
pub const KAUTH_GUID_SIZE: u32 = 16;
pub const KAUTH_NTSID_MAX_AUTHORITIES: u32 = 16;
pub const KAUTH_NTSID_HDRSIZE: u32 = 8;
pub const KAUTH_EXTLOOKUP_SUCCESS: u32 = 0;
pub const KAUTH_EXTLOOKUP_BADRQ: u32 = 1;
pub const KAUTH_EXTLOOKUP_FAILURE: u32 = 2;
pub const KAUTH_EXTLOOKUP_FATAL: u32 = 3;
pub const KAUTH_EXTLOOKUP_INPROG: u32 = 100;
pub const KAUTH_EXTLOOKUP_VALID_UID: u32 = 1;
pub const KAUTH_EXTLOOKUP_VALID_UGUID: u32 = 2;
pub const KAUTH_EXTLOOKUP_VALID_USID: u32 = 4;
pub const KAUTH_EXTLOOKUP_VALID_GID: u32 = 8;
pub const KAUTH_EXTLOOKUP_VALID_GGUID: u32 = 16;
pub const KAUTH_EXTLOOKUP_VALID_GSID: u32 = 32;
pub const KAUTH_EXTLOOKUP_WANT_UID: u32 = 64;
pub const KAUTH_EXTLOOKUP_WANT_UGUID: u32 = 128;
pub const KAUTH_EXTLOOKUP_WANT_USID: u32 = 256;
pub const KAUTH_EXTLOOKUP_WANT_GID: u32 = 512;
pub const KAUTH_EXTLOOKUP_WANT_GGUID: u32 = 1024;
pub const KAUTH_EXTLOOKUP_WANT_GSID: u32 = 2048;
pub const KAUTH_EXTLOOKUP_WANT_MEMBERSHIP: u32 = 4096;
pub const KAUTH_EXTLOOKUP_VALID_MEMBERSHIP: u32 = 8192;
pub const KAUTH_EXTLOOKUP_ISMEMBER: u32 = 16384;
pub const KAUTH_EXTLOOKUP_VALID_PWNAM: u32 = 32768;
pub const KAUTH_EXTLOOKUP_WANT_PWNAM: u32 = 65536;
pub const KAUTH_EXTLOOKUP_VALID_GRNAM: u32 = 131072;
pub const KAUTH_EXTLOOKUP_WANT_GRNAM: u32 = 262144;
pub const KAUTH_EXTLOOKUP_VALID_SUPGRPS: u32 = 524288;
pub const KAUTH_EXTLOOKUP_WANT_SUPGRPS: u32 = 1048576;
pub const KAUTH_EXTLOOKUP_REGISTER: u32 = 0;
pub const KAUTH_EXTLOOKUP_RESULT: u32 = 1;
pub const KAUTH_EXTLOOKUP_WORKER: u32 = 2;
pub const KAUTH_EXTLOOKUP_DEREGISTER: u32 = 4;
pub const KAUTH_GET_CACHE_SIZES: u32 = 8;
pub const KAUTH_SET_CACHE_SIZES: u32 = 16;
pub const KAUTH_CLEAR_CACHES: u32 = 32;
pub const IDENTITYSVC_ENTITLEMENT: &[u8; 30] = b"com.apple.private.identitysvc\0";
pub const KAUTH_ACE_KINDMASK: u32 = 15;
pub const KAUTH_ACE_PERMIT: u32 = 1;
pub const KAUTH_ACE_DENY: u32 = 2;
pub const KAUTH_ACE_AUDIT: u32 = 3;
pub const KAUTH_ACE_ALARM: u32 = 4;
pub const KAUTH_ACE_INHERITED: u32 = 16;
pub const KAUTH_ACE_FILE_INHERIT: u32 = 32;
pub const KAUTH_ACE_DIRECTORY_INHERIT: u32 = 64;
pub const KAUTH_ACE_LIMIT_INHERIT: u32 = 128;
pub const KAUTH_ACE_ONLY_INHERIT: u32 = 256;
pub const KAUTH_ACE_SUCCESS: u32 = 512;
pub const KAUTH_ACE_FAILURE: u32 = 1024;
pub const KAUTH_ACE_INHERIT_CONTROL_FLAGS: u32 = 480;
pub const KAUTH_ACE_GENERIC_ALL: u32 = 2097152;
pub const KAUTH_ACE_GENERIC_EXECUTE: u32 = 4194304;
pub const KAUTH_ACE_GENERIC_WRITE: u32 = 8388608;
pub const KAUTH_ACE_GENERIC_READ: u32 = 16777216;
pub const KAUTH_ACL_MAX_ENTRIES: u32 = 128;
pub const KAUTH_ACL_FLAGS_PRIVATE: u32 = 65535;
pub const KAUTH_ACL_DEFER_INHERIT: u32 = 65536;
pub const KAUTH_ACL_NO_INHERIT: u32 = 131072;
pub const KAUTH_FILESEC_MAGIC: u32 = 19710317;
pub const KAUTH_FILESEC_FLAGS_PRIVATE: u32 = 65535;
pub const KAUTH_FILESEC_DEFER_INHERIT: u32 = 65536;
pub const KAUTH_FILESEC_NO_INHERIT: u32 = 131072;
pub const KAUTH_FILESEC_XATTR: &[u8; 26] = b"com.apple.system.Security\0";
pub const KAUTH_ENDIAN_HOST: u32 = 1;
pub const KAUTH_ENDIAN_DISK: u32 = 2;
pub const KAUTH_VNODE_READ_DATA: u32 = 2;
pub const KAUTH_VNODE_LIST_DIRECTORY: u32 = 2;
pub const KAUTH_VNODE_WRITE_DATA: u32 = 4;
pub const KAUTH_VNODE_ADD_FILE: u32 = 4;
pub const KAUTH_VNODE_EXECUTE: u32 = 8;
pub const KAUTH_VNODE_SEARCH: u32 = 8;
pub const KAUTH_VNODE_DELETE: u32 = 16;
pub const KAUTH_VNODE_APPEND_DATA: u32 = 32;
pub const KAUTH_VNODE_ADD_SUBDIRECTORY: u32 = 32;
pub const KAUTH_VNODE_DELETE_CHILD: u32 = 64;
pub const KAUTH_VNODE_READ_ATTRIBUTES: u32 = 128;
pub const KAUTH_VNODE_WRITE_ATTRIBUTES: u32 = 256;
pub const KAUTH_VNODE_READ_EXTATTRIBUTES: u32 = 512;
pub const KAUTH_VNODE_WRITE_EXTATTRIBUTES: u32 = 1024;
pub const KAUTH_VNODE_READ_SECURITY: u32 = 2048;
pub const KAUTH_VNODE_WRITE_SECURITY: u32 = 4096;
pub const KAUTH_VNODE_TAKE_OWNERSHIP: u32 = 8192;
pub const KAUTH_VNODE_CHANGE_OWNER: u32 = 8192;
pub const KAUTH_VNODE_SYNCHRONIZE: u32 = 1048576;
pub const KAUTH_VNODE_LINKTARGET: u32 = 33554432;
pub const KAUTH_VNODE_CHECKIMMUTABLE: u32 = 67108864;
pub const KAUTH_VNODE_ACCESS: u32 = 2147483648;
pub const KAUTH_VNODE_NOIMMUTABLE: u32 = 1073741824;
pub const KAUTH_VNODE_SEARCHBYANYONE: u32 = 536870912;
pub const KAUTH_VNODE_GENERIC_READ_BITS: u32 = 2690;
pub const KAUTH_VNODE_GENERIC_WRITE_BITS: u32 = 5492;
pub const KAUTH_VNODE_GENERIC_EXECUTE_BITS: u32 = 8;
pub const KAUTH_VNODE_GENERIC_ALL_BITS: u32 = 8190;
pub const KAUTH_VNODE_WRITE_RIGHTS: u32 = 100676980;
pub const __DARWIN_ACL_READ_DATA: u32 = 2;
pub const __DARWIN_ACL_LIST_DIRECTORY: u32 = 2;
pub const __DARWIN_ACL_WRITE_DATA: u32 = 4;
pub const __DARWIN_ACL_ADD_FILE: u32 = 4;
pub const __DARWIN_ACL_EXECUTE: u32 = 8;
pub const __DARWIN_ACL_SEARCH: u32 = 8;
pub const __DARWIN_ACL_DELETE: u32 = 16;
pub const __DARWIN_ACL_APPEND_DATA: u32 = 32;
pub const __DARWIN_ACL_ADD_SUBDIRECTORY: u32 = 32;
pub const __DARWIN_ACL_DELETE_CHILD: u32 = 64;
pub const __DARWIN_ACL_READ_ATTRIBUTES: u32 = 128;
pub const __DARWIN_ACL_WRITE_ATTRIBUTES: u32 = 256;
pub const __DARWIN_ACL_READ_EXTATTRIBUTES: u32 = 512;
pub const __DARWIN_ACL_WRITE_EXTATTRIBUTES: u32 = 1024;
pub const __DARWIN_ACL_READ_SECURITY: u32 = 2048;
pub const __DARWIN_ACL_WRITE_SECURITY: u32 = 4096;
pub const __DARWIN_ACL_CHANGE_OWNER: u32 = 8192;
pub const __DARWIN_ACL_SYNCHRONIZE: u32 = 1048576;
pub const __DARWIN_ACL_EXTENDED_ALLOW: u32 = 1;
pub const __DARWIN_ACL_EXTENDED_DENY: u32 = 2;
pub const __DARWIN_ACL_ENTRY_INHERITED: u32 = 16;
pub const __DARWIN_ACL_ENTRY_FILE_INHERIT: u32 = 32;
pub const __DARWIN_ACL_ENTRY_DIRECTORY_INHERIT: u32 = 64;
pub const __DARWIN_ACL_ENTRY_LIMIT_INHERIT: u32 = 128;
pub const __DARWIN_ACL_ENTRY_ONLY_INHERIT: u32 = 256;
pub const __DARWIN_ACL_FLAG_NO_INHERIT: u32 = 131072;
pub const ACL_MAX_ENTRIES: u32 = 128;
pub const __COREFOUNDATION_CFSTRINGTOKENIZER__: u32 = 1;
pub const __COREFOUNDATION_CFFILEDESCRIPTOR__: u32 = 1;
pub const __COREFOUNDATION_CFUSERNOTIFICATION__: u32 = 1;
pub const __COREFOUNDATION_CFXMLNODE__: u32 = 1;
pub const __CFXMLNode_DEPRECATION_MSG : & [u8 ; 83] = b"CFXMLNode is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead\0" ;
pub const __COREFOUNDATION_CFXMLPARSER__: u32 = 1;
pub const __CFXMLParser_DEPRECATION_MSG : & [u8 ; 85] = b"CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead\0" ;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContextGroup {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextGroupRef A group that associates JavaScript contexts with one another. Contexts in the same group may share and exchange JavaScript objects."]
pub type JSContextGroupRef = *const OpaqueJSContextGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContext {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextRef A JavaScript execution context. Holds the global object and other execution state."]
pub type JSContextRef = *const OpaqueJSContext;
#[doc = " @typedef JSGlobalContextRef A global JavaScript execution context. A JSGlobalContext is a JSContext."]
pub type JSGlobalContextRef = *mut OpaqueJSContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSString {
    _unused: [u8; 0],
}
#[doc = " @typedef JSStringRef A UTF16 character buffer. The fundamental string representation in JavaScript."]
pub type JSStringRef = *mut OpaqueJSString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSClass {
    _unused: [u8; 0],
}
#[doc = " @typedef JSClassRef A JavaScript class. Used with JSObjectMake to construct objects with custom behavior."]
pub type JSClassRef = *mut OpaqueJSClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameArray {
    _unused: [u8; 0],
}
#[doc = " @typedef JSPropertyNameArrayRef An array of JavaScript property names."]
pub type JSPropertyNameArrayRef = *mut OpaqueJSPropertyNameArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameAccumulator {
    _unused: [u8; 0],
}
#[doc = " @typedef JSPropertyNameAccumulatorRef An ordered set used to collect the names of a JavaScript object's properties."]
pub type JSPropertyNameAccumulatorRef = *mut OpaqueJSPropertyNameAccumulator;
#[doc = " @typedef JSTypedArrayBytesDeallocator A function used to deallocate bytes passed to a Typed Array constructor. The function should take two arguments. The first is a pointer to the bytes that were originally passed to the Typed Array constructor. The second is a pointer to additional information desired at the time the bytes are to be freed."]
pub type JSTypedArrayBytesDeallocator = ::std::option::Option<
    unsafe extern "C" fn(
        bytes: *mut ::std::os::raw::c_void,
        deallocatorContext: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSValue {
    _unused: [u8; 0],
}
#[doc = " @typedef JSValueRef A JavaScript value. The base type for all JavaScript values, and polymorphic functions on them."]
pub type JSValueRef = *const OpaqueJSValue;
#[doc = " @typedef JSObjectRef A JavaScript object. A JSObject is a JSValue."]
pub type JSObjectRef = *mut OpaqueJSValue;
#[doc = "@typedef JSModuleLoaderResolve\n@abstract The callback invoked when resolving a module specifier.\n@param ctx The execution context to use.\n@param keyValue A JSValue containing the module specifier to resolve.\n@param referrerValue A JSValue containing the referrer URL.\n@param scriptFetcher A JSValue containing the script fetcher.\n@result A JSString containing the resolved module specifier."]
pub type JSModuleLoaderResolve = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        keyValue: JSValueRef,
        referrerValue: JSValueRef,
        scriptFetcher: JSValueRef,
    ) -> JSStringRef,
>;
#[doc = "@typedef JSModuleLoaderEvaluate\n@abstract The callback invoked when evaluating a module.\n@param ctx The execution context to use.\n@param key A JSValue containing the module specifier to evaluate.\n@param scriptFetcher A JSValue containing the script fetcher.\n@param sentValue A JSValue containing the value to send to the module.\n@param resumeMode A JSValue containing the resume mode.\n@result A JSValue containing the result of evaluating the module."]
pub type JSModuleLoaderEvaluate = ::std::option::Option<
    unsafe extern "C" fn(ctx: JSContextRef, key: JSValueRef) -> JSValueRef,
>;
#[doc = "@typedef JSModuleLoaderFetch\n@abstract The callback invoked when fetching a module.\n@param ctx The execution context to use.\n@param key A JSValue containing the module specifier to fetch.\n@param attributesValue A JSValue containing the attributes.\n@param scriptFetcher A JSValue containing the script fetcher.\n@result A JSStringRef containing the fetched module."]
pub type JSModuleLoaderFetch = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        key: JSValueRef,
        attributesValue: JSValueRef,
        scriptFetcher: JSValueRef,
    ) -> JSStringRef,
>;
#[doc = "@typedef JSModuleLoaderCreateImportMetaProperties\n@abstract The callback invoked when creating import meta properties.\n@param ctx The execution context to use.\n@param key A JSValue containing the module specifier.\n@param scriptFetcher A JSValue containing the script fetcher.\n@result A JSObjectRef containing the import meta properties."]
pub type JSModuleLoaderCreateImportMetaProperties = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        key: JSValueRef,
        scriptFetcher: JSValueRef,
    ) -> JSObjectRef,
>;
#[doc = "@struct JSAPIModuleLoader\n@abstract The callbacks used to load and evaluate modules.\n@field moduleLoaderResolve The callback used to resolve a module specifier.\n@field moduleLoaderEvaluate The callback used to evaluate a module.\n@field moduleLoaderFetch The callback used to fetch a module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSAPIModuleLoader {
    pub disableBuiltinFileSystemLoader: bool,
    pub moduleLoaderResolve: JSModuleLoaderResolve,
    pub moduleLoaderEvaluate: JSModuleLoaderEvaluate,
    pub moduleLoaderFetch: JSModuleLoaderFetch,
    pub moduleLoaderCreateImportMetaProperties: JSModuleLoaderCreateImportMetaProperties,
}
#[test]
fn bindgen_test_layout_JSAPIModuleLoader() {
    const UNINIT: ::std::mem::MaybeUninit<JSAPIModuleLoader> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JSAPIModuleLoader>(),
        40usize,
        concat!("Size of: ", stringify!(JSAPIModuleLoader))
    );
    assert_eq!(
        ::std::mem::align_of::<JSAPIModuleLoader>(),
        8usize,
        concat!("Alignment of ", stringify!(JSAPIModuleLoader))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disableBuiltinFileSystemLoader) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSAPIModuleLoader),
            "::",
            stringify!(disableBuiltinFileSystemLoader)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).moduleLoaderResolve) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSAPIModuleLoader),
            "::",
            stringify!(moduleLoaderResolve)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).moduleLoaderEvaluate) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSAPIModuleLoader),
            "::",
            stringify!(moduleLoaderEvaluate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moduleLoaderFetch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JSAPIModuleLoader),
            "::",
            stringify!(moduleLoaderFetch)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).moduleLoaderCreateImportMetaProperties) as usize
                - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JSAPIModuleLoader),
            "::",
            stringify!(moduleLoaderCreateImportMetaProperties)
        )
    );
}
#[doc = "@typedef JSUncaughtExceptionAtEventLoop\n@abstract The callback invoked when an exception is not caught in the event loop.\n@param ctx The execution context to use.\n@param exception A JSValue containing the uncaught exception."]
pub type JSUncaughtExceptionAtEventLoop =
    ::std::option::Option<unsafe extern "C" fn(ctx: JSContextRef, exception: JSValueRef)>;
#[doc = "@typedef JSUncaughtExceptionHandler\n@abstract The callback invoked when an exception is not caught.\n@param ctx The execution context to use.\n@param exception A JSValue containing the uncaught exception."]
pub type JSUncaughtExceptionHandler = ::std::option::Option<
    unsafe extern "C" fn(ctx: JSContextRef, filename: JSStringRef, exception: JSValueRef),
>;
extern "C" {
    #[doc = "@function JSSetAPIModuleLoader\n@abstract Sets the moduleLoader used to load and evaluate modules.\n@param ctx The execution context to use.\n@param moduleLoader A JSAPIModuleLoader structure containing the callbacks to use."]
    pub fn JSSetAPIModuleLoader(ctx: JSContextRef, moduleLoader: JSAPIModuleLoader);
}
extern "C" {
    #[doc = "@function JSEvaluateScript\n@abstract Evaluates a string of JavaScript.\n@param ctx The execution context to use.\n@param script A JSString containing the script to evaluate.\n@param thisObject The object to use as \"this,\" or NULL to use the global object as \"this.\"\n@param sourceURL A JSString containing a URL for the script's source file. This is used by debuggers and when reporting exceptions. Pass NULL if you do not care to include source file information.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSValue that results from evaluating script, or NULL if an exception is thrown."]
    pub fn JSEvaluateScript(
        ctx: JSContextRef,
        script: JSStringRef,
        thisObject: JSObjectRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function JSLoadAndEvaluateModule\n@abstract Evaluates a file containing JavaScript Code.\n@param ctx The execution context to use.\n@param filename A JSString containing the path to the module to evaluate."]
    pub fn JSLoadAndEvaluateModule(
        ctx: JSContextRef,
        filename: JSStringRef,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function JSLoadAndEvaluateModuleFromSource\n@abstract Evaluates a string of JavaScript as a module.\n@param ctx The execution context to use.\n@param module A JSString containing the module code to evaluate.\n@param sourceURLString A JSString containing a URL for the script's source file. This is used by debuggers and when reporting exceptions. Pass NULL if you do not care to include source file information.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSLoadAndEvaluateModuleFromSource(
        ctx: JSContextRef,
        module: JSStringRef,
        sourceURLString: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function JSLoadModule\n@abstract Loads a module.\n@param ctx The execution context to use.\n@param moduleKey A JSString containing the module key to load.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSLoadModule(
        ctx: JSContextRef,
        moduleKey: JSStringRef,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function JSLoadModuleFromSource\n@abstract Loads a module from a string of JavaScript.\n@param ctx The execution context to use.\n@param module A JSString containing the module code to load.\n@param sourceURLString A JSString containing a URL for the script's source file. This is used by debuggers and when reporting exceptions. Pass NULL if you do not care to include source file information.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSLoadModuleFromSource(
        ctx: JSContextRef,
        module: JSStringRef,
        sourceURLString: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function JSLinkAndEvaluateModule\n@abstract Links and evaluates a module.\n@param ctx The execution context to use.\n@param moduleKey A JSString containing the module key to link and evaluate.\n@result The JSValue that results from evaluating the module, or NULL if an exception is thrown."]
    pub fn JSLinkAndEvaluateModule(
        ctx: JSContextRef,
        moduleKey: JSStringRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function JSSetSyntheticModuleKeys\n@abstract Sets the synthetic module keys.\n@param ctx The execution context to use.\n@param argumentCount The number of keys.\n@param keys An array of JSString containing the keys.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSSetSyntheticModuleKeys(
        ctx: JSContextRef,
        argumentCount: usize,
        keys: *const JSStringRef,
    );
}
extern "C" {
    #[doc = "@function JSCheckScriptSyntax\n@abstract Checks for syntax errors in a string of JavaScript.\n@param ctx The execution context to use.\n@param script A JSString containing the script to check for syntax errors.\n@param sourceURL A JSString containing a URL for the script's source file. This is only used when reporting exceptions. Pass NULL if you do not care to include source file information in exceptions.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store a syntax error exception, if any. Pass NULL if you do not care to store a syntax error exception.\n@result true if the script is syntactically correct, otherwise false."]
    pub fn JSCheckScriptSyntax(
        ctx: JSContextRef,
        script: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function JSGarbageCollect\n@abstract Performs a JavaScript garbage collection.\n@param ctx The execution context to use.\n@discussion JavaScript values that are on the machine stack, in a register,\nprotected by JSValueProtect, set as the global object of an execution context,\nor reachable from any such value will not be collected.\n\nDuring JavaScript execution, you are not required to call this function; the\nJavaScript engine will garbage collect as needed. JavaScript values created\nwithin a context group are automatically destroyed when the last reference\nto the context group is released."]
    pub fn JSGarbageCollect(ctx: JSContextRef);
}
extern "C" {
    #[doc = "@function JSGetMemoryUsageStatistics\n@abstract Returns the current memory usage of a context.\n@param ctx The execution context to use.\n@result A JSObjectRef containing the memory usage statistics."]
    pub fn JSGetMemoryUsageStatistics(ctx: JSContextRef) -> JSObjectRef;
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> !;
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__types) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nranges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__nranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ranges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__ranges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneCharClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneLocale> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sgetrune) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sgetrune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sputrune) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sputrune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__invalid_rune) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__invalid_rune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__runetype) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__maplower) as usize - ptr as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mapupper) as usize - ptr as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__runetype_ext) as usize - ptr as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__maplower_ext) as usize - ptr as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mapupper_ext) as usize - ptr as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__variable) as usize - ptr as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__variable_len) as usize - ptr as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ncharclasses) as usize - ptr as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__ncharclasses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__charclasses) as usize - ptr as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__charclasses)
        )
    );
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    const UNINIT: ::std::mem::MaybeUninit<lconv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize
        },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn setlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    const UNINIT: ::std::mem::MaybeUninit<__float2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    const UNINIT: ::std::mem::MaybeUninit<__double2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    const UNINIT: ::std::mem::MaybeUninit<exception> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
pub type jmp_buf = [::std::os::raw::c_int; 48usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 49usize];
extern "C" {
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn sigsetjmp(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> !;
}
extern "C" {
    pub fn longjmperror();
}
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler:
        ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler:
        ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(
        arg1: *mut sigset_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(
        arg1: *mut sigset_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        arg1: *const sigset_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(
        arg1: ::std::os::raw::c_int,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize
                - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize
                - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize
                - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize
                - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_reserved: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize
                - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize
                - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_secure_time_in_system) as usize - ptr as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_time_in_system)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_secure_ptime_in_system) as usize - ptr as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_ptime_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(
        arg1: ::std::os::raw::c_int,
        arg2: *mut rlimit,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(
        arg1: ::std::os::raw::c_int,
        arg2: *mut rusage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(
        arg1: ::std::os::raw::c_int,
        arg2: *const rlimit,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(
        arg1: ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(
        arg1: *mut ::std::os::raw::c_char,
        arg2: wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(
        arg1: *mut f64,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(
        __rqtp: *const timespec,
        __rmtp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(
        __clock_id: clockid_t,
        __res: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(
        __clock_id: clockid_t,
        __tp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(
        __clock_id: clockid_t,
        __tp: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        ts: *mut timespec,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _Block_copy(
        aBlock: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _Block_release(aBlock: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _Block_object_assign(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _Block_object_dispose(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub static mut _NSConcreteGlobalBlock: [*mut ::std::os::raw::c_void; 32usize];
}
extern "C" {
    pub static mut _NSConcreteStackBlock: [*mut ::std::os::raw::c_void; 32usize];
}
pub type UInt8 = ::std::os::raw::c_uchar;
pub type SInt8 = ::std::os::raw::c_schar;
pub type UInt16 = ::std::os::raw::c_ushort;
pub type SInt16 = ::std::os::raw::c_short;
pub type UInt32 = ::std::os::raw::c_uint;
pub type SInt32 = ::std::os::raw::c_int;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct wide {
    pub lo: UInt32,
    pub hi: SInt32,
}
#[test]
fn bindgen_test_layout_wide() {
    const UNINIT: ::std::mem::MaybeUninit<wide> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wide>(),
        8usize,
        concat!("Size of: ", stringify!(wide))
    );
    assert_eq!(
        ::std::mem::align_of::<wide>(),
        2usize,
        concat!("Alignment of ", stringify!(wide))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wide), "::", stringify!(lo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(wide), "::", stringify!(hi))
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct UnsignedWide {
    pub lo: UInt32,
    pub hi: UInt32,
}
#[test]
fn bindgen_test_layout_UnsignedWide() {
    const UNINIT: ::std::mem::MaybeUninit<UnsignedWide> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UnsignedWide>(),
        8usize,
        concat!("Size of: ", stringify!(UnsignedWide))
    );
    assert_eq!(
        ::std::mem::align_of::<UnsignedWide>(),
        2usize,
        concat!("Alignment of ", stringify!(UnsignedWide))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UnsignedWide),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UnsignedWide),
            "::",
            stringify!(hi)
        )
    );
}
pub type SInt64 = ::std::os::raw::c_longlong;
pub type UInt64 = ::std::os::raw::c_ulonglong;
pub type Fixed = SInt32;
pub type FixedPtr = *mut Fixed;
pub type Fract = SInt32;
pub type FractPtr = *mut Fract;
pub type UnsignedFixed = UInt32;
pub type UnsignedFixedPtr = *mut UnsignedFixed;
pub type ShortFixed = ::std::os::raw::c_short;
pub type ShortFixedPtr = *mut ShortFixed;
pub type Float32 = f32;
pub type Float64 = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Float80 {
    pub exp: SInt16,
    pub man: [UInt16; 4usize],
}
#[test]
fn bindgen_test_layout_Float80() {
    const UNINIT: ::std::mem::MaybeUninit<Float80> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Float80>(),
        10usize,
        concat!("Size of: ", stringify!(Float80))
    );
    assert_eq!(
        ::std::mem::align_of::<Float80>(),
        2usize,
        concat!("Alignment of ", stringify!(Float80))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Float80),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).man) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Float80),
            "::",
            stringify!(man)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Float96 {
    pub exp: [SInt16; 2usize],
    pub man: [UInt16; 4usize],
}
#[test]
fn bindgen_test_layout_Float96() {
    const UNINIT: ::std::mem::MaybeUninit<Float96> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Float96>(),
        12usize,
        concat!("Size of: ", stringify!(Float96))
    );
    assert_eq!(
        ::std::mem::align_of::<Float96>(),
        2usize,
        concat!("Alignment of ", stringify!(Float96))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Float96),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).man) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Float96),
            "::",
            stringify!(man)
        )
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct Float32Point {
    pub x: Float32,
    pub y: Float32,
}
#[test]
fn bindgen_test_layout_Float32Point() {
    const UNINIT: ::std::mem::MaybeUninit<Float32Point> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Float32Point>(),
        8usize,
        concat!("Size of: ", stringify!(Float32Point))
    );
    assert_eq!(
        ::std::mem::align_of::<Float32Point>(),
        2usize,
        concat!("Alignment of ", stringify!(Float32Point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Float32Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Float32Point),
            "::",
            stringify!(y)
        )
    );
}
pub type Ptr = *mut ::std::os::raw::c_char;
pub type Handle = *mut Ptr;
pub type Size = ::std::os::raw::c_long;
pub type OSErr = SInt16;
pub type OSStatus = SInt32;
pub type LogicalAddress = *mut ::std::os::raw::c_void;
pub type ConstLogicalAddress = *const ::std::os::raw::c_void;
pub type PhysicalAddress = *mut ::std::os::raw::c_void;
pub type BytePtr = *mut UInt8;
pub type ByteCount = ::std::os::raw::c_ulong;
pub type ByteOffset = ::std::os::raw::c_ulong;
pub type Duration = SInt32;
pub type AbsoluteTime = UnsignedWide;
pub type OptionBits = UInt32;
pub type ItemCount = ::std::os::raw::c_ulong;
pub type PBVersion = UInt32;
pub type ScriptCode = SInt16;
pub type LangCode = SInt16;
pub type RegionCode = SInt16;
pub type FourCharCode = UInt32;
pub type OSType = FourCharCode;
pub type ResType = FourCharCode;
pub type OSTypePtr = *mut OSType;
pub type ResTypePtr = *mut ResType;
pub type Boolean = ::std::os::raw::c_uchar;
pub type ProcPtr =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type Register68kProcPtr = ::std::option::Option<unsafe extern "C" fn()>;
pub type UniversalProcPtr = ProcPtr;
pub type ProcHandle = *mut ProcPtr;
pub type UniversalProcHandle = *mut UniversalProcPtr;
pub type PRefCon = *mut ::std::os::raw::c_void;
pub type URefCon = *mut ::std::os::raw::c_void;
pub type SRefCon = *mut ::std::os::raw::c_void;
pub const noErr: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const kNilOptions: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const kVariableLengthArray: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const kUnknownType: _bindgen_ty_4 = 1061109567;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub type UnicodeScalarValue = UInt32;
pub type UTF32Char = UInt32;
pub type UniChar = UInt16;
pub type UTF16Char = UInt16;
pub type UTF8Char = UInt8;
pub type UniCharPtr = *mut UniChar;
pub type UniCharCount = ::std::os::raw::c_ulong;
pub type UniCharCountPtr = *mut UniCharCount;
pub type Str255 = [::std::os::raw::c_uchar; 256usize];
pub type Str63 = [::std::os::raw::c_uchar; 64usize];
pub type Str32 = [::std::os::raw::c_uchar; 33usize];
pub type Str31 = [::std::os::raw::c_uchar; 32usize];
pub type Str27 = [::std::os::raw::c_uchar; 28usize];
pub type Str15 = [::std::os::raw::c_uchar; 16usize];
pub type Str32Field = [::std::os::raw::c_uchar; 34usize];
pub type StrFileName = Str63;
pub type StringPtr = *mut ::std::os::raw::c_uchar;
pub type StringHandle = *mut StringPtr;
pub type ConstStringPtr = *const ::std::os::raw::c_uchar;
pub type ConstStr255Param = *const ::std::os::raw::c_uchar;
pub type ConstStr63Param = *const ::std::os::raw::c_uchar;
pub type ConstStr32Param = *const ::std::os::raw::c_uchar;
pub type ConstStr31Param = *const ::std::os::raw::c_uchar;
pub type ConstStr27Param = *const ::std::os::raw::c_uchar;
pub type ConstStr15Param = *const ::std::os::raw::c_uchar;
pub type ConstStrFileNameParam = ConstStr63Param;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct ProcessSerialNumber {
    pub highLongOfPSN: UInt32,
    pub lowLongOfPSN: UInt32,
}
#[test]
fn bindgen_test_layout_ProcessSerialNumber() {
    const UNINIT: ::std::mem::MaybeUninit<ProcessSerialNumber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ProcessSerialNumber>(),
        8usize,
        concat!("Size of: ", stringify!(ProcessSerialNumber))
    );
    assert_eq!(
        ::std::mem::align_of::<ProcessSerialNumber>(),
        2usize,
        concat!("Alignment of ", stringify!(ProcessSerialNumber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).highLongOfPSN) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessSerialNumber),
            "::",
            stringify!(highLongOfPSN)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowLongOfPSN) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessSerialNumber),
            "::",
            stringify!(lowLongOfPSN)
        )
    );
}
pub type ProcessSerialNumberPtr = *mut ProcessSerialNumber;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Point {
    pub v: ::std::os::raw::c_short,
    pub h: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_Point() {
    const UNINIT: ::std::mem::MaybeUninit<Point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Point>(),
        4usize,
        concat!("Size of: ", stringify!(Point))
    );
    assert_eq!(
        ::std::mem::align_of::<Point>(),
        2usize,
        concat!("Alignment of ", stringify!(Point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Point), "::", stringify!(v))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(Point), "::", stringify!(h))
    );
}
pub type PointPtr = *mut Point;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rect {
    pub top: ::std::os::raw::c_short,
    pub left: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_Rect() {
    const UNINIT: ::std::mem::MaybeUninit<Rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Rect>(),
        8usize,
        concat!("Size of: ", stringify!(Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<Rect>(),
        2usize,
        concat!("Alignment of ", stringify!(Rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Rect), "::", stringify!(top))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Rect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Rect),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Rect),
            "::",
            stringify!(right)
        )
    );
}
pub type RectPtr = *mut Rect;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct FixedPoint {
    pub x: Fixed,
    pub y: Fixed,
}
#[test]
fn bindgen_test_layout_FixedPoint() {
    const UNINIT: ::std::mem::MaybeUninit<FixedPoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FixedPoint>(),
        8usize,
        concat!("Size of: ", stringify!(FixedPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<FixedPoint>(),
        2usize,
        concat!("Alignment of ", stringify!(FixedPoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FixedPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FixedPoint),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct FixedRect {
    pub left: Fixed,
    pub top: Fixed,
    pub right: Fixed,
    pub bottom: Fixed,
}
#[test]
fn bindgen_test_layout_FixedRect() {
    const UNINIT: ::std::mem::MaybeUninit<FixedRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FixedRect>(),
        16usize,
        concat!("Size of: ", stringify!(FixedRect))
    );
    assert_eq!(
        ::std::mem::align_of::<FixedRect>(),
        2usize,
        concat!("Alignment of ", stringify!(FixedRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FixedRect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FixedRect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FixedRect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FixedRect),
            "::",
            stringify!(bottom)
        )
    );
}
pub type CharParameter = ::std::os::raw::c_short;
pub const normal: _bindgen_ty_5 = 0;
pub const bold: _bindgen_ty_5 = 1;
pub const italic: _bindgen_ty_5 = 2;
pub const underline: _bindgen_ty_5 = 4;
pub const outline: _bindgen_ty_5 = 8;
pub const shadow: _bindgen_ty_5 = 16;
pub const condense: _bindgen_ty_5 = 32;
pub const extend: _bindgen_ty_5 = 64;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub type Style = ::std::os::raw::c_uchar;
pub type StyleParameter = ::std::os::raw::c_short;
pub type StyleField = Style;
pub type TimeValue = SInt32;
pub type TimeScale = SInt32;
pub type CompTimeValue = wide;
pub type TimeValue64 = SInt64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeBaseRecord {
    _unused: [u8; 0],
}
pub type TimeBase = *mut TimeBaseRecord;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct TimeRecord {
    pub value: CompTimeValue,
    pub scale: TimeScale,
    pub base: TimeBase,
}
#[test]
fn bindgen_test_layout_TimeRecord() {
    const UNINIT: ::std::mem::MaybeUninit<TimeRecord> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TimeRecord>(),
        20usize,
        concat!("Size of: ", stringify!(TimeRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<TimeRecord>(),
        2usize,
        concat!("Alignment of ", stringify!(TimeRecord))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeRecord),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeRecord),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeRecord),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumVersion {
    pub nonRelRev: UInt8,
    pub stage: UInt8,
    pub minorAndBugRev: UInt8,
    pub majorRev: UInt8,
}
#[test]
fn bindgen_test_layout_NumVersion() {
    const UNINIT: ::std::mem::MaybeUninit<NumVersion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NumVersion>(),
        4usize,
        concat!("Size of: ", stringify!(NumVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<NumVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(NumVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonRelRev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(nonRelRev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stage) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minorAndBugRev) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(minorAndBugRev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).majorRev) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(majorRev)
        )
    );
}
pub const developStage: _bindgen_ty_6 = 32;
pub const alphaStage: _bindgen_ty_6 = 64;
pub const betaStage: _bindgen_ty_6 = 96;
pub const finalStage: _bindgen_ty_6 = 128;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union NumVersionVariant {
    pub parts: NumVersion,
    pub whole: UInt32,
}
#[test]
fn bindgen_test_layout_NumVersionVariant() {
    const UNINIT: ::std::mem::MaybeUninit<NumVersionVariant> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NumVersionVariant>(),
        4usize,
        concat!("Size of: ", stringify!(NumVersionVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<NumVersionVariant>(),
        2usize,
        concat!("Alignment of ", stringify!(NumVersionVariant))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersionVariant),
            "::",
            stringify!(parts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).whole) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersionVariant),
            "::",
            stringify!(whole)
        )
    );
}
pub type NumVersionVariantPtr = *mut NumVersionVariant;
pub type NumVersionVariantHandle = *mut NumVersionVariantPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VersRec {
    pub numericVersion: NumVersion,
    pub countryCode: ::std::os::raw::c_short,
    pub shortVersion: Str255,
    pub reserved: Str255,
}
#[test]
fn bindgen_test_layout_VersRec() {
    const UNINIT: ::std::mem::MaybeUninit<VersRec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VersRec>(),
        518usize,
        concat!("Size of: ", stringify!(VersRec))
    );
    assert_eq!(
        ::std::mem::align_of::<VersRec>(),
        2usize,
        concat!("Alignment of ", stringify!(VersRec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numericVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(numericVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).countryCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(countryCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shortVersion) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(shortVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(reserved)
        )
    );
}
pub type VersRecPtr = *mut VersRec;
pub type VersRecHndl = *mut VersRecPtr;
pub type Byte = UInt8;
pub type SignedByte = SInt8;
pub type WidePtr = *mut wide;
pub type UnsignedWidePtr = *mut UnsignedWide;
pub type extended80 = Float80;
pub type extended96 = Float96;
pub type VHSelect = SInt8;
extern "C" {
    pub fn Debugger();
}
extern "C" {
    pub fn DebugStr(debuggerMsg: ConstStr255Param);
}
extern "C" {
    pub fn SysBreak();
}
extern "C" {
    pub fn SysBreakStr(debuggerMsg: ConstStr255Param);
}
extern "C" {
    pub fn SysBreakFunc(debuggerMsg: ConstStr255Param);
}
extern "C" {
    pub static mut kCFCoreFoundationVersionNumber: f64;
}
pub type CFTypeID = ::std::os::raw::c_ulong;
pub type CFOptionFlags = ::std::os::raw::c_ulong;
pub type CFHashCode = ::std::os::raw::c_ulong;
pub type CFIndex = ::std::os::raw::c_long;
pub type CFTypeRef = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFString {
    _unused: [u8; 0],
}
pub type CFStringRef = *const __CFString;
pub type CFMutableStringRef = *mut __CFString;
pub type CFPropertyListRef = CFTypeRef;
pub type CFComparisonResult = CFIndex;
pub const kCFCompareLessThan: _bindgen_ty_7 = -1;
pub const kCFCompareEqualTo: _bindgen_ty_7 = 0;
pub const kCFCompareGreaterThan: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
pub type CFComparatorFunction = ::std::option::Option<
    unsafe extern "C" fn(
        val1: *const ::std::os::raw::c_void,
        val2: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ) -> CFComparisonResult,
>;
pub const kCFNotFound: CFIndex = -1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRange {
    pub location: CFIndex,
    pub length: CFIndex,
}
#[test]
fn bindgen_test_layout_CFRange() {
    const UNINIT: ::std::mem::MaybeUninit<CFRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFRange>(),
        16usize,
        concat!("Size of: ", stringify!(CFRange))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRange>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRange),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRange),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn __CFRangeMake(loc: CFIndex, len: CFIndex) -> CFRange;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNull {
    _unused: [u8; 0],
}
pub type CFNullRef = *const __CFNull;
extern "C" {
    pub fn CFNullGetTypeID() -> CFTypeID;
}
extern "C" {
    pub static kCFNull: CFNullRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAllocator {
    _unused: [u8; 0],
}
pub type CFAllocatorRef = *const __CFAllocator;
extern "C" {
    pub static kCFAllocatorDefault: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorSystemDefault: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorMalloc: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorMallocZone: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorNull: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorUseContext: CFAllocatorRef;
}
pub type CFAllocatorRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFAllocatorReleaseCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>;
pub type CFAllocatorCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFAllocatorAllocateCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocSize: CFIndex,
        hint: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CFAllocatorReallocateCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        newsize: CFIndex,
        hint: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CFAllocatorDeallocateCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFAllocatorPreferredSizeCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        size: CFIndex,
        hint: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ) -> CFIndex,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFAllocatorContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
    pub allocate: CFAllocatorAllocateCallBack,
    pub reallocate: CFAllocatorReallocateCallBack,
    pub deallocate: CFAllocatorDeallocateCallBack,
    pub preferredSize: CFAllocatorPreferredSizeCallBack,
}
#[test]
fn bindgen_test_layout_CFAllocatorContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFAllocatorContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFAllocatorContext>(),
        72usize,
        concat!("Size of: ", stringify!(CFAllocatorContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFAllocatorContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFAllocatorContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(allocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reallocate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(reallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deallocate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(deallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preferredSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(preferredSize)
        )
    );
}
extern "C" {
    pub fn CFAllocatorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFAllocatorSetDefault(allocator: CFAllocatorRef);
}
extern "C" {
    pub fn CFAllocatorGetDefault() -> CFAllocatorRef;
}
extern "C" {
    pub fn CFAllocatorCreate(
        allocator: CFAllocatorRef,
        context: *mut CFAllocatorContext,
    ) -> CFAllocatorRef;
}
extern "C" {
    pub fn CFAllocatorAllocate(
        allocator: CFAllocatorRef,
        size: CFIndex,
        hint: CFOptionFlags,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFAllocatorReallocate(
        allocator: CFAllocatorRef,
        ptr: *mut ::std::os::raw::c_void,
        newsize: CFIndex,
        hint: CFOptionFlags,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFAllocatorDeallocate(
        allocator: CFAllocatorRef,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFAllocatorGetPreferredSizeForSize(
        allocator: CFAllocatorRef,
        size: CFIndex,
        hint: CFOptionFlags,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFAllocatorGetContext(
        allocator: CFAllocatorRef,
        context: *mut CFAllocatorContext,
    );
}
extern "C" {
    pub fn CFGetTypeID(cf: CFTypeRef) -> CFTypeID;
}
extern "C" {
    pub fn CFCopyTypeIDDescription(type_id: CFTypeID) -> CFStringRef;
}
extern "C" {
    pub fn CFRetain(cf: CFTypeRef) -> CFTypeRef;
}
extern "C" {
    pub fn CFRelease(cf: CFTypeRef);
}
extern "C" {
    pub fn CFAutorelease(arg: CFTypeRef) -> CFTypeRef;
}
extern "C" {
    pub fn CFGetRetainCount(cf: CFTypeRef) -> CFIndex;
}
extern "C" {
    pub fn CFEqual(cf1: CFTypeRef, cf2: CFTypeRef) -> Boolean;
}
extern "C" {
    pub fn CFHash(cf: CFTypeRef) -> CFHashCode;
}
extern "C" {
    pub fn CFCopyDescription(cf: CFTypeRef) -> CFStringRef;
}
extern "C" {
    pub fn CFGetAllocator(cf: CFTypeRef) -> CFAllocatorRef;
}
extern "C" {
    pub fn CFMakeCollectable(cf: CFTypeRef) -> CFTypeRef;
}
pub const ptrauth_key_ptrauth_key_none: ptrauth_key = -1;
pub const ptrauth_key_ptrauth_key_asia: ptrauth_key = 0;
pub const ptrauth_key_ptrauth_key_asib: ptrauth_key = 1;
pub const ptrauth_key_ptrauth_key_asda: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_asdb: ptrauth_key = 3;
pub const ptrauth_key_ptrauth_key_process_independent_code: ptrauth_key = 0;
pub const ptrauth_key_ptrauth_key_process_dependent_code: ptrauth_key = 1;
pub const ptrauth_key_ptrauth_key_process_independent_data: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_process_dependent_data: ptrauth_key = 3;
pub const ptrauth_key_ptrauth_key_function_pointer: ptrauth_key = 0;
pub const ptrauth_key_ptrauth_key_return_address: ptrauth_key = 1;
pub const ptrauth_key_ptrauth_key_frame_pointer: ptrauth_key = 3;
pub const ptrauth_key_ptrauth_key_block_function: ptrauth_key = 0;
pub const ptrauth_key_ptrauth_key_cxx_vtable_pointer: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_method_list_pointer: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_objc_isa_pointer: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_objc_super_pointer: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_block_descriptor_pointer: ptrauth_key = 2;
pub const ptrauth_key_ptrauth_key_objc_sel_pointer: ptrauth_key = 3;
pub const ptrauth_key_ptrauth_key_objc_class_ro_pointer: ptrauth_key = 2;
pub type ptrauth_key = ::std::os::raw::c_int;
pub type ptrauth_extra_data_t = ::std::os::raw::c_ulong;
pub type ptrauth_generic_signature_t = ::std::os::raw::c_ulong;
#[doc = "@typedef CFArrayCallBacks\nStructure containing the callbacks of a CFArray.\n@field version The version number of the structure type being passed\nin as a parameter to the CFArray creation functions. This\nstructure is version 0.\n@field retain The callback used to add a retain for the array on\nvalues as they are put into the array. This callback returns\nthe value to store in the array, which is usually the value\nparameter passed to this callback, but may be a different\nvalue if a different value should be stored in the array.\nThe array's allocator is passed as the first argument.\n@field release The callback used to remove a retain previously added\nfor the array from values as they are removed from the\narray. The array's allocator is passed as the first\nargument.\n@field copyDescription The callback used to create a descriptive\nstring representation of each value in the array. This is\nused by the CFCopyDescription() function.\n@field equal The callback used to compare values in the array for\nequality for some operations."]
pub type CFArrayRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFArrayReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
pub type CFArrayCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFArrayEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFArrayCallBacks {
    pub version: CFIndex,
    pub retain: CFArrayRetainCallBack,
    pub release: CFArrayReleaseCallBack,
    pub copyDescription: CFArrayCopyDescriptionCallBack,
    pub equal: CFArrayEqualCallBack,
}
#[test]
fn bindgen_test_layout_CFArrayCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFArrayCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFArrayCallBacks>(),
        40usize,
        concat!("Size of: ", stringify!(CFArrayCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFArrayCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFArrayCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(equal)
        )
    );
}
extern "C" {
    #[doc = "@constant kCFTypeArrayCallBacks\nPredefined CFArrayCallBacks structure containing a set of callbacks\nappropriate for use when the values in a CFArray are all CFTypes."]
    pub static kCFTypeArrayCallBacks: CFArrayCallBacks;
}
#[doc = "@typedef CFArrayApplierFunction\nType of the callback function used by the apply functions of\nCFArrays.\n@param value The current value from the array.\n@param context The user-defined context parameter given to the apply\nfunction."]
pub type CFArrayApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFArray {
    _unused: [u8; 0],
}
#[doc = "@typedef CFArrayRef\nThis is the type of a reference to immutable CFArrays."]
pub type CFArrayRef = *const __CFArray;
#[doc = "@typedef CFMutableArrayRef\nThis is the type of a reference to mutable CFArrays."]
pub type CFMutableArrayRef = *mut __CFArray;
extern "C" {
    #[doc = "@function CFArrayGetTypeID\nReturns the type identifier of all CFArray instances."]
    pub fn CFArrayGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFArrayCreate\nCreates a new immutable array with the given values.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param values A C array of the pointer-sized values to be in the\narray. The values in the array are ordered in the same order\nin which they appear in this C array. This parameter may be\nNULL if the numValues parameter is 0. This C array is not\nchanged or freed by this function. If this parameter is not\na valid pointer to a C array of at least numValues pointers,\nthe behavior is undefined.\n@param numValues The number of values to copy from the values C\narray into the CFArray. This number will be the count of the\narray.\nIf this parameter is negative, or greater than the number of\nvalues actually in the value's C array, the behavior is\nundefined.\n@param callBacks A pointer to a CFArrayCallBacks structure\ninitialized with the callbacks for the array to use on each\nvalue in the array. The retain callback will be used within\nthis function, for example, to retain all of the new values\nfrom the values C array. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a\nstructure on the stack can be passed in, or can be reused\nfor multiple array creations. If the version field of this\ncallbacks structure is not one of the defined ones for\nCFArray, the behavior is undefined. The retain field may be\nNULL, in which case the CFArray will do nothing to add a\nretain to the contained values for the array. The release\nfield may be NULL, in which case the CFArray will do nothing\nto remove the array's retain (if any) on the values when the\narray is destroyed. If the copyDescription field is NULL,\nthe array will create a simple description for the value. If\nthe equal field is NULL, the array will use pointer equality\nto test for equality of values. This callbacks parameter\nitself may be NULL, which is treated as if a valid structure\nof version 0 with all fields NULL had been passed in.\nOtherwise, if any of the fields are not valid pointers to\nfunctions of the correct type, or this parameter is not a\nvalid pointer to a  CFArrayCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\narray is not one understood by one of the callback functions\nthe behavior when that callback function is used is\nundefined.\n@result A reference to the new immutable CFArray."]
    pub fn CFArrayCreate(
        allocator: CFAllocatorRef,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        callBacks: *const CFArrayCallBacks,
    ) -> CFArrayRef;
}
extern "C" {
    #[doc = "@function CFArrayCreateCopy\nCreates a new immutable array with the values from the given array.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theArray The array which is to be copied. The values from the\narray are copied as pointers into the new array (that is,\nthe values themselves are copied, not that which the values\npoint to, if anything). However, the values are also\nretained by the new array. The count of the new array will\nbe the same as the given array. The new array uses the same\ncallbacks as the array to be copied. If this parameter is\nnot a valid CFArray, the behavior is undefined.\n@result A reference to the new immutable CFArray."]
    pub fn CFArrayCreateCopy(
        allocator: CFAllocatorRef,
        theArray: CFArrayRef,
    ) -> CFArrayRef;
}
extern "C" {
    #[doc = "@function CFArrayCreateMutable\nCreates a new empty mutable array.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFArray. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. An array's actual capacity is only limited by\naddress space and available memory constraints). If this\nparameter is negative, the behavior is undefined.\n@param callBacks A pointer to a CFArrayCallBacks structure\ninitialized with the callbacks for the array to use on each\nvalue in the array. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a\nstructure on the stack can be passed in, or can be reused\nfor multiple array creations. If the version field of this\ncallbacks structure is not one of the defined ones for\nCFArray, the behavior is undefined. The retain field may be\nNULL, in which case the CFArray will do nothing to add a\nretain to the contained values for the array. The release\nfield may be NULL, in which case the CFArray will do nothing\nto remove the array's retain (if any) on the values when the\narray is destroyed. If the copyDescription field is NULL,\nthe array will create a simple description for the value. If\nthe equal field is NULL, the array will use pointer equality\nto test for equality of values. This callbacks parameter\nitself may be NULL, which is treated as if a valid structure\nof version 0 with all fields NULL had been passed in.\nOtherwise, if any of the fields are not valid pointers to\nfunctions of the correct type, or this parameter is not a\nvalid pointer to a  CFArrayCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\narray is not one understood by one of the callback functions\nthe behavior when that callback function is used is\nundefined.\n@result A reference to the new mutable CFArray."]
    pub fn CFArrayCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFArrayCallBacks,
    ) -> CFMutableArrayRef;
}
extern "C" {
    #[doc = "@function CFArrayCreateMutableCopy\nCreates a new mutable array with the values from the given array.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFArray. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. An array's actual capacity is only limited by\naddress space and available memory constraints).\nThis parameter must be greater than or equal\nto the count of the array which is to be copied, or the\nbehavior is undefined. If this parameter is negative, the\nbehavior is undefined.\n@param theArray The array which is to be copied. The values from the\narray are copied as pointers into the new array (that is,\nthe values themselves are copied, not that which the values\npoint to, if anything). However, the values are also\nretained by the new array. The count of the new array will\nbe the same as the given array. The new array uses the same\ncallbacks as the array to be copied. If this parameter is\nnot a valid CFArray, the behavior is undefined.\n@result A reference to the new mutable CFArray."]
    pub fn CFArrayCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theArray: CFArrayRef,
    ) -> CFMutableArrayRef;
}
extern "C" {
    #[doc = "@function CFArrayGetCount\nReturns the number of values currently in the array.\n@param theArray The array to be queried. If this parameter is not a valid\nCFArray, the behavior is undefined.\n@result The number of values in the array."]
    pub fn CFArrayGetCount(theArray: CFArrayRef) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFArrayGetCountOfValue\nCounts the number of times the given value occurs in the array.\n@param theArray The array to be searched. If this parameter is not a\nvalid CFArray, the behavior is undefined.\n@param range The range within the array to search. If the range\nlocation or end point (defined by the location plus length\nminus 1) is outside the index space of the array (0 to\nN-1 inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0).\n@param value The value for which to find matches in the array. The\nequal() callback provided when the array was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the array, are not understood by the equal() callback,\nthe behavior is undefined.\n@result The number of times the given value occurs in the array,\nwithin the specified range."]
    pub fn CFArrayGetCountOfValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFArrayContainsValue\nReports whether or not the value is in the array.\n@param theArray The array to be searched. If this parameter is not a\nvalid CFArray, the behavior is undefined.\n@param range The range within the array to search. If the range\nlocation or end point (defined by the location plus length\nminus 1) is outside the index space of the array (0 to\nN-1 inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0).\n@param value The value for which to find matches in the array. The\nequal() callback provided when the array was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the array, are not understood by the equal() callback,\nthe behavior is undefined.\n@result true, if the value is in the specified range of the array,\notherwise false."]
    pub fn CFArrayContainsValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFArrayGetValueAtIndex\nRetrieves the value at the given index.\n@param theArray The array to be queried. If this parameter is not a\nvalid CFArray, the behavior is undefined.\n@param idx The index of the value to retrieve. If the index is\noutside the index space of the array (0 to N-1 inclusive,\nwhere N is the count of the array), the behavior is\nundefined.\n@result The value with the given index in the array."]
    pub fn CFArrayGetValueAtIndex(
        theArray: CFArrayRef,
        idx: CFIndex,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function CFArrayGetValues\nFills the buffer with values from the array.\n@param theArray The array to be queried. If this parameter is not a\nvalid CFArray, the behavior is undefined.\n@param range The range of values within the array to retrieve. If\nthe range location or end point (defined by the location\nplus length minus 1) is outside the index space of the\narray (0 to N-1 inclusive, where N is the count of the\narray), the behavior is undefined. If the range length is\nnegative, the behavior is undefined. The range may be empty\n(length 0), in which case no values are put into the buffer.\n@param values A C array of pointer-sized values to be filled with\nvalues from the array. The values in the C array are ordered\nin the same order in which they appear in the array. If this\nparameter is not a valid pointer to a C array of at least\nrange.length pointers, the behavior is undefined."]
    pub fn CFArrayGetValues(
        theArray: CFArrayRef,
        range: CFRange,
        values: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFArrayApplyFunction\nCalls a function once for each value in the array.\n@param theArray The array to be operated upon. If this parameter is not\na valid CFArray, the behavior is undefined.\n@param range The range of values within the array to which to apply\nthe function. If the range location or end point (defined by\nthe location plus length minus 1) is outside the index\nspace of the array (0 to N-1 inclusive, where N is the count\nof the array), the behavior is undefined. If the range\nlength is negative, the behavior is undefined. The range may\nbe empty (length 0).\n@param applier The callback function to call once for each value in\nthe given range in the array. If this parameter is not a\npointer to a function of the correct prototype, the behavior\nis undefined. If there are values in the range which the\napplier function does not expect or cannot properly apply\nto, the behavior is undefined.\n@param context A pointer-sized user-defined value, which is passed\nas the second parameter to the applier function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the applier function, the behavior is\nundefined."]
    pub fn CFArrayApplyFunction(
        theArray: CFArrayRef,
        range: CFRange,
        applier: CFArrayApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFArrayGetFirstIndexOfValue\nSearches the array for the value.\n@param theArray The array to be searched. If this parameter is not a\nvalid CFArray, the behavior is undefined.\n@param range The range within the array to search. If the range\nlocation or end point (defined by the location plus length\nminus 1) is outside the index space of the array (0 to\nN-1 inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0).\nThe search progresses from the smallest index defined by\nthe range to the largest.\n@param value The value for which to find a match in the array. The\nequal() callback provided when the array was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the array, are not understood by the equal() callback,\nthe behavior is undefined.\n@result The lowest index of the matching values in the range, or\nkCFNotFound if no value in the range matched."]
    pub fn CFArrayGetFirstIndexOfValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFArrayGetLastIndexOfValue\nSearches the array for the value.\n@param theArray The array to be searched. If this parameter is not a\nvalid CFArray, the behavior is undefined.\n@param range The range within the array to search. If the range\nlocation or end point (defined by the location plus length\nminus 1) is outside the index space of the array (0 to\nN-1 inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0).\nThe search progresses from the largest index defined by the\nrange to the smallest.\n@param value The value for which to find a match in the array. The\nequal() callback provided when the array was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the array, are not understood by the equal() callback,\nthe behavior is undefined.\n@result The highest index of the matching values in the range, or\nkCFNotFound if no value in the range matched."]
    pub fn CFArrayGetLastIndexOfValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFArrayBSearchValues\nSearches the array for the value using a binary search algorithm.\n@param theArray The array to be searched. If this parameter is not a\nvalid CFArray, the behavior is undefined. If the array is\nnot sorted from least to greatest according to the\ncomparator function, the behavior is undefined.\n@param range The range within the array to search. If the range\nlocation or end point (defined by the location plus length\nminus 1) is outside the index space of the array (0 to\nN-1 inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0).\n@param value The value for which to find a match in the array. If\nvalue, or any of the values in the array, are not understood\nby the comparator callback, the behavior is undefined.\n@param comparator The function with the comparator function type\nsignature which is used in the binary search operation to\ncompare values in the array with the given value. If this\nparameter is not a pointer to a function of the correct\nprototype, the behavior is undefined. If there are values\nin the range which the comparator function does not expect\nor cannot properly compare, the behavior is undefined.\n@param context A pointer-sized user-defined value, which is passed\nas the third parameter to the comparator function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the comparator function, the behavior is\nundefined.\n@result The return value is either 1) the index of a value that\nmatched, if the target value matches one or more in the\nrange, 2) greater than or equal to the end point of the\nrange, if the value is greater than all the values in the\nrange, or 3) the index of the value greater than the target\nvalue, if the value lies between two of (or less than all\nof) the values in the range."]
    pub fn CFArrayBSearchValues(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
        comparator: CFComparatorFunction,
        context: *mut ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFArrayAppendValue\nAdds the value to the array giving it a new largest index.\n@param theArray The array to which the value is to be added. If this\nparameter is not a valid mutable CFArray, the behavior is\nundefined.\n@param value The value to add to the array. The value is retained by\nthe array using the retain callback provided when the array\nwas created. If the value is not of the sort expected by the\nretain callback, the behavior is undefined. The value is\nassigned to the index one larger than the previous largest\nindex, and the count of the array is increased by one."]
    pub fn CFArrayAppendValue(
        theArray: CFMutableArrayRef,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFArrayInsertValueAtIndex\nAdds the value to the array, giving it the given index.\n@param theArray The array to which the value is to be added. If this\nparameter is not a valid mutable CFArray, the behavior is\nundefined.\n@param idx The index to which to add the new value. If the index is\noutside the index space of the array (0 to N inclusive,\nwhere N is the count of the array before the operation), the\nbehavior is undefined. If the index is the same as N, this\nfunction has the same effect as CFArrayAppendValue().\n@param value The value to add to the array. The value is retained by\nthe array using the retain callback provided when the array\nwas created. If the value is not of the sort expected by the\nretain callback, the behavior is undefined. The value is\nassigned to the given index, and all values with equal and\nlarger indices have their indexes increased by one."]
    pub fn CFArrayInsertValueAtIndex(
        theArray: CFMutableArrayRef,
        idx: CFIndex,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFArraySetValueAtIndex\nChanges the value with the given index in the array.\n@param theArray The array in which the value is to be changed. If this\nparameter is not a valid mutable CFArray, the behavior is\nundefined.\n@param idx The index to which to set the new value. If the index is\noutside the index space of the array (0 to N inclusive,\nwhere N is the count of the array before the operation), the\nbehavior is undefined. If the index is the same as N, this\nfunction has the same effect as CFArrayAppendValue().\n@param value The value to set in the array. The value is retained by\nthe array using the retain callback provided when the array\nwas created, and the previous value with that index is\nreleased. If the value is not of the sort expected by the\nretain callback, the behavior is undefined. The indices of\nother values is not affected."]
    pub fn CFArraySetValueAtIndex(
        theArray: CFMutableArrayRef,
        idx: CFIndex,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFArrayRemoveValueAtIndex\nRemoves the value with the given index from the array.\n@param theArray The array from which the value is to be removed. If\nthis parameter is not a valid mutable CFArray, the behavior\nis undefined.\n@param idx The index from which to remove the value. If the index is\noutside the index space of the array (0 to N-1 inclusive,\nwhere N is the count of the array before the operation), the\nbehavior is undefined."]
    pub fn CFArrayRemoveValueAtIndex(theArray: CFMutableArrayRef, idx: CFIndex);
}
extern "C" {
    #[doc = "@function CFArrayRemoveAllValues\nRemoves all the values from the array, making it empty.\n@param theArray The array from which all of the values are to be\nremoved. If this parameter is not a valid mutable CFArray,\nthe behavior is undefined."]
    pub fn CFArrayRemoveAllValues(theArray: CFMutableArrayRef);
}
extern "C" {
    #[doc = "@function CFArrayReplaceValues\nReplaces a range of values in the array.\n@param theArray The array from which all of the values are to be\nremoved. If this parameter is not a valid mutable CFArray,\nthe behavior is undefined.\n@param range The range of values within the array to replace. If the\nrange location or end point (defined by the location plus\nlength minus 1) is outside the index space of the array (0\nto N inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0),\nin which case the new values are merely inserted at the\nrange location.\n@param newValues A C array of the pointer-sized values to be placed\ninto the array. The new values in the array are ordered in\nthe same order in which they appear in this C array. This\nparameter may be NULL if the newCount parameter is 0. This\nC array is not changed or freed by this function. If this\nparameter is not a valid pointer to a C array of at least\nnewCount pointers, the behavior is undefined.\n@param newCount The number of values to copy from the values C\narray into the CFArray. If this parameter is different than\nthe range length, the excess newCount values will be\ninserted after the range, or the excess range values will be\ndeleted. This parameter may be 0, in which case no new\nvalues are replaced into the array and the values in the\nrange are simply removed. If this parameter is negative, or\ngreater than the number of values actually in the newValues\nC array, the behavior is undefined."]
    pub fn CFArrayReplaceValues(
        theArray: CFMutableArrayRef,
        range: CFRange,
        newValues: *mut *const ::std::os::raw::c_void,
        newCount: CFIndex,
    );
}
extern "C" {
    #[doc = "@function CFArrayExchangeValuesAtIndices\nExchanges the values at two indices of the array.\n@param theArray The array of which the values are to be swapped. If\nthis parameter is not a valid mutable CFArray, the behavior\nis undefined.\n@param idx1 The first index whose values should be swapped. If the\nindex is outside the index space of the array (0 to N-1\ninclusive, where N is the count of the array before the\noperation), the behavior is undefined.\n@param idx2 The second index whose values should be swapped. If the\nindex is outside the index space of the array (0 to N-1\ninclusive, where N is the count of the array before the\noperation), the behavior is undefined."]
    pub fn CFArrayExchangeValuesAtIndices(
        theArray: CFMutableArrayRef,
        idx1: CFIndex,
        idx2: CFIndex,
    );
}
extern "C" {
    #[doc = "@function CFArraySortValues\nSorts the values in the array using the given comparison function.\n@param theArray The array whose values are to be sorted. If this\nparameter is not a valid mutable CFArray, the behavior is\nundefined.\n@param range The range of values within the array to sort. If the\nrange location or end point (defined by the location plus\nlength minus 1) is outside the index space of the array (0\nto N-1 inclusive, where N is the count of the array), the\nbehavior is undefined. If the range length is negative, the\nbehavior is undefined. The range may be empty (length 0).\n@param comparator The function with the comparator function type\nsignature which is used in the sort operation to compare\nvalues in the array with the given value. If this parameter\nis not a pointer to a function of the correct prototype, the\nthe behavior is undefined. If there are values in the array\nwhich the comparator function does not expect or cannot\nproperly compare, the behavior is undefined. The values in\nthe range are sorted from least to greatest according to\nthis function.\n@param context A pointer-sized user-defined value, which is passed\nas the third parameter to the comparator function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the comparator function, the behavior is\nundefined."]
    pub fn CFArraySortValues(
        theArray: CFMutableArrayRef,
        range: CFRange,
        comparator: CFComparatorFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFArrayAppendArray\nAdds the values from an array to another array.\n@param theArray The array to which values from the otherArray are to\nbe added. If this parameter is not a valid mutable CFArray,\nthe behavior is undefined.\n@param otherArray The array providing the values to be added to the\narray. If this parameter is not a valid CFArray, the\nbehavior is undefined.\n@param otherRange The range within the otherArray from which to add\nthe values to the array. If the range location or end point\n(defined by the location plus length minus 1) is outside\nthe index space of the otherArray (0 to N-1 inclusive, where\nN is the count of the otherArray), the behavior is\nundefined. The new values are retained by the array using\nthe retain callback provided when the array was created. If\nthe values are not of the sort expected by the retain\ncallback, the behavior is undefined. The values are assigned\nto the indices one larger than the previous largest index\nin the array, and beyond, and the count of the array is\nincreased by range.length. The values are assigned new\nindices in the array from smallest to largest index in the\norder in which they appear in the otherArray."]
    pub fn CFArrayAppendArray(
        theArray: CFMutableArrayRef,
        otherArray: CFArrayRef,
        otherRange: CFRange,
    );
}
pub type CFBagRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFBagReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
pub type CFBagCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFBagEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type CFBagHashCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFHashCode,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFBagCallBacks {
    pub version: CFIndex,
    pub retain: CFBagRetainCallBack,
    pub release: CFBagReleaseCallBack,
    pub copyDescription: CFBagCopyDescriptionCallBack,
    pub equal: CFBagEqualCallBack,
    pub hash: CFBagHashCallBack,
}
#[test]
fn bindgen_test_layout_CFBagCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFBagCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFBagCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFBagCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFBagCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFBagCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    pub static kCFTypeBagCallBacks: CFBagCallBacks;
}
extern "C" {
    pub static kCFCopyStringBagCallBacks: CFBagCallBacks;
}
pub type CFBagApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBag {
    _unused: [u8; 0],
}
pub type CFBagRef = *const __CFBag;
pub type CFMutableBagRef = *mut __CFBag;
extern "C" {
    pub fn CFBagGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBagCreate(
        allocator: CFAllocatorRef,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        callBacks: *const CFBagCallBacks,
    ) -> CFBagRef;
}
extern "C" {
    pub fn CFBagCreateCopy(allocator: CFAllocatorRef, theBag: CFBagRef) -> CFBagRef;
}
extern "C" {
    pub fn CFBagCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFBagCallBacks,
    ) -> CFMutableBagRef;
}
extern "C" {
    pub fn CFBagCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theBag: CFBagRef,
    ) -> CFMutableBagRef;
}
extern "C" {
    pub fn CFBagGetCount(theBag: CFBagRef) -> CFIndex;
}
extern "C" {
    pub fn CFBagGetCountOfValue(
        theBag: CFBagRef,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFBagContainsValue(
        theBag: CFBagRef,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBagGetValue(
        theBag: CFBagRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFBagGetValueIfPresent(
        theBag: CFBagRef,
        candidate: *const ::std::os::raw::c_void,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBagGetValues(theBag: CFBagRef, values: *mut *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagApplyFunction(
        theBag: CFBagRef,
        applier: CFBagApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBagAddValue(theBag: CFMutableBagRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagReplaceValue(
        theBag: CFMutableBagRef,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBagSetValue(theBag: CFMutableBagRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagRemoveValue(
        theBag: CFMutableBagRef,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBagRemoveAllValues(theBag: CFMutableBagRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFBinaryHeapCompareContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFBinaryHeapCompareContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFBinaryHeapCompareContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFBinaryHeapCompareContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFBinaryHeapCompareContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFBinaryHeapCompareContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFBinaryHeapCompareContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
#[doc = "@typedef CFBinaryHeapCallBacks\nStructure containing the callbacks for values of a CFBinaryHeap.\n@field version The version number of the structure type being passed\nin as a parameter to the CFBinaryHeap creation functions.\nThis structure is version 0.\n@field retain The callback used to add a retain for the binary heap\non values as they are put into the binary heap.\nThis callback returns the value to use as the value in the\nbinary heap, which is usually the value parameter passed to\nthis callback, but may be a different value if a different\nvalue should be added to the binary heap. The binary heap's\nallocator is passed as the first argument.\n@field release The callback used to remove a retain previously added\nfor the binary heap from values as they are removed from\nthe binary heap. The binary heap's allocator is passed as the\nfirst argument.\n@field copyDescription The callback used to create a descriptive\nstring representation of each value in the binary heap. This\nis used by the CFCopyDescription() function.\n@field compare The callback used to compare values in the binary heap for\nequality in some operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFBinaryHeapCallBacks {
    pub version: CFIndex,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: CFAllocatorRef,
            ptr: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: CFAllocatorRef,
            ptr: *const ::std::os::raw::c_void,
        ),
    >,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(
            ptr1: *const ::std::os::raw::c_void,
            ptr2: *const ::std::os::raw::c_void,
            context: *mut ::std::os::raw::c_void,
        ) -> CFComparisonResult,
    >,
}
#[test]
fn bindgen_test_layout_CFBinaryHeapCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFBinaryHeapCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFBinaryHeapCallBacks>(),
        40usize,
        concat!("Size of: ", stringify!(CFBinaryHeapCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFBinaryHeapCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFBinaryHeapCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compare) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(compare)
        )
    );
}
extern "C" {
    #[doc = "@constant kCFStringBinaryHeapCallBacks\nPredefined CFBinaryHeapCallBacks structure containing a set\nof callbacks appropriate for use when the values in a CFBinaryHeap\nare all CFString types."]
    pub static kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
}
#[doc = "@typedef CFBinaryHeapApplierFunction\nType of the callback function used by the apply functions of\nCFBinaryHeap.\n@param val The current value from the binary heap.\n@param context The user-defined context parameter given to the apply\nfunction."]
pub type CFBinaryHeapApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        val: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBinaryHeap {
    _unused: [u8; 0],
}
#[doc = "@typedef CFBinaryHeapRef\nThis is the type of a reference to CFBinaryHeaps."]
pub type CFBinaryHeapRef = *mut __CFBinaryHeap;
extern "C" {
    #[doc = "@function CFBinaryHeapGetTypeID\nReturns the type identifier of all CFBinaryHeap instances."]
    pub fn CFBinaryHeapGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFBinaryHeapCreate\nCreates a new mutable binary heap with the given values.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the binary heap and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFBinaryHeap. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. A heap's actual capacity is only limited by\naddress space and available memory constraints). If this\nparameter is negative, the behavior is undefined.\n@param callBacks A pointer to a CFBinaryHeapCallBacks structure\ninitialized with the callbacks for the binary heap to use on\neach value in the binary heap. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a structure\non the stack can be passed in, or can be reused for multiple\nbinary heap creations. If the version field of this callbacks\nstructure is not one of the defined ones for CFBinaryHeap, the\nbehavior is undefined. The retain field may be NULL, in which\ncase the CFBinaryHeap will do nothing to add a retain to values\nas they are put into the binary heap. The release field may be\nNULL, in which case the CFBinaryHeap will do nothing to remove\nthe binary heap's retain (if any) on the values when the\nheap is destroyed or a key-value pair is removed. If the\ncopyDescription field is NULL, the binary heap will create a\nsimple description for a value. If the equal field is NULL, the\nbinary heap will use pointer equality to test for equality of\nvalues. This callbacks parameter itself may be NULL, which is\ntreated as if a valid structure of version 0 with all fields\nNULL had been passed in. Otherwise,\nif any of the fields are not valid pointers to functions\nof the correct type, or this parameter is not a valid\npointer to a CFBinaryHeapCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\nbinary heap is not one understood by one of the callback functions\nthe behavior when that callback function is used is undefined.\n@param compareContext A pointer to a CFBinaryHeapCompareContext structure.\n@result A reference to the new CFBinaryHeap."]
    pub fn CFBinaryHeapCreate(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFBinaryHeapCallBacks,
        compareContext: *const CFBinaryHeapCompareContext,
    ) -> CFBinaryHeapRef;
}
extern "C" {
    #[doc = "@function CFBinaryHeapCreateCopy\nCreates a new mutable binary heap with the values from the given binary heap.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the binary heap and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFBinaryHeap. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. A heap's actual capacity is only limited by\naddress space and available memory constraints).\nThis parameter must be greater than or equal\nto the count of the heap which is to be copied, or the\nbehavior is undefined. If this parameter is negative, the\nbehavior is undefined.\n@param heap The binary heap which is to be copied. The values from the\nbinary heap are copied as pointers into the new binary heap (that is,\nthe values themselves are copied, not that which the values\npoint to, if anything). However, the values are also\nretained by the new binary heap. The count of the new binary will\nbe the same as the given binary heap. The new binary heap uses the same\ncallbacks as the binary heap to be copied. If this parameter is\nnot a valid CFBinaryHeap, the behavior is undefined.\n@result A reference to the new mutable binary heap."]
    pub fn CFBinaryHeapCreateCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        heap: CFBinaryHeapRef,
    ) -> CFBinaryHeapRef;
}
extern "C" {
    #[doc = "@function CFBinaryHeapGetCount\nReturns the number of values currently in the binary heap.\n@param heap The binary heap to be queried. If this parameter is not a valid\nCFBinaryHeap, the behavior is undefined.\n@result The number of values in the binary heap."]
    pub fn CFBinaryHeapGetCount(heap: CFBinaryHeapRef) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFBinaryHeapGetCountOfValue\nCounts the number of times the given value occurs in the binary heap.\n@param heap The binary heap to be searched. If this parameter is not a\nvalid CFBinaryHeap, the behavior is undefined.\n@param value The value for which to find matches in the binary heap. The\ncompare() callback provided when the binary heap was created is\nused to compare. If the compare() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the binary heap, are not understood by the compare() callback,\nthe behavior is undefined.\n@result The number of times the given value occurs in the binary heap."]
    pub fn CFBinaryHeapGetCountOfValue(
        heap: CFBinaryHeapRef,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFBinaryHeapContainsValue\nReports whether or not the value is in the binary heap.\n@param heap The binary heap to be searched. If this parameter is not a\nvalid CFBinaryHeap, the behavior is undefined.\n@param value The value for which to find matches in the binary heap. The\ncompare() callback provided when the binary heap was created is\nused to compare. If the compare() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the binary heap, are not understood by the compare() callback,\nthe behavior is undefined.\n@result true, if the value is in the specified binary heap, otherwise false."]
    pub fn CFBinaryHeapContainsValue(
        heap: CFBinaryHeapRef,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFBinaryHeapGetMinimum\nReturns the minimum value is in the binary heap.  If the heap contains several equal\nminimum values, any one may be returned.\n@param heap The binary heap to be searched. If this parameter is not a\nvalid CFBinaryHeap, the behavior is undefined.\n@result A reference to the minimum value in the binary heap, or NULL if the\nbinary heap contains no values."]
    pub fn CFBinaryHeapGetMinimum(heap: CFBinaryHeapRef)
        -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function CFBinaryHeapGetMinimumIfPresent\nReturns the minimum value is in the binary heap, if present.  If the heap contains several equal\nminimum values, any one may be returned.\n@param heap The binary heap to be searched. If this parameter is not a\nvalid CFBinaryHeap, the behavior is undefined.\n@param value A C pointer to pointer-sized storage to be filled with the minimum value in\nthe binary heap.  If this value is not a valid C pointer to a pointer-sized block\nof storage, the result is undefined.  If the result of the function is false, the value\nstored at this address is undefined.\n@result true, if a minimum value was found in the specified binary heap, otherwise false."]
    pub fn CFBinaryHeapGetMinimumIfPresent(
        heap: CFBinaryHeapRef,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFBinaryHeapGetValues\nFills the buffer with values from the binary heap.\n@param heap The binary heap to be queried. If this parameter is not a\nvalid CFBinaryHeap, the behavior is undefined.\n@param values A C array of pointer-sized values to be filled with\nvalues from the binary heap. The values in the C array are ordered\nfrom least to greatest. If this parameter is not a valid pointer to a\nC array of at least CFBinaryHeapGetCount() pointers, the behavior is undefined."]
    pub fn CFBinaryHeapGetValues(
        heap: CFBinaryHeapRef,
        values: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFBinaryHeapApplyFunction\nCalls a function once for each value in the binary heap.\n@param heap The binary heap to be operated upon. If this parameter is not a\nvalid CFBinaryHeap, the behavior is undefined.\n@param applier The callback function to call once for each value in\nthe given binary heap. If this parameter is not a\npointer to a function of the correct prototype, the behavior\nis undefined. If there are values in the binary heap which the\napplier function does not expect or cannot properly apply\nto, the behavior is undefined.\n@param context A pointer-sized user-defined value, which is passed\nas the second parameter to the applier function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the applier function, the behavior is\nundefined."]
    pub fn CFBinaryHeapApplyFunction(
        heap: CFBinaryHeapRef,
        applier: CFBinaryHeapApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFBinaryHeapAddValue\nAdds the value to the binary heap.\n@param heap The binary heap to which the value is to be added. If this parameter is not a\nvalid mutable CFBinaryHeap, the behavior is undefined.\n@param value The value to add to the binary heap. The value is retained by\nthe binary heap using the retain callback provided when the binary heap\nwas created. If the value is not of the sort expected by the\nretain callback, the behavior is undefined."]
    pub fn CFBinaryHeapAddValue(
        heap: CFBinaryHeapRef,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFBinaryHeapRemoveMinimumValue\nRemoves the minimum value from the binary heap.\n@param heap The binary heap from which the minimum value is to be removed. If this\nparameter is not a valid mutable CFBinaryHeap, the behavior is undefined."]
    pub fn CFBinaryHeapRemoveMinimumValue(heap: CFBinaryHeapRef);
}
extern "C" {
    #[doc = "@function CFBinaryHeapRemoveAllValues\nRemoves all the values from the binary heap, making it empty.\n@param heap The binary heap from which all of the values are to be\nremoved. If this parameter is not a valid mutable CFBinaryHeap,\nthe behavior is undefined."]
    pub fn CFBinaryHeapRemoveAllValues(heap: CFBinaryHeapRef);
}
pub type CFBit = UInt32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBitVector {
    _unused: [u8; 0],
}
pub type CFBitVectorRef = *const __CFBitVector;
pub type CFMutableBitVectorRef = *mut __CFBitVector;
extern "C" {
    pub fn CFBitVectorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBitVectorCreate(
        allocator: CFAllocatorRef,
        bytes: *const UInt8,
        numBits: CFIndex,
    ) -> CFBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorCreateCopy(
        allocator: CFAllocatorRef,
        bv: CFBitVectorRef,
    ) -> CFBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
    ) -> CFMutableBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        bv: CFBitVectorRef,
    ) -> CFMutableBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorGetCount(bv: CFBitVectorRef) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorGetCountOfBit(
        bv: CFBitVectorRef,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorContainsBit(
        bv: CFBitVectorRef,
        range: CFRange,
        value: CFBit,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBitVectorGetBitAtIndex(bv: CFBitVectorRef, idx: CFIndex) -> CFBit;
}
extern "C" {
    pub fn CFBitVectorGetBits(bv: CFBitVectorRef, range: CFRange, bytes: *mut UInt8);
}
extern "C" {
    pub fn CFBitVectorGetFirstIndexOfBit(
        bv: CFBitVectorRef,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorGetLastIndexOfBit(
        bv: CFBitVectorRef,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorSetCount(bv: CFMutableBitVectorRef, count: CFIndex);
}
extern "C" {
    pub fn CFBitVectorFlipBitAtIndex(bv: CFMutableBitVectorRef, idx: CFIndex);
}
extern "C" {
    pub fn CFBitVectorFlipBits(bv: CFMutableBitVectorRef, range: CFRange);
}
extern "C" {
    pub fn CFBitVectorSetBitAtIndex(
        bv: CFMutableBitVectorRef,
        idx: CFIndex,
        value: CFBit,
    );
}
extern "C" {
    pub fn CFBitVectorSetBits(bv: CFMutableBitVectorRef, range: CFRange, value: CFBit);
}
extern "C" {
    pub fn CFBitVectorSetAllBits(bv: CFMutableBitVectorRef, value: CFBit);
}
pub const OSUnknownByteOrder: _bindgen_ty_8 = 0;
pub const OSLittleEndian: _bindgen_ty_8 = 1;
pub const OSBigEndian: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const __CFByteOrder_CFByteOrderUnknown: __CFByteOrder = 0;
pub const __CFByteOrder_CFByteOrderLittleEndian: __CFByteOrder = 1;
pub const __CFByteOrder_CFByteOrderBigEndian: __CFByteOrder = 2;
pub type __CFByteOrder = ::std::os::raw::c_uint;
pub type CFByteOrder = CFIndex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSwappedFloat32 {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_CFSwappedFloat32() {
    const UNINIT: ::std::mem::MaybeUninit<CFSwappedFloat32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFSwappedFloat32>(),
        4usize,
        concat!("Size of: ", stringify!(CFSwappedFloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSwappedFloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(CFSwappedFloat32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSwappedFloat32),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSwappedFloat64 {
    pub v: u64,
}
#[test]
fn bindgen_test_layout_CFSwappedFloat64() {
    const UNINIT: ::std::mem::MaybeUninit<CFSwappedFloat64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFSwappedFloat64>(),
        8usize,
        concat!("Size of: ", stringify!(CFSwappedFloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSwappedFloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSwappedFloat64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSwappedFloat64),
            "::",
            stringify!(v)
        )
    );
}
#[doc = "@typedef CFDictionaryKeyCallBacks\nStructure containing the callbacks for keys of a CFDictionary.\n@field version The version number of the structure type being passed\nin as a parameter to the CFDictionary creation functions.\nThis structure is version 0.\n@field retain The callback used to add a retain for the dictionary\non keys as they are used to put values into the dictionary.\nThis callback returns the value to use as the key in the\ndictionary, which is usually the value parameter passed to\nthis callback, but may be a different value if a different\nvalue should be used as the key. The dictionary's allocator\nis passed as the first argument.\n@field release The callback used to remove a retain previously added\nfor the dictionary from keys as their values are removed from\nthe dictionary. The dictionary's allocator is passed as the\nfirst argument.\n@field copyDescription The callback used to create a descriptive\nstring representation of each key in the dictionary. This\nis used by the CFCopyDescription() function.\n@field equal The callback used to compare keys in the dictionary for\nequality.\n@field hash The callback used to compute a hash code for keys as they\nare used to access, add, or remove values in the dictionary."]
pub type CFDictionaryRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFDictionaryReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
pub type CFDictionaryCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFDictionaryEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type CFDictionaryHashCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFHashCode,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFDictionaryKeyCallBacks {
    pub version: CFIndex,
    pub retain: CFDictionaryRetainCallBack,
    pub release: CFDictionaryReleaseCallBack,
    pub copyDescription: CFDictionaryCopyDescriptionCallBack,
    pub equal: CFDictionaryEqualCallBack,
    pub hash: CFDictionaryHashCallBack,
}
#[test]
fn bindgen_test_layout_CFDictionaryKeyCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFDictionaryKeyCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFDictionaryKeyCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFDictionaryKeyCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFDictionaryKeyCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFDictionaryKeyCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    #[doc = "@constant kCFTypeDictionaryKeyCallBacks\nPredefined CFDictionaryKeyCallBacks structure containing a\nset of callbacks appropriate for use when the keys of a\nCFDictionary are all CFTypes."]
    pub static kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
}
extern "C" {
    #[doc = "@constant kCFCopyStringDictionaryKeyCallBacks\nPredefined CFDictionaryKeyCallBacks structure containing a\nset of callbacks appropriate for use when the keys of a\nCFDictionary are all CFStrings, which may be mutable and\nneed to be copied in order to serve as constant keys for\nthe values in the dictionary."]
    pub static kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
}
#[doc = "@typedef CFDictionaryValueCallBacks\nStructure containing the callbacks for values of a CFDictionary.\n@field version The version number of the structure type being passed\nin as a parameter to the CFDictionary creation functions.\nThis structure is version 0.\n@field retain The callback used to add a retain for the dictionary\non values as they are put into the dictionary.\nThis callback returns the value to use as the value in the\ndictionary, which is usually the value parameter passed to\nthis callback, but may be a different value if a different\nvalue should be added to the dictionary. The dictionary's\nallocator is passed as the first argument.\n@field release The callback used to remove a retain previously added\nfor the dictionary from values as they are removed from\nthe dictionary. The dictionary's allocator is passed as the\nfirst argument.\n@field copyDescription The callback used to create a descriptive\nstring representation of each value in the dictionary. This\nis used by the CFCopyDescription() function.\n@field equal The callback used to compare values in the dictionary for\nequality in some operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFDictionaryValueCallBacks {
    pub version: CFIndex,
    pub retain: CFDictionaryRetainCallBack,
    pub release: CFDictionaryReleaseCallBack,
    pub copyDescription: CFDictionaryCopyDescriptionCallBack,
    pub equal: CFDictionaryEqualCallBack,
}
#[test]
fn bindgen_test_layout_CFDictionaryValueCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFDictionaryValueCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFDictionaryValueCallBacks>(),
        40usize,
        concat!("Size of: ", stringify!(CFDictionaryValueCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFDictionaryValueCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFDictionaryValueCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(equal)
        )
    );
}
extern "C" {
    #[doc = "@constant kCFTypeDictionaryValueCallBacks\nPredefined CFDictionaryValueCallBacks structure containing a set\nof callbacks appropriate for use when the values in a CFDictionary\nare all CFTypes."]
    pub static kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
}
#[doc = "@typedef CFDictionaryApplierFunction\nType of the callback function used by the apply functions of\nCFDictionarys.\n@param key The current key for the value.\n@param value The current value from the dictionary.\n@param context The user-defined context parameter given to the apply\nfunction."]
pub type CFDictionaryApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFDictionary {
    _unused: [u8; 0],
}
#[doc = "@typedef CFDictionaryRef\nThis is the type of a reference to immutable CFDictionarys."]
pub type CFDictionaryRef = *const __CFDictionary;
#[doc = "@typedef CFMutableDictionaryRef\nThis is the type of a reference to mutable CFDictionarys."]
pub type CFMutableDictionaryRef = *mut __CFDictionary;
extern "C" {
    #[doc = "@function CFDictionaryGetTypeID\nReturns the type identifier of all CFDictionary instances."]
    pub fn CFDictionaryGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFDictionaryCreate\nCreates a new immutable dictionary with the given values.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the dictionary and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param keys A C array of the pointer-sized keys to be used for\nthe parallel C array of values to be put into the dictionary.\nThis parameter may be NULL if the numValues parameter is 0.\nThis C array is not changed or freed by this function. If\nthis parameter is not a valid pointer to a C array of at\nleast numValues pointers, the behavior is undefined.\n@param values A C array of the pointer-sized values to be in the\ndictionary. This parameter may be NULL if the numValues\nparameter is 0. This C array is not changed or freed by\nthis function. If this parameter is not a valid pointer to\na C array of at least numValues pointers, the behavior is\nundefined.\n@param numValues The number of values to copy from the keys and\nvalues C arrays into the CFDictionary. This number will be\nthe count of the dictionary. If this parameter is\nnegative, or greater than the number of values actually\nin the keys or values C arrays, the behavior is undefined.\n@param keyCallBacks A pointer to a CFDictionaryKeyCallBacks structure\ninitialized with the callbacks for the dictionary to use on\neach key in the dictionary. The retain callback will be used\nwithin this function, for example, to retain all of the new\nkeys from the keys C array. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a structure\non the stack can be passed in, or can be reused for multiple\ndictionary creations. If the version field of this\ncallbacks structure is not one of the defined ones for\nCFDictionary, the behavior is undefined. The retain field may\nbe NULL, in which case the CFDictionary will do nothing to add\na retain to the keys of the contained values. The release field\nmay be NULL, in which case the CFDictionary will do nothing\nto remove the dictionary's retain (if any) on the keys when the\ndictionary is destroyed or a key-value pair is removed. If the\ncopyDescription field is NULL, the dictionary will create a\nsimple description for a key. If the equal field is NULL, the\ndictionary will use pointer equality to test for equality of\nkeys. If the hash field is NULL, a key will be converted from\na pointer to an integer to compute the hash code. This callbacks\nparameter itself may be NULL, which is treated as if a valid\nstructure of version 0 with all fields NULL had been passed in.\nOtherwise, if any of the fields are not valid pointers to\nfunctions of the correct type, or this parameter is not a\nvalid pointer to a CFDictionaryKeyCallBacks callbacks structure,\nthe behavior is undefined. If any of the keys put into the\ndictionary is not one understood by one of the callback functions\nthe behavior when that callback function is used is undefined.\n@param valueCallBacks A pointer to a CFDictionaryValueCallBacks structure\ninitialized with the callbacks for the dictionary to use on\neach value in the dictionary. The retain callback will be used\nwithin this function, for example, to retain all of the new\nvalues from the values C array. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a structure\non the stack can be passed in, or can be reused for multiple\ndictionary creations. If the version field of this callbacks\nstructure is not one of the defined ones for CFDictionary, the\nbehavior is undefined. The retain field may be NULL, in which\ncase the CFDictionary will do nothing to add a retain to values\nas they are put into the dictionary. The release field may be\nNULL, in which case the CFDictionary will do nothing to remove\nthe dictionary's retain (if any) on the values when the\ndictionary is destroyed or a key-value pair is removed. If the\ncopyDescription field is NULL, the dictionary will create a\nsimple description for a value. If the equal field is NULL, the\ndictionary will use pointer equality to test for equality of\nvalues. This callbacks parameter itself may be NULL, which is\ntreated as if a valid structure of version 0 with all fields\nNULL had been passed in. Otherwise,\nif any of the fields are not valid pointers to functions\nof the correct type, or this parameter is not a valid\npointer to a CFDictionaryValueCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\ndictionary is not one understood by one of the callback functions\nthe behavior when that callback function is used is undefined.\n@result A reference to the new immutable CFDictionary."]
    pub fn CFDictionaryCreate(
        allocator: CFAllocatorRef,
        keys: *mut *const ::std::os::raw::c_void,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        keyCallBacks: *const CFDictionaryKeyCallBacks,
        valueCallBacks: *const CFDictionaryValueCallBacks,
    ) -> CFDictionaryRef;
}
extern "C" {
    #[doc = "@function CFDictionaryCreateCopy\nCreates a new immutable dictionary with the key-value pairs from\nthe given dictionary.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the dictionary and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theDict The dictionary which is to be copied. The keys and values\nfrom the dictionary are copied as pointers into the new\ndictionary (that is, the values themselves are copied, not\nthat which the values point to, if anything). However, the\nkeys and values are also retained by the new dictionary using\nthe retain function of the original dictionary.\nThe count of the new dictionary will be the same as the\ngiven dictionary. The new dictionary uses the same callbacks\nas the dictionary to be copied. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@result A reference to the new immutable CFDictionary."]
    pub fn CFDictionaryCreateCopy(
        allocator: CFAllocatorRef,
        theDict: CFDictionaryRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    #[doc = "@function CFDictionaryCreateMutable\nCreates a new mutable dictionary.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the dictionary and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFDictionary. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. A dictionary's actual capacity is only limited by\naddress space and available memory constraints). If this\nparameter is negative, the behavior is undefined.\n@param keyCallBacks A pointer to a CFDictionaryKeyCallBacks structure\ninitialized with the callbacks for the dictionary to use on\neach key in the dictionary. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a structure\non the stack can be passed in, or can be reused for multiple\ndictionary creations. If the version field of this\ncallbacks structure is not one of the defined ones for\nCFDictionary, the behavior is undefined. The retain field may\nbe NULL, in which case the CFDictionary will do nothing to add\na retain to the keys of the contained values. The release field\nmay be NULL, in which case the CFDictionary will do nothing\nto remove the dictionary's retain (if any) on the keys when the\ndictionary is destroyed or a key-value pair is removed. If the\ncopyDescription field is NULL, the dictionary will create a\nsimple description for a key. If the equal field is NULL, the\ndictionary will use pointer equality to test for equality of\nkeys. If the hash field is NULL, a key will be converted from\na pointer to an integer to compute the hash code. This callbacks\nparameter itself may be NULL, which is treated as if a valid\nstructure of version 0 with all fields NULL had been passed in.\nOtherwise, if any of the fields are not valid pointers to\nfunctions of the correct type, or this parameter is not a\nvalid pointer to a CFDictionaryKeyCallBacks callbacks structure,\nthe behavior is undefined. If any of the keys put into the\ndictionary is not one understood by one of the callback functions\nthe behavior when that callback function is used is undefined.\n@param valueCallBacks A pointer to a CFDictionaryValueCallBacks structure\ninitialized with the callbacks for the dictionary to use on\neach value in the dictionary. The retain callback will be used\nwithin this function, for example, to retain all of the new\nvalues from the values C array. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a structure\non the stack can be passed in, or can be reused for multiple\ndictionary creations. If the version field of this callbacks\nstructure is not one of the defined ones for CFDictionary, the\nbehavior is undefined. The retain field may be NULL, in which\ncase the CFDictionary will do nothing to add a retain to values\nas they are put into the dictionary. The release field may be\nNULL, in which case the CFDictionary will do nothing to remove\nthe dictionary's retain (if any) on the values when the\ndictionary is destroyed or a key-value pair is removed. If the\ncopyDescription field is NULL, the dictionary will create a\nsimple description for a value. If the equal field is NULL, the\ndictionary will use pointer equality to test for equality of\nvalues. This callbacks parameter itself may be NULL, which is\ntreated as if a valid structure of version 0 with all fields\nNULL had been passed in. Otherwise,\nif any of the fields are not valid pointers to functions\nof the correct type, or this parameter is not a valid\npointer to a CFDictionaryValueCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\ndictionary is not one understood by one of the callback functions\nthe behavior when that callback function is used is undefined.\n@result A reference to the new mutable CFDictionary."]
    pub fn CFDictionaryCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        keyCallBacks: *const CFDictionaryKeyCallBacks,
        valueCallBacks: *const CFDictionaryValueCallBacks,
    ) -> CFMutableDictionaryRef;
}
extern "C" {
    #[doc = "@function CFDictionaryCreateMutableCopy\nCreates a new mutable dictionary with the key-value pairs from\nthe given dictionary.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the dictionary and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFDictionary. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. A dictionary's actual capacity is only limited by\naddress space and available memory constraints).\nThis parameter must be greater than or equal\nto the count of the dictionary which is to be copied, or the\nbehavior is undefined. If this parameter is negative, the\nbehavior is undefined.\n@param theDict The dictionary which is to be copied. The keys and values\nfrom the dictionary are copied as pointers into the new\ndictionary (that is, the values themselves are copied, not\nthat which the values point to, if anything). However, the\nkeys and values are also retained by the new dictionary using\nthe retain function of the original dictionary.\nThe count of the new dictionary will be the same as the\ngiven dictionary. The new dictionary uses the same callbacks\nas the dictionary to be copied. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@result A reference to the new mutable CFDictionary."]
    pub fn CFDictionaryCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theDict: CFDictionaryRef,
    ) -> CFMutableDictionaryRef;
}
extern "C" {
    #[doc = "@function CFDictionaryGetCount\nReturns the number of values currently in the dictionary.\n@param theDict The dictionary to be queried. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@result The number of values in the dictionary."]
    pub fn CFDictionaryGetCount(theDict: CFDictionaryRef) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFDictionaryGetCountOfKey\nCounts the number of times the given key occurs in the dictionary.\n@param theDict The dictionary to be searched. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param key The key for which to find matches in the dictionary. The\nhash() and equal() key callbacks provided when the dictionary\nwas created are used to compare. If the hash() key callback\nwas NULL, the key is treated as a pointer and converted to\nan integer. If the equal() key callback was NULL, pointer\nequality (in C, ==) is used. If key, or any of the keys in\nthe dictionary, are not understood by the equal() callback,\nthe behavior is undefined.\n@result Returns 1 if a matching key is used by the dictionary,\n0 otherwise."]
    pub fn CFDictionaryGetCountOfKey(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFDictionaryGetCountOfValue\nCounts the number of times the given value occurs in the dictionary.\n@param theDict The dictionary to be searched. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param value The value for which to find matches in the dictionary. The\nequal() callback provided when the dictionary was created is\nused to compare. If the equal() value callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values in\nthe dictionary, are not understood by the equal() callback,\nthe behavior is undefined.\n@result The number of times the given value occurs in the dictionary."]
    pub fn CFDictionaryGetCountOfValue(
        theDict: CFDictionaryRef,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFDictionaryContainsKey\nReports whether or not the key is in the dictionary.\n@param theDict The dictionary to be searched. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param key The key for which to find matches in the dictionary. The\nhash() and equal() key callbacks provided when the dictionary\nwas created are used to compare. If the hash() key callback\nwas NULL, the key is treated as a pointer and converted to\nan integer. If the equal() key callback was NULL, pointer\nequality (in C, ==) is used. If key, or any of the keys in\nthe dictionary, are not understood by the equal() callback,\nthe behavior is undefined.\n@result true, if the key is in the dictionary, otherwise false."]
    pub fn CFDictionaryContainsKey(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFDictionaryContainsValue\nReports whether or not the value is in the dictionary.\n@param theDict The dictionary to be searched. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param value The value for which to find matches in the dictionary. The\nequal() callback provided when the dictionary was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the dictionary, are not understood by the equal() callback,\nthe behavior is undefined.\n@result true, if the value is in the dictionary, otherwise false."]
    pub fn CFDictionaryContainsValue(
        theDict: CFDictionaryRef,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFDictionaryGetValue\nRetrieves the value associated with the given key.\n@param theDict The dictionary to be queried. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param key The key for which to find a match in the dictionary. The\nhash() and equal() key callbacks provided when the dictionary\nwas created are used to compare. If the hash() key callback\nwas NULL, the key is treated as a pointer and converted to\nan integer. If the equal() key callback was NULL, pointer\nequality (in C, ==) is used. If key, or any of the keys in\nthe dictionary, are not understood by the equal() callback,\nthe behavior is undefined.\n@result The value with the given key in the dictionary, or NULL if\nno key-value pair with a matching key exists. Since NULL\ncan be a valid value in some dictionaries, the function\nCFDictionaryGetValueIfPresent() must be used to distinguish\nNULL-no-found from NULL-is-the-value."]
    pub fn CFDictionaryGetValue(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function CFDictionaryGetValueIfPresent\nRetrieves the value associated with the given key.\n@param theDict The dictionary to be queried. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param key The key for which to find a match in the dictionary. The\nhash() and equal() key callbacks provided when the dictionary\nwas created are used to compare. If the hash() key callback\nwas NULL, the key is treated as a pointer and converted to\nan integer. If the equal() key callback was NULL, pointer\nequality (in C, ==) is used. If key, or any of the keys in\nthe dictionary, are not understood by the equal() callback,\nthe behavior is undefined.\n@param value A pointer to memory which should be filled with the\npointer-sized value if a matching key is found. If no key\nmatch is found, the contents of the storage pointed to by\nthis parameter are undefined. This parameter may be NULL,\nin which case the value from the dictionary is not returned\n(but the return value of this function still indicates\nwhether or not the key-value pair was present).\n@result true, if a matching key was found, false otherwise."]
    pub fn CFDictionaryGetValueIfPresent(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFDictionaryGetKeysAndValues\nFills the two buffers with the keys and values from the dictionary.\n@param theDict The dictionary to be queried. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param keys A C array of pointer-sized values to be filled with keys\nfrom the dictionary. The keys and values C arrays are parallel\nto each other (that is, the items at the same indices form a\nkey-value pair from the dictionary). This parameter may be NULL\nif the keys are not desired. If this parameter is not a valid\npointer to a C array of at least CFDictionaryGetCount() pointers,\nor NULL, the behavior is undefined.\n@param values A C array of pointer-sized values to be filled with values\nfrom the dictionary. The keys and values C arrays are parallel\nto each other (that is, the items at the same indices form a\nkey-value pair from the dictionary). This parameter may be NULL\nif the values are not desired. If this parameter is not a valid\npointer to a C array of at least CFDictionaryGetCount() pointers,\nor NULL, the behavior is undefined."]
    pub fn CFDictionaryGetKeysAndValues(
        theDict: CFDictionaryRef,
        keys: *mut *const ::std::os::raw::c_void,
        values: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFDictionaryApplyFunction\nCalls a function once for each value in the dictionary.\n@param theDict The dictionary to be queried. If this parameter is\nnot a valid CFDictionary, the behavior is undefined.\n@param applier The callback function to call once for each value in\nthe dictionary. If this parameter is not a\npointer to a function of the correct prototype, the behavior\nis undefined. If there are keys or values which the\napplier function does not expect or cannot properly apply\nto, the behavior is undefined.\n@param context A pointer-sized user-defined value, which is passed\nas the third parameter to the applier function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the applier function, the behavior is\nundefined."]
    pub fn CFDictionaryApplyFunction(
        theDict: CFDictionaryRef,
        applier: CFDictionaryApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFDictionaryAddValue\nAdds the key-value pair to the dictionary if no such key already exists.\n@param theDict The dictionary to which the value is to be added. If this\nparameter is not a valid mutable CFDictionary, the behavior is\nundefined.\n@param key The key of the value to add to the dictionary. The key is\nretained by the dictionary using the retain callback provided\nwhen the dictionary was created. If the key is not of the sort\nexpected by the retain callback, the behavior is undefined. If\na key which matches this key is already present in the dictionary,\nthis function does nothing (\"add if absent\").\n@param value The value to add to the dictionary. The value is retained\nby the dictionary using the retain callback provided when the\ndictionary was created. If the value is not of the sort expected\nby the retain callback, the behavior is undefined."]
    pub fn CFDictionaryAddValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFDictionarySetValue\nSets the value of the key in the dictionary.\n@param theDict The dictionary to which the value is to be set. If this\nparameter is not a valid mutable CFDictionary, the behavior is\nundefined.\n@param key The key of the value to set into the dictionary. If a key\nwhich matches this key is already present in the dictionary, only\nthe value is changed (\"add if absent, replace if present\"). If\nno key matches the given key, the key-value pair is added to the\ndictionary. If added, the key is retained by the dictionary,\nusing the retain callback provided\nwhen the dictionary was created. If the key is not of the sort\nexpected by the key retain callback, the behavior is undefined.\n@param value The value to add to or replace into the dictionary. The value\nis retained by the dictionary using the retain callback provided\nwhen the dictionary was created, and the previous value if any is\nreleased. If the value is not of the sort expected by the\nretain or release callbacks, the behavior is undefined."]
    pub fn CFDictionarySetValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFDictionaryReplaceValue\nReplaces the value of the key in the dictionary.\n@param theDict The dictionary to which the value is to be replaced. If this\nparameter is not a valid mutable CFDictionary, the behavior is\nundefined.\n@param key The key of the value to replace in the dictionary. If a key\nwhich matches this key is present in the dictionary, the value\nis changed to the given value, otherwise this function does\nnothing (\"replace if present\").\n@param value The value to replace into the dictionary. The value\nis retained by the dictionary using the retain callback provided\nwhen the dictionary was created, and the previous value is\nreleased. If the value is not of the sort expected by the\nretain or release callbacks, the behavior is undefined."]
    pub fn CFDictionaryReplaceValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFDictionaryRemoveValue\nRemoves the value of the key from the dictionary.\n@param theDict The dictionary from which the value is to be removed. If this\nparameter is not a valid mutable CFDictionary, the behavior is\nundefined.\n@param key The key of the value to remove from the dictionary. If a key\nwhich matches this key is present in the dictionary, the key-value\npair is removed from the dictionary, otherwise this function does\nnothing (\"remove if present\")."]
    pub fn CFDictionaryRemoveValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFDictionaryRemoveAllValues\nRemoves all the values from the dictionary, making it empty.\n@param theDict The dictionary from which all of the values are to be\nremoved. If this parameter is not a valid mutable\nCFDictionary, the behavior is undefined."]
    pub fn CFDictionaryRemoveAllValues(theDict: CFMutableDictionaryRef);
}
pub type CFNotificationName = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNotificationCenter {
    _unused: [u8; 0],
}
pub type CFNotificationCenterRef = *mut __CFNotificationCenter;
pub type CFNotificationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        center: CFNotificationCenterRef,
        observer: *mut ::std::os::raw::c_void,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
        userInfo: CFDictionaryRef,
    ),
>;
pub type CFNotificationSuspensionBehavior = CFIndex;
pub const CFNotificationSuspensionBehaviorDrop: _bindgen_ty_9 = 1;
pub const CFNotificationSuspensionBehaviorCoalesce: _bindgen_ty_9 = 2;
pub const CFNotificationSuspensionBehaviorHold: _bindgen_ty_9 = 3;
pub const CFNotificationSuspensionBehaviorDeliverImmediately: _bindgen_ty_9 = 4;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFNotificationCenterGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFNotificationCenterGetLocalCenter() -> CFNotificationCenterRef;
}
extern "C" {
    pub fn CFNotificationCenterGetDistributedCenter() -> CFNotificationCenterRef;
}
extern "C" {
    pub fn CFNotificationCenterGetDarwinNotifyCenter() -> CFNotificationCenterRef;
}
extern "C" {
    pub fn CFNotificationCenterAddObserver(
        center: CFNotificationCenterRef,
        observer: *const ::std::os::raw::c_void,
        callBack: CFNotificationCallback,
        name: CFStringRef,
        object: *const ::std::os::raw::c_void,
        suspensionBehavior: CFNotificationSuspensionBehavior,
    );
}
extern "C" {
    pub fn CFNotificationCenterRemoveObserver(
        center: CFNotificationCenterRef,
        observer: *const ::std::os::raw::c_void,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFNotificationCenterRemoveEveryObserver(
        center: CFNotificationCenterRef,
        observer: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFNotificationCenterPostNotification(
        center: CFNotificationCenterRef,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
        userInfo: CFDictionaryRef,
        deliverImmediately: Boolean,
    );
}
pub const kCFNotificationDeliverImmediately: _bindgen_ty_10 = 1;
pub const kCFNotificationPostToAllSessions: _bindgen_ty_10 = 2;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFNotificationCenterPostNotificationWithOptions(
        center: CFNotificationCenterRef,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
        userInfo: CFDictionaryRef,
        options: CFOptionFlags,
    );
}
pub type CFLocaleIdentifier = CFStringRef;
pub type CFLocaleKey = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFLocale {
    _unused: [u8; 0],
}
pub type CFLocaleRef = *const __CFLocale;
extern "C" {
    pub fn CFLocaleGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFLocaleGetSystem() -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleCopyCurrent() -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleCopyAvailableLocaleIdentifiers() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyISOLanguageCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyISOCountryCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyISOCurrencyCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyCommonISOCurrencyCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyPreferredLanguages() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCreateCanonicalLanguageIdentifierFromString(
        allocator: CFAllocatorRef,
        localeIdentifier: CFStringRef,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreateCanonicalLocaleIdentifierFromString(
        allocator: CFAllocatorRef,
        localeIdentifier: CFStringRef,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(
        allocator: CFAllocatorRef,
        lcode: LangCode,
        rcode: RegionCode,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(
        allocator: CFAllocatorRef,
        lcid: u32,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(
        localeIdentifier: CFLocaleIdentifier,
    ) -> u32;
}
pub type CFLocaleLanguageDirection = CFIndex;
pub const kCFLocaleLanguageDirectionUnknown: _bindgen_ty_11 = 0;
pub const kCFLocaleLanguageDirectionLeftToRight: _bindgen_ty_11 = 1;
pub const kCFLocaleLanguageDirectionRightToLeft: _bindgen_ty_11 = 2;
pub const kCFLocaleLanguageDirectionTopToBottom: _bindgen_ty_11 = 3;
pub const kCFLocaleLanguageDirectionBottomToTop: _bindgen_ty_11 = 4;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFLocaleGetLanguageCharacterDirection(
        isoLangCode: CFStringRef,
    ) -> CFLocaleLanguageDirection;
}
extern "C" {
    pub fn CFLocaleGetLanguageLineDirection(
        isoLangCode: CFStringRef,
    ) -> CFLocaleLanguageDirection;
}
extern "C" {
    pub fn CFLocaleCreateComponentsFromLocaleIdentifier(
        allocator: CFAllocatorRef,
        localeID: CFLocaleIdentifier,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFLocaleCreateLocaleIdentifierFromComponents(
        allocator: CFAllocatorRef,
        dictionary: CFDictionaryRef,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreate(
        allocator: CFAllocatorRef,
        localeIdentifier: CFLocaleIdentifier,
    ) -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleCreateCopy(
        allocator: CFAllocatorRef,
        locale: CFLocaleRef,
    ) -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleGetIdentifier(locale: CFLocaleRef) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleGetValue(locale: CFLocaleRef, key: CFLocaleKey) -> CFTypeRef;
}
extern "C" {
    pub fn CFLocaleCopyDisplayNameForPropertyValue(
        displayLocale: CFLocaleRef,
        key: CFLocaleKey,
        value: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub static kCFLocaleCurrentLocaleDidChangeNotification: CFNotificationName;
}
extern "C" {
    pub static kCFLocaleIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleLanguageCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCountryCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleScriptCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleVariantCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleExemplarCharacterSet: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCalendarIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCalendar: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCollationIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleUsesMetricSystem: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleMeasurementSystem: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleDecimalSeparator: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleGroupingSeparator: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCurrencySymbol: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCurrencyCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCollatorIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleQuotationBeginDelimiterKey: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleQuotationEndDelimiterKey: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleAlternateQuotationBeginDelimiterKey: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleAlternateQuotationEndDelimiterKey: CFLocaleKey;
}
pub type CFCalendarIdentifier = CFStringRef;
extern "C" {
    pub static kCFGregorianCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFBuddhistCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFChineseCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFHebrewCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicCivilCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFJapaneseCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFRepublicOfChinaCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFPersianCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIndianCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFISO8601Calendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicTabularCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicUmmAlQuraCalendar: CFCalendarIdentifier;
}
pub type CFTimeInterval = f64;
pub type CFAbsoluteTime = CFTimeInterval;
extern "C" {
    pub fn CFAbsoluteTimeGetCurrent() -> CFAbsoluteTime;
}
extern "C" {
    pub static kCFAbsoluteTimeIntervalSince1970: CFTimeInterval;
}
extern "C" {
    pub static kCFAbsoluteTimeIntervalSince1904: CFTimeInterval;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFDate {
    _unused: [u8; 0],
}
pub type CFDateRef = *const __CFDate;
extern "C" {
    pub fn CFDateGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFDateCreate(allocator: CFAllocatorRef, at: CFAbsoluteTime) -> CFDateRef;
}
extern "C" {
    pub fn CFDateGetAbsoluteTime(theDate: CFDateRef) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFDateGetTimeIntervalSinceDate(
        theDate: CFDateRef,
        otherDate: CFDateRef,
    ) -> CFTimeInterval;
}
extern "C" {
    pub fn CFDateCompare(
        theDate: CFDateRef,
        otherDate: CFDateRef,
        context: *mut ::std::os::raw::c_void,
    ) -> CFComparisonResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFTimeZone {
    _unused: [u8; 0],
}
pub type CFTimeZoneRef = *const __CFTimeZone;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFGregorianDate {
    pub year: SInt32,
    pub month: SInt8,
    pub day: SInt8,
    pub hour: SInt8,
    pub minute: SInt8,
    pub second: f64,
}
#[test]
fn bindgen_test_layout_CFGregorianDate() {
    const UNINIT: ::std::mem::MaybeUninit<CFGregorianDate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFGregorianDate>(),
        16usize,
        concat!("Size of: ", stringify!(CFGregorianDate))
    );
    assert_eq!(
        ::std::mem::align_of::<CFGregorianDate>(),
        8usize,
        concat!("Alignment of ", stringify!(CFGregorianDate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minute) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).second) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(second)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFGregorianUnits {
    pub years: SInt32,
    pub months: SInt32,
    pub days: SInt32,
    pub hours: SInt32,
    pub minutes: SInt32,
    pub seconds: f64,
}
#[test]
fn bindgen_test_layout_CFGregorianUnits() {
    const UNINIT: ::std::mem::MaybeUninit<CFGregorianUnits> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFGregorianUnits>(),
        32usize,
        concat!("Size of: ", stringify!(CFGregorianUnits))
    );
    assert_eq!(
        ::std::mem::align_of::<CFGregorianUnits>(),
        8usize,
        concat!("Alignment of ", stringify!(CFGregorianUnits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).years) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(years)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).months) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(days)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hours) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minutes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(seconds)
        )
    );
}
pub type CFGregorianUnitFlags = CFOptionFlags;
pub const kCFGregorianUnitsYears: _bindgen_ty_12 = 1;
pub const kCFGregorianUnitsMonths: _bindgen_ty_12 = 2;
pub const kCFGregorianUnitsDays: _bindgen_ty_12 = 4;
pub const kCFGregorianUnitsHours: _bindgen_ty_12 = 8;
pub const kCFGregorianUnitsMinutes: _bindgen_ty_12 = 16;
pub const kCFGregorianUnitsSeconds: _bindgen_ty_12 = 32;
pub const kCFGregorianAllUnits: _bindgen_ty_12 = 16777215;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFGregorianDateIsValid(
        gdate: CFGregorianDate,
        unitFlags: CFOptionFlags,
    ) -> Boolean;
}
extern "C" {
    pub fn CFGregorianDateGetAbsoluteTime(
        gdate: CFGregorianDate,
        tz: CFTimeZoneRef,
    ) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFAbsoluteTimeGetGregorianDate(
        at: CFAbsoluteTime,
        tz: CFTimeZoneRef,
    ) -> CFGregorianDate;
}
extern "C" {
    pub fn CFAbsoluteTimeAddGregorianUnits(
        at: CFAbsoluteTime,
        tz: CFTimeZoneRef,
        units: CFGregorianUnits,
    ) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFAbsoluteTimeGetDifferenceAsGregorianUnits(
        at1: CFAbsoluteTime,
        at2: CFAbsoluteTime,
        tz: CFTimeZoneRef,
        unitFlags: CFOptionFlags,
    ) -> CFGregorianUnits;
}
extern "C" {
    pub fn CFAbsoluteTimeGetDayOfWeek(at: CFAbsoluteTime, tz: CFTimeZoneRef) -> SInt32;
}
extern "C" {
    pub fn CFAbsoluteTimeGetDayOfYear(at: CFAbsoluteTime, tz: CFTimeZoneRef) -> SInt32;
}
extern "C" {
    pub fn CFAbsoluteTimeGetWeekOfYear(at: CFAbsoluteTime, tz: CFTimeZoneRef) -> SInt32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFData {
    _unused: [u8; 0],
}
pub type CFDataRef = *const __CFData;
pub type CFMutableDataRef = *mut __CFData;
extern "C" {
    pub fn CFDataGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFDataCreate(
        allocator: CFAllocatorRef,
        bytes: *const UInt8,
        length: CFIndex,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFDataCreateWithBytesNoCopy(
        allocator: CFAllocatorRef,
        bytes: *const UInt8,
        length: CFIndex,
        bytesDeallocator: CFAllocatorRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFDataCreateCopy(allocator: CFAllocatorRef, theData: CFDataRef) -> CFDataRef;
}
extern "C" {
    pub fn CFDataCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
    ) -> CFMutableDataRef;
}
extern "C" {
    pub fn CFDataCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theData: CFDataRef,
    ) -> CFMutableDataRef;
}
extern "C" {
    pub fn CFDataGetLength(theData: CFDataRef) -> CFIndex;
}
extern "C" {
    pub fn CFDataGetBytePtr(theData: CFDataRef) -> *const UInt8;
}
extern "C" {
    pub fn CFDataGetMutableBytePtr(theData: CFMutableDataRef) -> *mut UInt8;
}
extern "C" {
    pub fn CFDataGetBytes(theData: CFDataRef, range: CFRange, buffer: *mut UInt8);
}
extern "C" {
    pub fn CFDataSetLength(theData: CFMutableDataRef, length: CFIndex);
}
extern "C" {
    pub fn CFDataIncreaseLength(theData: CFMutableDataRef, extraLength: CFIndex);
}
extern "C" {
    pub fn CFDataAppendBytes(
        theData: CFMutableDataRef,
        bytes: *const UInt8,
        length: CFIndex,
    );
}
extern "C" {
    pub fn CFDataReplaceBytes(
        theData: CFMutableDataRef,
        range: CFRange,
        newBytes: *const UInt8,
        newLength: CFIndex,
    );
}
extern "C" {
    pub fn CFDataDeleteBytes(theData: CFMutableDataRef, range: CFRange);
}
pub type CFDataSearchFlags = CFOptionFlags;
pub const kCFDataSearchBackwards: _bindgen_ty_13 = 1;
pub const kCFDataSearchAnchored: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFDataFind(
        theData: CFDataRef,
        dataToFind: CFDataRef,
        searchRange: CFRange,
        compareOptions: CFDataSearchFlags,
    ) -> CFRange;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFCharacterSet {
    _unused: [u8; 0],
}
#[doc = "@typedef CFCharacterSetRef\nThis is the type of a reference to immutable CFCharacterSets."]
pub type CFCharacterSetRef = *const __CFCharacterSet;
#[doc = "@typedef CFMutableCharacterSetRef\nThis is the type of a reference to mutable CFMutableCharacterSets."]
pub type CFMutableCharacterSetRef = *mut __CFCharacterSet;
#[doc = "@typedef CFCharacterSetPredefinedSet\nType of the predefined CFCharacterSet selector values."]
pub type CFCharacterSetPredefinedSet = CFIndex;
pub const kCFCharacterSetControl: _bindgen_ty_14 = 1;
pub const kCFCharacterSetWhitespace: _bindgen_ty_14 = 2;
pub const kCFCharacterSetWhitespaceAndNewline: _bindgen_ty_14 = 3;
pub const kCFCharacterSetDecimalDigit: _bindgen_ty_14 = 4;
pub const kCFCharacterSetLetter: _bindgen_ty_14 = 5;
pub const kCFCharacterSetLowercaseLetter: _bindgen_ty_14 = 6;
pub const kCFCharacterSetUppercaseLetter: _bindgen_ty_14 = 7;
pub const kCFCharacterSetNonBase: _bindgen_ty_14 = 8;
pub const kCFCharacterSetDecomposable: _bindgen_ty_14 = 9;
pub const kCFCharacterSetAlphaNumeric: _bindgen_ty_14 = 10;
pub const kCFCharacterSetPunctuation: _bindgen_ty_14 = 11;
pub const kCFCharacterSetCapitalizedLetter: _bindgen_ty_14 = 13;
pub const kCFCharacterSetSymbol: _bindgen_ty_14 = 14;
pub const kCFCharacterSetNewline: _bindgen_ty_14 = 15;
pub const kCFCharacterSetIllegal: _bindgen_ty_14 = 12;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "@function CFCharacterSetGetTypeID\nReturns the type identifier of all CFCharacterSet instances."]
    pub fn CFCharacterSetGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFCharacterSetGetPredefined\nReturns a predefined CFCharacterSet instance.\n@param theSetIdentifier The CFCharacterSetPredefinedSet selector\nwhich specifies the predefined character set.  If the\nvalue is not in CFCharacterSetPredefinedSet, the behavior\nis undefined.\n@result A reference to the predefined immutable CFCharacterSet.\nThis instance is owned by CF."]
    pub fn CFCharacterSetGetPredefined(
        theSetIdentifier: CFCharacterSetPredefinedSet,
    ) -> CFCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateWithCharactersInRange\nCreates a new immutable character set with the values from the given range.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theRange The CFRange which should be used to specify the\nUnicode range the character set is filled with.  It\naccepts the range in 32-bit in the UTF-32 format.  The\nvalid character point range is from 0x00000 to 0x10FFFF.\nIf the range is outside of the valid Unicode character\npoint, the behavior is undefined.\n@result A reference to the new immutable CFCharacterSet."]
    pub fn CFCharacterSetCreateWithCharactersInRange(
        alloc: CFAllocatorRef,
        theRange: CFRange,
    ) -> CFCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateWithCharactersInString\nCreates a new immutable character set with the values in the given string.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theString The CFString which should be used to specify\nthe Unicode characters the character set is filled with.\nIf this parameter is not a valid CFString, the behavior\nis undefined.\n@result A reference to the new immutable CFCharacterSet."]
    pub fn CFCharacterSetCreateWithCharactersInString(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateWithBitmapRepresentation\nCreates a new immutable character set with the bitmap representtion in the given data.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theData The CFData which should be used to specify the\nbitmap representation of the Unicode character points\nthe character set is filled with.  The bitmap\nrepresentation could contain all the Unicode character\nrange starting from BMP to Plane 16.  The first 8192 bytes\nof the data represent the BMP range.  The BMP range 8192\nbytes can be followed by zero to sixteen 8192 byte\nbitmaps, each one with the plane index byte prepended.\nFor example, the bitmap representing the BMP and Plane 2\nhas the size of 16385 bytes (8192 bytes for BMP, 1 byte\nindex + 8192 bytes bitmap for Plane 2).  The plane index\nbyte, in this case, contains the integer value two.  If\nthis parameter is not a valid CFData or it contains a\nPlane index byte outside of the valid Plane range\n(1 to 16), the behavior is undefined.\n@result A reference to the new immutable CFCharacterSet."]
    pub fn CFCharacterSetCreateWithBitmapRepresentation(
        alloc: CFAllocatorRef,
        theData: CFDataRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateInvertedSet\nCreates a new immutable character set that is the invert of the specified character set.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theSet The CFCharacterSet which is to be inverted.  If this\nparameter is not a valid CFCharacterSet, the behavior is\nundefined.\n@result A reference to the new immutable CFCharacterSet."]
    pub fn CFCharacterSetCreateInvertedSet(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetIsSupersetOfSet\nReports whether or not the character set is a superset of the character set specified as the second parameter.\n@param theSet  The character set to be checked for the membership of theOtherSet.\nIf this parameter is not a valid CFCharacterSet, the behavior is undefined.\n@param theOtherset  The character set to be checked whether or not it is a subset of theSet.\nIf this parameter is not a valid CFCharacterSet, the behavior is undefined."]
    pub fn CFCharacterSetIsSupersetOfSet(
        theSet: CFCharacterSetRef,
        theOtherset: CFCharacterSetRef,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFCharacterSetHasMemberInPlane\nReports whether or not the character set contains at least one member character in the specified plane.\n@param theSet  The character set to be checked for the membership.  If this\nparameter is not a valid CFCharacterSet, the behavior is undefined.\n@param thePlane  The plane number to be checked for the membership.\nThe valid value range is from 0 to 16.  If the value is outside of the valid\nplane number range, the behavior is undefined."]
    pub fn CFCharacterSetHasMemberInPlane(
        theSet: CFCharacterSetRef,
        thePlane: CFIndex,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateMutable\nCreates a new empty mutable character set.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@result A reference to the new mutable CFCharacterSet."]
    pub fn CFCharacterSetCreateMutable(alloc: CFAllocatorRef)
        -> CFMutableCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateCopy\nCreates a new character set with the values from the given character set.  This function tries to compact the backing store where applicable.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theSet The CFCharacterSet which is to be copied.  If this\nparameter is not a valid CFCharacterSet, the behavior is\nundefined.\n@result A reference to the new CFCharacterSet."]
    pub fn CFCharacterSetCreateCopy(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateMutableCopy\nCreates a new mutable character set with the values from the given character set.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theSet The CFCharacterSet which is to be copied.  If this\nparameter is not a valid CFCharacterSet, the behavior is\nundefined.\n@result A reference to the new mutable CFCharacterSet."]
    pub fn CFCharacterSetCreateMutableCopy(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFMutableCharacterSetRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetIsCharacterMember\nReports whether or not the Unicode character is in the character set.\n@param theSet The character set to be searched. If this parameter\nis not a valid CFCharacterSet, the behavior is undefined.\n@param theChar The Unicode character for which to test against the\ncharacter set.  Note that this function takes 16-bit Unicode\ncharacter value; hence, it does not support access to the\nnon-BMP planes.\n@result true, if the value is in the character set, otherwise false."]
    pub fn CFCharacterSetIsCharacterMember(
        theSet: CFCharacterSetRef,
        theChar: UniChar,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFCharacterSetIsLongCharacterMember\nReports whether or not the UTF-32 character is in the character set.\n@param theSet The character set to be searched. If this parameter\nis not a valid CFCharacterSet, the behavior is undefined.\n@param theChar The UTF-32 character for which to test against the\ncharacter set.\n@result true, if the value is in the character set, otherwise false."]
    pub fn CFCharacterSetIsLongCharacterMember(
        theSet: CFCharacterSetRef,
        theChar: UTF32Char,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFCharacterSetCreateBitmapRepresentation\nCreates a new immutable data with the bitmap representation from the given character set.\n@param alloc The CFAllocator which should be used to allocate\nmemory for the array and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theSet The CFCharacterSet which is to be used create the\nbitmap representation from.  Refer to the comments for\nCFCharacterSetCreateWithBitmapRepresentation for the\ndetailed discussion of the bitmap representation format.\nIf this parameter is not a valid CFCharacterSet, the\nbehavior is undefined.\n@result A reference to the new immutable CFData."]
    pub fn CFCharacterSetCreateBitmapRepresentation(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFDataRef;
}
extern "C" {
    #[doc = "@function CFCharacterSetAddCharactersInRange\nAdds the given range to the charaacter set.\n@param theSet The character set to which the range is to be added.\nIf this parameter is not a valid mutable CFCharacterSet,\nthe behavior is undefined.\n@param theRange The range to add to the character set.  It accepts\nthe range in 32-bit in the UTF-32 format.  The valid\ncharacter point range is from 0x00000 to 0x10FFFF.  If the\nrange is outside of the valid Unicode character point,\nthe behavior is undefined."]
    pub fn CFCharacterSetAddCharactersInRange(
        theSet: CFMutableCharacterSetRef,
        theRange: CFRange,
    );
}
extern "C" {
    #[doc = "@function CFCharacterSetRemoveCharactersInRange\nRemoves the given range from the charaacter set.\n@param theSet The character set from which the range is to be\nremoved.  If this parameter is not a valid mutable\nCFCharacterSet, the behavior is undefined.\n@param theRange The range to remove from the character set.\nIt accepts the range in 32-bit in the UTF-32 format.\nThe valid character point range is from 0x00000 to 0x10FFFF.\nIf the range is outside of the valid Unicode character point,\nthe behavior is undefined."]
    pub fn CFCharacterSetRemoveCharactersInRange(
        theSet: CFMutableCharacterSetRef,
        theRange: CFRange,
    );
}
extern "C" {
    #[doc = "@function CFCharacterSetAddCharactersInString\nAdds the characters in the given string to the charaacter set.\n@param theSet The character set to which the characters in the\nstring are to be added.  If this parameter is not a\nvalid mutable CFCharacterSet, the behavior is undefined.\n@param theString The string to add to the character set.\nIf this parameter is not a valid CFString, the behavior\nis undefined."]
    pub fn CFCharacterSetAddCharactersInString(
        theSet: CFMutableCharacterSetRef,
        theString: CFStringRef,
    );
}
extern "C" {
    #[doc = "@function CFCharacterSetRemoveCharactersInString\nRemoves the characters in the given string from the charaacter set.\n@param theSet The character set from which the characters in the\nstring are to be remove.  If this parameter is not a\nvalid mutable CFCharacterSet, the behavior is undefined.\n@param theString The string to remove from the character set.\nIf this parameter is not a valid CFString, the behavior\nis undefined."]
    pub fn CFCharacterSetRemoveCharactersInString(
        theSet: CFMutableCharacterSetRef,
        theString: CFStringRef,
    );
}
extern "C" {
    #[doc = "@function CFCharacterSetUnion\nForms the union with the given character set.\n@param theSet The destination character set into which the\nunion of the two character sets is stored.  If this\nparameter is not a valid mutable CFCharacterSet, the\nbehavior is undefined.\n@param theOtherSet The character set with which the union is\nformed.  If this parameter is not a valid CFCharacterSet,\nthe behavior is undefined."]
    pub fn CFCharacterSetUnion(
        theSet: CFMutableCharacterSetRef,
        theOtherSet: CFCharacterSetRef,
    );
}
extern "C" {
    #[doc = "@function CFCharacterSetIntersect\nForms the intersection with the given character set.\n@param theSet The destination character set into which the\nintersection of the two character sets is stored.\nIf this parameter is not a valid mutable CFCharacterSet,\nthe behavior is undefined.\n@param theOtherSet The character set with which the intersection\nis formed.  If this parameter is not a valid CFCharacterSet,\nthe behavior is undefined."]
    pub fn CFCharacterSetIntersect(
        theSet: CFMutableCharacterSetRef,
        theOtherSet: CFCharacterSetRef,
    );
}
extern "C" {
    #[doc = "@function CFCharacterSetInvert\nInverts the content of the given character set.\n@param theSet The character set to be inverted.\nIf this parameter is not a valid mutable CFCharacterSet,\nthe behavior is undefined."]
    pub fn CFCharacterSetInvert(theSet: CFMutableCharacterSetRef);
}
pub type CFErrorDomain = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFError {
    _unused: [u8; 0],
}
#[doc = "@typedef CFErrorRef\nThis is the type of a reference to CFErrors.  CFErrorRef is toll-free bridged with NSError."]
pub type CFErrorRef = *mut __CFError;
extern "C" {
    #[doc = "@function CFErrorGetTypeID\nReturns the type identifier of all CFError instances."]
    pub fn CFErrorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub static kCFErrorDomainPOSIX: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorDomainOSStatus: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorDomainMach: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorDomainCocoa: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorLocalizedDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorLocalizedFailureKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorLocalizedFailureReasonKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorLocalizedRecoverySuggestionKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorUnderlyingErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorURLKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorFilePathKey: CFStringRef;
}
extern "C" {
    #[doc = "@function CFErrorCreate\n@abstract Creates a new CFError.\n@param allocator The CFAllocator which should be used to allocate memory for the error. This parameter may be NULL in which case the\ncurrent default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.\n@param domain A CFString identifying the error domain. If this reference is NULL or is otherwise not a valid CFString, the behavior is undefined.\n@param code A CFIndex identifying the error code. The code is interpreted within the context of the error domain.\n@param userInfo A CFDictionary created with kCFCopyStringDictionaryKeyCallBacks and kCFTypeDictionaryValueCallBacks. It will be copied with CFDictionaryCreateCopy().\nIf no userInfo dictionary is desired, NULL may be passed in as a convenience, in which case an empty userInfo dictionary will be assigned.\n@result A reference to the new CFError."]
    pub fn CFErrorCreate(
        allocator: CFAllocatorRef,
        domain: CFErrorDomain,
        code: CFIndex,
        userInfo: CFDictionaryRef,
    ) -> CFErrorRef;
}
extern "C" {
    #[doc = "@function CFErrorCreateWithUserInfoKeysAndValues\n@abstract Creates a new CFError without having to create an intermediate userInfo dictionary.\n@param allocator The CFAllocator which should be used to allocate memory for the error. This parameter may be NULL in which case the\ncurrent default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.\n@param domain A CFString identifying the error domain. If this reference is NULL or is otherwise not a valid CFString, the behavior is undefined.\n@param code A CFIndex identifying the error code. The code is interpreted within the context of the error domain.\n@param userInfoKeys An array of numUserInfoValues CFStrings used as keys in creating the userInfo dictionary. NULL is valid only if numUserInfoValues is 0.\n@param userInfoValues An array of numUserInfoValues CF types used as values in creating the userInfo dictionary.  NULL is valid only if numUserInfoValues is 0.\n@param numUserInfoValues CFIndex representing the number of keys and values in the userInfoKeys and userInfoValues arrays.\n@result A reference to the new CFError. numUserInfoValues CF types are gathered from each of userInfoKeys and userInfoValues to create the userInfo dictionary."]
    pub fn CFErrorCreateWithUserInfoKeysAndValues(
        allocator: CFAllocatorRef,
        domain: CFErrorDomain,
        code: CFIndex,
        userInfoKeys: *const *const ::std::os::raw::c_void,
        userInfoValues: *const *const ::std::os::raw::c_void,
        numUserInfoValues: CFIndex,
    ) -> CFErrorRef;
}
extern "C" {
    #[doc = "@function CFErrorGetDomain\n@abstract Returns the error domain the CFError was created with.\n@param err The CFError whose error domain is to be returned. If this reference is not a valid CFError, the behavior is undefined.\n@result The error domain of the CFError. Since this is a \"Get\" function, the caller shouldn't CFRelease the return value."]
    pub fn CFErrorGetDomain(err: CFErrorRef) -> CFErrorDomain;
}
extern "C" {
    #[doc = "@function CFErrorGetCode\n@abstract Returns the error code the CFError was created with.\n@param err The CFError whose error code is to be returned. If this reference is not a valid CFError, the behavior is undefined.\n@result The error code of the CFError (not an error return for the current call)."]
    pub fn CFErrorGetCode(err: CFErrorRef) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFErrorCopyUserInfo\n@abstract Returns CFError userInfo dictionary.\n@discussion Returns a dictionary containing the same keys and values as in the userInfo dictionary the CFError was created with. Returns an empty dictionary if NULL was supplied to CFErrorCreate().\n@param err The CFError whose error user info is to be returned. If this reference is not a valid CFError, the behavior is undefined.\n@result The user info of the CFError."]
    pub fn CFErrorCopyUserInfo(err: CFErrorRef) -> CFDictionaryRef;
}
extern "C" {
    #[doc = "@function CFErrorCopyDescription\n@abstract Returns a human-presentable description for the error. CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedDescriptionKey at the time of CFError creation.\n@discussion This is a complete sentence or two which says what failed and why it failed. Please refer to header comments for -[NSError localizedDescription] for details on the steps used to compute this; but roughly:\n- Use value of kCFErrorLocalizedDescriptionKey as-is if provided.\n- Use value of kCFErrorLocalizedFailureKey if provided, optionally followed by kCFErrorLocalizedFailureReasonKey if available.\n- Use value of kCFErrorLocalizedFailureReasonKey, combining with a generic failure message such as: \"Operation code not be completed. \" + kCFErrorLocalizedFailureReasonKey.\n- If all of the above fail, generate a semi-user presentable string from kCFErrorDescriptionKey, the domain, and code. Something like: \"Operation could not be completed. Error domain/code occurred. \" or \"Operation could not be completed. \" + kCFErrorDescriptionKey + \" (Error domain/code)\"\nToll-free bridged NSError instances might provide additional behaviors for manufacturing a description string.  Do not count on the exact contents or format of the returned string, it might change.\n@param err The CFError whose description is to be returned. If this reference is not a valid CFError, the behavior is undefined.\n@result A CFString with human-presentable description of the CFError. Never NULL."]
    pub fn CFErrorCopyDescription(err: CFErrorRef) -> CFStringRef;
}
extern "C" {
    #[doc = "@function CFErrorCopyFailureReason\n@abstract Returns a human-presentable failure reason for the error.  May return NULL.  CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedFailureReasonKey at the time of CFError creation.\n@discussion This is a complete sentence which describes why the operation failed. In many cases this will be just the \"because\" part of the description (but as a complete sentence, which makes localization easier). By default this looks for kCFErrorLocalizedFailureReasonKey in the user info. Toll-free bridged NSError instances might provide additional behaviors for manufacturing this value. If no user-presentable string is available, returns NULL.\nExample Description: \"Could not save file 'Letter' in folder 'Documents' because the volume 'MyDisk' doesn't have enough space.\"\nCorresponding FailureReason: \"The volume 'MyDisk' doesn't have enough space.\"\n@param err The CFError whose failure reason is to be returned. If this reference is not a valid CFError, the behavior is undefined.\n@result A CFString with the localized, end-user presentable failure reason of the CFError, or NULL."]
    pub fn CFErrorCopyFailureReason(err: CFErrorRef) -> CFStringRef;
}
extern "C" {
    #[doc = "@function CFErrorCopyRecoverySuggestion\n@abstract Returns a human presentable recovery suggestion for the error.  May return NULL.  CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedRecoverySuggestionKey at the time of CFError creation.\n@discussion This is the string that can be displayed as the \"informative\" (aka \"secondary\") message on an alert panel. By default this looks for kCFErrorLocalizedRecoverySuggestionKey in the user info. Toll-free bridged NSError instances might provide additional behaviors for manufacturing this value. If no user-presentable string is available, returns NULL.\nExample Description: \"Could not save file 'Letter' in folder 'Documents' because the volume 'MyDisk' doesn't have enough space.\"\nCorresponding RecoverySuggestion: \"Remove some files from the volume and try again.\"\n@param err The CFError whose recovery suggestion is to be returned. If this reference is not a valid CFError, the behavior is undefined.\n@result A CFString with the localized, end-user presentable recovery suggestion of the CFError, or NULL."]
    pub fn CFErrorCopyRecoverySuggestion(err: CFErrorRef) -> CFStringRef;
}
pub type CFStringEncoding = UInt32;
pub type CFStringBuiltInEncodings = CFStringEncoding;
pub const kCFStringEncodingMacRoman: _bindgen_ty_15 = 0;
pub const kCFStringEncodingWindowsLatin1: _bindgen_ty_15 = 1280;
pub const kCFStringEncodingISOLatin1: _bindgen_ty_15 = 513;
pub const kCFStringEncodingNextStepLatin: _bindgen_ty_15 = 2817;
pub const kCFStringEncodingASCII: _bindgen_ty_15 = 1536;
pub const kCFStringEncodingUnicode: _bindgen_ty_15 = 256;
pub const kCFStringEncodingUTF8: _bindgen_ty_15 = 134217984;
pub const kCFStringEncodingNonLossyASCII: _bindgen_ty_15 = 3071;
pub const kCFStringEncodingUTF16: _bindgen_ty_15 = 256;
pub const kCFStringEncodingUTF16BE: _bindgen_ty_15 = 268435712;
pub const kCFStringEncodingUTF16LE: _bindgen_ty_15 = 335544576;
pub const kCFStringEncodingUTF32: _bindgen_ty_15 = 201326848;
pub const kCFStringEncodingUTF32BE: _bindgen_ty_15 = 402653440;
pub const kCFStringEncodingUTF32LE: _bindgen_ty_15 = 469762304;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFStringGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = " Immutable string creation functions"]
    pub fn CFStringCreateWithPascalString(
        alloc: CFAllocatorRef,
        pStr: ConstStr255Param,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCString(
        alloc: CFAllocatorRef,
        cStr: *const ::std::os::raw::c_char,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithBytes(
        alloc: CFAllocatorRef,
        bytes: *const UInt8,
        numBytes: CFIndex,
        encoding: CFStringEncoding,
        isExternalRepresentation: Boolean,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCharacters(
        alloc: CFAllocatorRef,
        chars: *const UniChar,
        numChars: CFIndex,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithPascalStringNoCopy(
        alloc: CFAllocatorRef,
        pStr: ConstStr255Param,
        encoding: CFStringEncoding,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCStringNoCopy(
        alloc: CFAllocatorRef,
        cStr: *const ::std::os::raw::c_char,
        encoding: CFStringEncoding,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithBytesNoCopy(
        alloc: CFAllocatorRef,
        bytes: *const UInt8,
        numBytes: CFIndex,
        encoding: CFStringEncoding,
        isExternalRepresentation: Boolean,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCharactersNoCopy(
        alloc: CFAllocatorRef,
        chars: *const UniChar,
        numChars: CFIndex,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithSubstring(
        alloc: CFAllocatorRef,
        str_: CFStringRef,
        range: CFRange,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateCopy(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithFormat(
        alloc: CFAllocatorRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        ...
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithFormatAndArguments(
        alloc: CFAllocatorRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        arguments: va_list,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateStringWithValidatedFormat(
        alloc: CFAllocatorRef,
        formatOptions: CFDictionaryRef,
        validFormatSpecifiers: CFStringRef,
        format: CFStringRef,
        errorPtr: *mut CFErrorRef,
        ...
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateStringWithValidatedFormatAndArguments(
        alloc: CFAllocatorRef,
        formatOptions: CFDictionaryRef,
        validFormatSpecifiers: CFStringRef,
        format: CFStringRef,
        arguments: va_list,
        errorPtr: *mut CFErrorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateMutable(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
    ) -> CFMutableStringRef;
}
extern "C" {
    pub fn CFStringCreateMutableCopy(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
        theString: CFStringRef,
    ) -> CFMutableStringRef;
}
extern "C" {
    pub fn CFStringCreateMutableWithExternalCharactersNoCopy(
        alloc: CFAllocatorRef,
        chars: *mut UniChar,
        numChars: CFIndex,
        capacity: CFIndex,
        externalCharactersAllocator: CFAllocatorRef,
    ) -> CFMutableStringRef;
}
extern "C" {
    #[doc = " Basic accessors for the contents"]
    pub fn CFStringGetLength(theString: CFStringRef) -> CFIndex;
}
extern "C" {
    pub fn CFStringGetCharacterAtIndex(theString: CFStringRef, idx: CFIndex) -> UniChar;
}
extern "C" {
    pub fn CFStringGetCharacters(
        theString: CFStringRef,
        range: CFRange,
        buffer: *mut UniChar,
    );
}
extern "C" {
    pub fn CFStringGetPascalString(
        theString: CFStringRef,
        buffer: StringPtr,
        bufferSize: CFIndex,
        encoding: CFStringEncoding,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetCString(
        theString: CFStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: CFIndex,
        encoding: CFStringEncoding,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetPascalStringPtr(
        theString: CFStringRef,
        encoding: CFStringEncoding,
    ) -> ConstStringPtr;
}
extern "C" {
    pub fn CFStringGetCStringPtr(
        theString: CFStringRef,
        encoding: CFStringEncoding,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CFStringGetCharactersPtr(theString: CFStringRef) -> *const UniChar;
}
extern "C" {
    pub fn CFStringGetBytes(
        theString: CFStringRef,
        range: CFRange,
        encoding: CFStringEncoding,
        lossByte: UInt8,
        isExternalRepresentation: Boolean,
        buffer: *mut UInt8,
        maxBufLen: CFIndex,
        usedBufLen: *mut CFIndex,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringCreateFromExternalRepresentation(
        alloc: CFAllocatorRef,
        data: CFDataRef,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateExternalRepresentation(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
        encoding: CFStringEncoding,
        lossByte: UInt8,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFStringGetSmallestEncoding(theString: CFStringRef) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetFastestEncoding(theString: CFStringRef) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetSystemEncoding() -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetMaximumSizeForEncoding(
        length: CFIndex,
        encoding: CFStringEncoding,
    ) -> CFIndex;
}
extern "C" {
    #[doc = " FileSystem path conversion functions"]
    pub fn CFStringGetFileSystemRepresentation(
        string: CFStringRef,
        buffer: *mut ::std::os::raw::c_char,
        maxBufLen: CFIndex,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetMaximumSizeOfFileSystemRepresentation(
        string: CFStringRef,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringCreateWithFileSystemRepresentation(
        alloc: CFAllocatorRef,
        buffer: *const ::std::os::raw::c_char,
    ) -> CFStringRef;
}
pub type CFStringCompareFlags = CFOptionFlags;
pub const kCFCompareCaseInsensitive: _bindgen_ty_16 = 1;
pub const kCFCompareBackwards: _bindgen_ty_16 = 4;
pub const kCFCompareAnchored: _bindgen_ty_16 = 8;
pub const kCFCompareNonliteral: _bindgen_ty_16 = 16;
pub const kCFCompareLocalized: _bindgen_ty_16 = 32;
pub const kCFCompareNumerically: _bindgen_ty_16 = 64;
pub const kCFCompareDiacriticInsensitive: _bindgen_ty_16 = 128;
pub const kCFCompareWidthInsensitive: _bindgen_ty_16 = 256;
pub const kCFCompareForcedOrdering: _bindgen_ty_16 = 512;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFStringCompareWithOptionsAndLocale(
        theString1: CFStringRef,
        theString2: CFStringRef,
        rangeToCompare: CFRange,
        compareOptions: CFStringCompareFlags,
        locale: CFLocaleRef,
    ) -> CFComparisonResult;
}
extern "C" {
    pub fn CFStringCompareWithOptions(
        theString1: CFStringRef,
        theString2: CFStringRef,
        rangeToCompare: CFRange,
        compareOptions: CFStringCompareFlags,
    ) -> CFComparisonResult;
}
extern "C" {
    pub fn CFStringCompare(
        theString1: CFStringRef,
        theString2: CFStringRef,
        compareOptions: CFStringCompareFlags,
    ) -> CFComparisonResult;
}
extern "C" {
    pub fn CFStringFindWithOptionsAndLocale(
        theString: CFStringRef,
        stringToFind: CFStringRef,
        rangeToSearch: CFRange,
        searchOptions: CFStringCompareFlags,
        locale: CFLocaleRef,
        result: *mut CFRange,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringFindWithOptions(
        theString: CFStringRef,
        stringToFind: CFStringRef,
        rangeToSearch: CFRange,
        searchOptions: CFStringCompareFlags,
        result: *mut CFRange,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringCreateArrayWithFindResults(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
        stringToFind: CFStringRef,
        rangeToSearch: CFRange,
        compareOptions: CFStringCompareFlags,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFStringFind(
        theString: CFStringRef,
        stringToFind: CFStringRef,
        compareOptions: CFStringCompareFlags,
    ) -> CFRange;
}
extern "C" {
    pub fn CFStringHasPrefix(theString: CFStringRef, prefix: CFStringRef) -> Boolean;
}
extern "C" {
    pub fn CFStringHasSuffix(theString: CFStringRef, suffix: CFStringRef) -> Boolean;
}
extern "C" {
    #[doc = "@function CFStringGetRangeOfComposedCharactersAtIndex\nReturns the range of the composed character sequence at the specified index.\n@param theString The CFString which is to be searched.  If this\nparameter is not a valid CFString, the behavior is\nundefined.\n@param theIndex The index of the character contained in the\ncomposed character sequence.  If the index is\noutside the index space of the string (0 to N-1 inclusive,\nwhere N is the length of the string), the behavior is\nundefined.\n@result The range of the composed character sequence."]
    pub fn CFStringGetRangeOfComposedCharactersAtIndex(
        theString: CFStringRef,
        theIndex: CFIndex,
    ) -> CFRange;
}
extern "C" {
    #[doc = "@function CFStringFindCharacterFromSet\nQuery the range of the first character contained in the specified character set.\n@param theString The CFString which is to be searched.  If this\nparameter is not a valid CFString, the behavior is\nundefined.\n@param theSet The CFCharacterSet against which the membership\nof characters is checked.  If this parameter is not a valid\nCFCharacterSet, the behavior is undefined.\n@param rangeToSearch The range of characters within the string to search. If\nthe range location or end point (defined by the location\nplus length minus 1) are outside the index space of the\nstring (0 to N-1 inclusive, where N is the length of the\nstring), the behavior is undefined. If the range length is\nnegative, the behavior is undefined. The range may be empty\n(length 0), in which case no search is performed.\n@param searchOptions The bitwise-or'ed option flags to control\nthe search behavior.  The supported options are\nkCFCompareBackwards andkCFCompareAnchored.\nIf other option flags are specified, the behavior\nis undefined.\n@param result The pointer to a CFRange supplied by the caller in\nwhich the search result is stored.  Note that the length\nof this range can be more than 1, if for instance the\nresult is a composed character. If a pointer to an invalid\nmemory is specified, the behavior is undefined.\n@result true, if at least a character which is a member of the character\nset is found and result is filled, otherwise, false."]
    pub fn CFStringFindCharacterFromSet(
        theString: CFStringRef,
        theSet: CFCharacterSetRef,
        rangeToSearch: CFRange,
        searchOptions: CFStringCompareFlags,
        result: *mut CFRange,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetLineBounds(
        theString: CFStringRef,
        range: CFRange,
        lineBeginIndex: *mut CFIndex,
        lineEndIndex: *mut CFIndex,
        contentsEndIndex: *mut CFIndex,
    );
}
extern "C" {
    pub fn CFStringGetParagraphBounds(
        string: CFStringRef,
        range: CFRange,
        parBeginIndex: *mut CFIndex,
        parEndIndex: *mut CFIndex,
        contentsEndIndex: *mut CFIndex,
    );
}
extern "C" {
    #[doc = "@function CFStringGetHyphenationLocationBeforeIndex\nRetrieve the first potential hyphenation location found before the specified location.\n@param string The CFString which is to be hyphenated.  If this\nparameter is not a valid CFString, the behavior is\nundefined.\n@param location An index in the string.  If a valid hyphen index is returned, it\nwill be before this index.\n@param limitRange The range of characters within the string to search. If\nthe range location or end point (defined by the location\nplus length minus 1) are outside the index space of the\nstring (0 to N-1 inclusive, where N is the length of the\nstring), the behavior is undefined. If the range length is\nnegative, the behavior is undefined. The range may be empty\n(length 0), in which case no hyphen location is generated.\n@param options Reserved for future use.\n@param locale Specifies which language's hyphenation conventions to use.\nThis must be a valid locale.  Hyphenation data is not available\nfor all locales.  You can use CFStringIsHyphenationAvailableForLocale\nto test for availability of hyphenation data.\n@param character The suggested hyphen character to insert.  Pass NULL if you\ndo not need this information.\n@result an index in the string where it is appropriate to insert a hyphen, if\none exists; else kCFNotFound"]
    pub fn CFStringGetHyphenationLocationBeforeIndex(
        string: CFStringRef,
        location: CFIndex,
        limitRange: CFRange,
        options: CFOptionFlags,
        locale: CFLocaleRef,
        character: *mut UTF32Char,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringIsHyphenationAvailableForLocale(locale: CFLocaleRef) -> Boolean;
}
extern "C" {
    #[doc = " Exploding and joining strings with a separator string"]
    pub fn CFStringCreateByCombiningStrings(
        alloc: CFAllocatorRef,
        theArray: CFArrayRef,
        separatorString: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateArrayBySeparatingStrings(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
        separatorString: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    #[doc = " Parsing non-localized numbers from strings"]
    pub fn CFStringGetIntValue(str_: CFStringRef) -> SInt32;
}
extern "C" {
    pub fn CFStringGetDoubleValue(str_: CFStringRef) -> f64;
}
extern "C" {
    #[doc = " MutableString functions"]
    pub fn CFStringAppend(theString: CFMutableStringRef, appendedString: CFStringRef);
}
extern "C" {
    pub fn CFStringAppendCharacters(
        theString: CFMutableStringRef,
        chars: *const UniChar,
        numChars: CFIndex,
    );
}
extern "C" {
    pub fn CFStringAppendPascalString(
        theString: CFMutableStringRef,
        pStr: ConstStr255Param,
        encoding: CFStringEncoding,
    );
}
extern "C" {
    pub fn CFStringAppendCString(
        theString: CFMutableStringRef,
        cStr: *const ::std::os::raw::c_char,
        encoding: CFStringEncoding,
    );
}
extern "C" {
    pub fn CFStringAppendFormat(
        theString: CFMutableStringRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        ...
    );
}
extern "C" {
    pub fn CFStringAppendFormatAndArguments(
        theString: CFMutableStringRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        arguments: va_list,
    );
}
extern "C" {
    pub fn CFStringInsert(
        str_: CFMutableStringRef,
        idx: CFIndex,
        insertedStr: CFStringRef,
    );
}
extern "C" {
    pub fn CFStringDelete(theString: CFMutableStringRef, range: CFRange);
}
extern "C" {
    pub fn CFStringReplace(
        theString: CFMutableStringRef,
        range: CFRange,
        replacement: CFStringRef,
    );
}
extern "C" {
    pub fn CFStringReplaceAll(theString: CFMutableStringRef, replacement: CFStringRef);
}
extern "C" {
    pub fn CFStringFindAndReplace(
        theString: CFMutableStringRef,
        stringToFind: CFStringRef,
        replacementString: CFStringRef,
        rangeToSearch: CFRange,
        compareOptions: CFStringCompareFlags,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringSetExternalCharactersNoCopy(
        theString: CFMutableStringRef,
        chars: *mut UniChar,
        length: CFIndex,
        capacity: CFIndex,
    );
}
extern "C" {
    pub fn CFStringPad(
        theString: CFMutableStringRef,
        padString: CFStringRef,
        length: CFIndex,
        indexIntoPad: CFIndex,
    );
}
extern "C" {
    pub fn CFStringTrim(theString: CFMutableStringRef, trimString: CFStringRef);
}
extern "C" {
    pub fn CFStringTrimWhitespace(theString: CFMutableStringRef);
}
extern "C" {
    pub fn CFStringLowercase(theString: CFMutableStringRef, locale: CFLocaleRef);
}
extern "C" {
    pub fn CFStringUppercase(theString: CFMutableStringRef, locale: CFLocaleRef);
}
extern "C" {
    pub fn CFStringCapitalize(theString: CFMutableStringRef, locale: CFLocaleRef);
}
#[doc = "@typedef CFStringNormalizationForm\nThis is the type of Unicode normalization forms as described in\nUnicode Technical Report #15. To normalize for use with file\nsystem calls, use CFStringGetFileSystemRepresentation()."]
pub type CFStringNormalizationForm = CFIndex;
pub const kCFStringNormalizationFormD: _bindgen_ty_17 = 0;
pub const kCFStringNormalizationFormKD: _bindgen_ty_17 = 1;
pub const kCFStringNormalizationFormC: _bindgen_ty_17 = 2;
pub const kCFStringNormalizationFormKC: _bindgen_ty_17 = 3;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "@function CFStringNormalize\nNormalizes the string into the specified form as described in\nUnicode Technical Report #15.\n@param theString  The string which is to be normalized.  If this\nparameter is not a valid mutable CFString, the behavior is\nundefined.\n@param theForm  The form into which the string is to be normalized.\nIf this parameter is not a valid CFStringNormalizationForm value,\nthe behavior is undefined."]
    pub fn CFStringNormalize(
        theString: CFMutableStringRef,
        theForm: CFStringNormalizationForm,
    );
}
extern "C" {
    #[doc = "@function CFStringFold\nFolds the string into the form specified by the flags.\nCharacter foldings are operations that convert any of a set of characters\nsharing similar semantics into a single representative from that set.\nThis function can be used to preprocess strings that are to be compared,\nsearched, or indexed.\nNote that folding does not include normalization, so it is necessary\nto use CFStringNormalize in addition to CFStringFold in order to obtain\nthe effect of kCFCompareNonliteral.\n@param theString  The string which is to be folded.  If this parameter is not\na valid mutable CFString, the behavior is undefined.\n@param theFlags  The equivalency flags which describes the character folding form.\nOnly those flags containing the word \"insensitive\" are recognized here; other flags are ignored.\nFolding with kCFCompareCaseInsensitive removes case distinctions in accordance with the mapping\nspecified by ftp://ftp.unicode.org/Public/UNIDATA/CaseFolding.txt.  Folding with\nkCFCompareDiacriticInsensitive removes distinctions of accents and other diacritics.  Folding\nwith kCFCompareWidthInsensitive removes character width distinctions by mapping characters in\nthe range U+FF00-U+FFEF to their ordinary equivalents.\n@param theLocale The locale tailoring the character folding behavior. If NULL,\nit's considered to be the system locale returned from CFLocaleGetSystem().\nIf non-NULL and not a valid CFLocale object, the behavior is undefined."]
    pub fn CFStringFold(
        theString: CFMutableStringRef,
        theFlags: CFStringCompareFlags,
        theLocale: CFLocaleRef,
    );
}
extern "C" {
    pub fn CFStringTransform(
        string: CFMutableStringRef,
        range: *mut CFRange,
        transform: CFStringRef,
        reverse: Boolean,
    ) -> Boolean;
}
extern "C" {
    pub static kCFStringTransformStripCombiningMarks: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformToLatin: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformFullwidthHalfwidth: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinKatakana: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinHiragana: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformHiraganaKatakana: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformMandarinLatin: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinHangul: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinArabic: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinHebrew: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinThai: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinCyrillic: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinGreek: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformToXMLHex: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformToUnicodeName: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformStripDiacritics: CFStringRef;
}
extern "C" {
    #[doc = " General encoding related functionality"]
    pub fn CFStringIsEncodingAvailable(encoding: CFStringEncoding) -> Boolean;
}
extern "C" {
    pub fn CFStringGetListOfAvailableEncodings() -> *const CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetNameOfEncoding(encoding: CFStringEncoding) -> CFStringRef;
}
extern "C" {
    pub fn CFStringConvertEncodingToNSStringEncoding(
        encoding: CFStringEncoding,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CFStringConvertNSStringEncodingToEncoding(
        encoding: ::std::os::raw::c_ulong,
    ) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringConvertEncodingToWindowsCodepage(encoding: CFStringEncoding)
        -> UInt32;
}
extern "C" {
    pub fn CFStringConvertWindowsCodepageToEncoding(codepage: UInt32)
        -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringConvertIANACharSetNameToEncoding(
        theString: CFStringRef,
    ) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringConvertEncodingToIANACharSetName(
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringGetMostCompatibleMacStringEncoding(
        encoding: CFStringEncoding,
    ) -> CFStringEncoding;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStringInlineBuffer {
    pub buffer: [UniChar; 64usize],
    pub theString: CFStringRef,
    pub directUniCharBuffer: *const UniChar,
    pub directCStringBuffer: *const ::std::os::raw::c_char,
    pub rangeToBuffer: CFRange,
    pub bufferedRangeStart: CFIndex,
    pub bufferedRangeEnd: CFIndex,
}
#[test]
fn bindgen_test_layout_CFStringInlineBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<CFStringInlineBuffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFStringInlineBuffer>(),
        184usize,
        concat!("Size of: ", stringify!(CFStringInlineBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<CFStringInlineBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStringInlineBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theString) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(theString)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).directUniCharBuffer) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(directUniCharBuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).directCStringBuffer) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(directCStringBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangeToBuffer) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(rangeToBuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bufferedRangeStart) as usize - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(bufferedRangeStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferedRangeEnd) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(bufferedRangeEnd)
        )
    );
}
extern "C" {
    pub fn CFShow(obj: CFTypeRef);
}
extern "C" {
    pub fn CFShowStr(str_: CFStringRef);
}
extern "C" {
    pub fn __CFStringMakeConstantString(
        cStr: *const ::std::os::raw::c_char,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFTimeZoneGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFTimeZoneCopySystem() -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneResetSystem();
}
extern "C" {
    pub fn CFTimeZoneCopyDefault() -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneSetDefault(tz: CFTimeZoneRef);
}
extern "C" {
    pub fn CFTimeZoneCopyKnownNames() -> CFArrayRef;
}
extern "C" {
    pub fn CFTimeZoneCopyAbbreviationDictionary() -> CFDictionaryRef;
}
extern "C" {
    pub fn CFTimeZoneSetAbbreviationDictionary(dict: CFDictionaryRef);
}
extern "C" {
    pub fn CFTimeZoneCreate(
        allocator: CFAllocatorRef,
        name: CFStringRef,
        data: CFDataRef,
    ) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneCreateWithTimeIntervalFromGMT(
        allocator: CFAllocatorRef,
        ti: CFTimeInterval,
    ) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneCreateWithName(
        allocator: CFAllocatorRef,
        name: CFStringRef,
        tryAbbrev: Boolean,
    ) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneGetName(tz: CFTimeZoneRef) -> CFStringRef;
}
extern "C" {
    pub fn CFTimeZoneGetData(tz: CFTimeZoneRef) -> CFDataRef;
}
extern "C" {
    pub fn CFTimeZoneGetSecondsFromGMT(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> CFTimeInterval;
}
extern "C" {
    pub fn CFTimeZoneCopyAbbreviation(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFTimeZoneIsDaylightSavingTime(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> Boolean;
}
extern "C" {
    pub fn CFTimeZoneGetDaylightSavingTimeOffset(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> CFTimeInterval;
}
extern "C" {
    pub fn CFTimeZoneGetNextDaylightSavingTimeTransition(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> CFAbsoluteTime;
}
pub type CFTimeZoneNameStyle = CFIndex;
pub const kCFTimeZoneNameStyleStandard: _bindgen_ty_18 = 0;
pub const kCFTimeZoneNameStyleShortStandard: _bindgen_ty_18 = 1;
pub const kCFTimeZoneNameStyleDaylightSaving: _bindgen_ty_18 = 2;
pub const kCFTimeZoneNameStyleShortDaylightSaving: _bindgen_ty_18 = 3;
pub const kCFTimeZoneNameStyleGeneric: _bindgen_ty_18 = 4;
pub const kCFTimeZoneNameStyleShortGeneric: _bindgen_ty_18 = 5;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFTimeZoneCopyLocalizedName(
        tz: CFTimeZoneRef,
        style: CFTimeZoneNameStyle,
        locale: CFLocaleRef,
    ) -> CFStringRef;
}
extern "C" {
    pub static kCFTimeZoneSystemTimeZoneDidChangeNotification: CFNotificationName;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFCalendar {
    _unused: [u8; 0],
}
pub type CFCalendarRef = *mut __CFCalendar;
extern "C" {
    pub fn CFCalendarGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFCalendarCopyCurrent() -> CFCalendarRef;
}
extern "C" {
    pub fn CFCalendarCreateWithIdentifier(
        allocator: CFAllocatorRef,
        identifier: CFCalendarIdentifier,
    ) -> CFCalendarRef;
}
extern "C" {
    pub fn CFCalendarGetIdentifier(calendar: CFCalendarRef) -> CFCalendarIdentifier;
}
extern "C" {
    pub fn CFCalendarCopyLocale(calendar: CFCalendarRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFCalendarSetLocale(calendar: CFCalendarRef, locale: CFLocaleRef);
}
extern "C" {
    pub fn CFCalendarCopyTimeZone(calendar: CFCalendarRef) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFCalendarSetTimeZone(calendar: CFCalendarRef, tz: CFTimeZoneRef);
}
extern "C" {
    pub fn CFCalendarGetFirstWeekday(calendar: CFCalendarRef) -> CFIndex;
}
extern "C" {
    pub fn CFCalendarSetFirstWeekday(calendar: CFCalendarRef, wkdy: CFIndex);
}
extern "C" {
    pub fn CFCalendarGetMinimumDaysInFirstWeek(calendar: CFCalendarRef) -> CFIndex;
}
extern "C" {
    pub fn CFCalendarSetMinimumDaysInFirstWeek(calendar: CFCalendarRef, mwd: CFIndex);
}
pub type CFCalendarUnit = CFOptionFlags;
pub const kCFCalendarUnitEra: _bindgen_ty_19 = 2;
pub const kCFCalendarUnitYear: _bindgen_ty_19 = 4;
pub const kCFCalendarUnitMonth: _bindgen_ty_19 = 8;
pub const kCFCalendarUnitDay: _bindgen_ty_19 = 16;
pub const kCFCalendarUnitHour: _bindgen_ty_19 = 32;
pub const kCFCalendarUnitMinute: _bindgen_ty_19 = 64;
pub const kCFCalendarUnitSecond: _bindgen_ty_19 = 128;
pub const kCFCalendarUnitWeek: _bindgen_ty_19 = 256;
pub const kCFCalendarUnitWeekday: _bindgen_ty_19 = 512;
pub const kCFCalendarUnitWeekdayOrdinal: _bindgen_ty_19 = 1024;
pub const kCFCalendarUnitQuarter: _bindgen_ty_19 = 2048;
pub const kCFCalendarUnitWeekOfMonth: _bindgen_ty_19 = 4096;
pub const kCFCalendarUnitWeekOfYear: _bindgen_ty_19 = 8192;
pub const kCFCalendarUnitYearForWeekOfYear: _bindgen_ty_19 = 16384;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFCalendarGetMinimumRangeOfUnit(
        calendar: CFCalendarRef,
        unit: CFCalendarUnit,
    ) -> CFRange;
}
extern "C" {
    pub fn CFCalendarGetMaximumRangeOfUnit(
        calendar: CFCalendarRef,
        unit: CFCalendarUnit,
    ) -> CFRange;
}
extern "C" {
    pub fn CFCalendarGetRangeOfUnit(
        calendar: CFCalendarRef,
        smallerUnit: CFCalendarUnit,
        biggerUnit: CFCalendarUnit,
        at: CFAbsoluteTime,
    ) -> CFRange;
}
extern "C" {
    pub fn CFCalendarGetOrdinalityOfUnit(
        calendar: CFCalendarRef,
        smallerUnit: CFCalendarUnit,
        biggerUnit: CFCalendarUnit,
        at: CFAbsoluteTime,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFCalendarGetTimeRangeOfUnit(
        calendar: CFCalendarRef,
        unit: CFCalendarUnit,
        at: CFAbsoluteTime,
        startp: *mut CFAbsoluteTime,
        tip: *mut CFTimeInterval,
    ) -> Boolean;
}
extern "C" {
    pub fn CFCalendarComposeAbsoluteTime(
        calendar: CFCalendarRef,
        at: *mut CFAbsoluteTime,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
extern "C" {
    pub fn CFCalendarDecomposeAbsoluteTime(
        calendar: CFCalendarRef,
        at: CFAbsoluteTime,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
pub const kCFCalendarComponentsWrap: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFCalendarAddComponents(
        calendar: CFCalendarRef,
        at: *mut CFAbsoluteTime,
        options: CFOptionFlags,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
extern "C" {
    pub fn CFCalendarGetComponentDifference(
        calendar: CFCalendarRef,
        startingAT: CFAbsoluteTime,
        resultAT: CFAbsoluteTime,
        options: CFOptionFlags,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
pub type CGFloat = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGPoint {
    pub x: CGFloat,
    pub y: CGFloat,
}
#[test]
fn bindgen_test_layout_CGPoint() {
    const UNINIT: ::std::mem::MaybeUninit<CGPoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGPoint>(),
        16usize,
        concat!("Size of: ", stringify!(CGPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<CGPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(CGPoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CGPoint),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGSize {
    pub width: CGFloat,
    pub height: CGFloat,
}
#[test]
fn bindgen_test_layout_CGSize() {
    const UNINIT: ::std::mem::MaybeUninit<CGSize> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGSize>(),
        16usize,
        concat!("Size of: ", stringify!(CGSize))
    );
    assert_eq!(
        ::std::mem::align_of::<CGSize>(),
        8usize,
        concat!("Alignment of ", stringify!(CGSize))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGSize),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CGSize),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGVector {
    pub dx: CGFloat,
    pub dy: CGFloat,
}
#[test]
fn bindgen_test_layout_CGVector() {
    const UNINIT: ::std::mem::MaybeUninit<CGVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGVector>(),
        16usize,
        concat!("Size of: ", stringify!(CGVector))
    );
    assert_eq!(
        ::std::mem::align_of::<CGVector>(),
        8usize,
        concat!("Alignment of ", stringify!(CGVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGVector),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CGVector),
            "::",
            stringify!(dy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGRect {
    pub origin: CGPoint,
    pub size: CGSize,
}
#[test]
fn bindgen_test_layout_CGRect() {
    const UNINIT: ::std::mem::MaybeUninit<CGRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGRect>(),
        32usize,
        concat!("Size of: ", stringify!(CGRect))
    );
    assert_eq!(
        ::std::mem::align_of::<CGRect>(),
        8usize,
        concat!("Alignment of ", stringify!(CGRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGRect),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CGRect),
            "::",
            stringify!(size)
        )
    );
}
pub type CGRectEdge = u32;
pub const CGRectMinXEdge: _bindgen_ty_21 = 0;
pub const CGRectMinYEdge: _bindgen_ty_21 = 1;
pub const CGRectMaxXEdge: _bindgen_ty_21 = 2;
pub const CGRectMaxYEdge: _bindgen_ty_21 = 3;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGAffineTransform {
    pub a: CGFloat,
    pub b: CGFloat,
    pub c: CGFloat,
    pub d: CGFloat,
    pub tx: CGFloat,
    pub ty: CGFloat,
}
#[test]
fn bindgen_test_layout_CGAffineTransform() {
    const UNINIT: ::std::mem::MaybeUninit<CGAffineTransform> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGAffineTransform>(),
        48usize,
        concat!("Size of: ", stringify!(CGAffineTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<CGAffineTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(CGAffineTransform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransform),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransform),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransform),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransform),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransform),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ty) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransform),
            "::",
            stringify!(ty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGAffineTransformComponents {
    pub scale: CGSize,
    pub horizontalShear: CGFloat,
    pub rotation: CGFloat,
    pub translation: CGVector,
}
#[test]
fn bindgen_test_layout_CGAffineTransformComponents() {
    const UNINIT: ::std::mem::MaybeUninit<CGAffineTransformComponents> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGAffineTransformComponents>(),
        48usize,
        concat!("Size of: ", stringify!(CGAffineTransformComponents))
    );
    assert_eq!(
        ::std::mem::align_of::<CGAffineTransformComponents>(),
        8usize,
        concat!("Alignment of ", stringify!(CGAffineTransformComponents))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransformComponents),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontalShear) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransformComponents),
            "::",
            stringify!(horizontalShear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransformComponents),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).translation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CGAffineTransformComponents),
            "::",
            stringify!(translation)
        )
    );
}
pub type CFDateFormatterKey = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFDateFormatter {
    _unused: [u8; 0],
}
pub type CFDateFormatterRef = *mut __CFDateFormatter;
extern "C" {
    pub fn CFDateFormatterCreateDateFormatFromTemplate(
        allocator: CFAllocatorRef,
        tmplate: CFStringRef,
        options: CFOptionFlags,
        locale: CFLocaleRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterGetTypeID() -> CFTypeID;
}
pub type CFDateFormatterStyle = CFIndex;
pub const kCFDateFormatterNoStyle: _bindgen_ty_22 = 0;
pub const kCFDateFormatterShortStyle: _bindgen_ty_22 = 1;
pub const kCFDateFormatterMediumStyle: _bindgen_ty_22 = 2;
pub const kCFDateFormatterLongStyle: _bindgen_ty_22 = 3;
pub const kCFDateFormatterFullStyle: _bindgen_ty_22 = 4;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub type CFISO8601DateFormatOptions = CFOptionFlags;
pub const kCFISO8601DateFormatWithYear: _bindgen_ty_23 = 1;
pub const kCFISO8601DateFormatWithMonth: _bindgen_ty_23 = 2;
pub const kCFISO8601DateFormatWithWeekOfYear: _bindgen_ty_23 = 4;
pub const kCFISO8601DateFormatWithDay: _bindgen_ty_23 = 16;
pub const kCFISO8601DateFormatWithTime: _bindgen_ty_23 = 32;
pub const kCFISO8601DateFormatWithTimeZone: _bindgen_ty_23 = 64;
pub const kCFISO8601DateFormatWithSpaceBetweenDateAndTime: _bindgen_ty_23 = 128;
pub const kCFISO8601DateFormatWithDashSeparatorInDate: _bindgen_ty_23 = 256;
pub const kCFISO8601DateFormatWithColonSeparatorInTime: _bindgen_ty_23 = 512;
pub const kCFISO8601DateFormatWithColonSeparatorInTimeZone: _bindgen_ty_23 = 1024;
pub const kCFISO8601DateFormatWithFractionalSeconds: _bindgen_ty_23 = 2048;
pub const kCFISO8601DateFormatWithFullDate: _bindgen_ty_23 = 275;
pub const kCFISO8601DateFormatWithFullTime: _bindgen_ty_23 = 1632;
pub const kCFISO8601DateFormatWithInternetDateTime: _bindgen_ty_23 = 1907;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFDateFormatterCreateISO8601Formatter(
        allocator: CFAllocatorRef,
        formatOptions: CFISO8601DateFormatOptions,
    ) -> CFDateFormatterRef;
}
extern "C" {
    pub fn CFDateFormatterCreate(
        allocator: CFAllocatorRef,
        locale: CFLocaleRef,
        dateStyle: CFDateFormatterStyle,
        timeStyle: CFDateFormatterStyle,
    ) -> CFDateFormatterRef;
}
extern "C" {
    pub fn CFDateFormatterGetLocale(formatter: CFDateFormatterRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFDateFormatterGetDateStyle(
        formatter: CFDateFormatterRef,
    ) -> CFDateFormatterStyle;
}
extern "C" {
    pub fn CFDateFormatterGetTimeStyle(
        formatter: CFDateFormatterRef,
    ) -> CFDateFormatterStyle;
}
extern "C" {
    pub fn CFDateFormatterGetFormat(formatter: CFDateFormatterRef) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterSetFormat(
        formatter: CFDateFormatterRef,
        formatString: CFStringRef,
    );
}
extern "C" {
    pub fn CFDateFormatterCreateStringWithDate(
        allocator: CFAllocatorRef,
        formatter: CFDateFormatterRef,
        date: CFDateRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterCreateStringWithAbsoluteTime(
        allocator: CFAllocatorRef,
        formatter: CFDateFormatterRef,
        at: CFAbsoluteTime,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterCreateDateFromString(
        allocator: CFAllocatorRef,
        formatter: CFDateFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
    ) -> CFDateRef;
}
extern "C" {
    pub fn CFDateFormatterGetAbsoluteTimeFromString(
        formatter: CFDateFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
        atp: *mut CFAbsoluteTime,
    ) -> Boolean;
}
extern "C" {
    pub fn CFDateFormatterSetProperty(
        formatter: CFDateFormatterRef,
        key: CFStringRef,
        value: CFTypeRef,
    );
}
extern "C" {
    pub fn CFDateFormatterCopyProperty(
        formatter: CFDateFormatterRef,
        key: CFDateFormatterKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub static kCFDateFormatterIsLenient: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterTimeZone: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterCalendarName: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterDefaultFormat: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterTwoDigitStartDate: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterDefaultDate: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterCalendar: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterEraSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterAMSymbol: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterPMSymbol: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterLongEraSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterStandaloneMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortStandaloneMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortStandaloneMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterStandaloneWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortStandaloneWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortStandaloneWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterStandaloneQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortStandaloneQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterGregorianStartDate: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterDoesRelativeDateFormattingKey: CFDateFormatterKey;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBoolean {
    _unused: [u8; 0],
}
pub type CFBooleanRef = *const __CFBoolean;
extern "C" {
    pub static kCFBooleanTrue: CFBooleanRef;
}
extern "C" {
    pub static kCFBooleanFalse: CFBooleanRef;
}
extern "C" {
    pub fn CFBooleanGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBooleanGetValue(boolean: CFBooleanRef) -> Boolean;
}
pub type CFNumberType = CFIndex;
pub const kCFNumberSInt8Type: _bindgen_ty_24 = 1;
pub const kCFNumberSInt16Type: _bindgen_ty_24 = 2;
pub const kCFNumberSInt32Type: _bindgen_ty_24 = 3;
pub const kCFNumberSInt64Type: _bindgen_ty_24 = 4;
pub const kCFNumberFloat32Type: _bindgen_ty_24 = 5;
pub const kCFNumberFloat64Type: _bindgen_ty_24 = 6;
pub const kCFNumberCharType: _bindgen_ty_24 = 7;
pub const kCFNumberShortType: _bindgen_ty_24 = 8;
pub const kCFNumberIntType: _bindgen_ty_24 = 9;
pub const kCFNumberLongType: _bindgen_ty_24 = 10;
pub const kCFNumberLongLongType: _bindgen_ty_24 = 11;
pub const kCFNumberFloatType: _bindgen_ty_24 = 12;
pub const kCFNumberDoubleType: _bindgen_ty_24 = 13;
pub const kCFNumberCFIndexType: _bindgen_ty_24 = 14;
pub const kCFNumberNSIntegerType: _bindgen_ty_24 = 15;
pub const kCFNumberCGFloatType: _bindgen_ty_24 = 16;
pub const kCFNumberMaxType: _bindgen_ty_24 = 16;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNumber {
    _unused: [u8; 0],
}
pub type CFNumberRef = *const __CFNumber;
extern "C" {
    pub static kCFNumberPositiveInfinity: CFNumberRef;
}
extern "C" {
    pub static kCFNumberNegativeInfinity: CFNumberRef;
}
extern "C" {
    pub static kCFNumberNaN: CFNumberRef;
}
extern "C" {
    pub fn CFNumberGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFNumberCreate(
        allocator: CFAllocatorRef,
        theType: CFNumberType,
        valuePtr: *const ::std::os::raw::c_void,
    ) -> CFNumberRef;
}
extern "C" {
    pub fn CFNumberGetType(number: CFNumberRef) -> CFNumberType;
}
extern "C" {
    pub fn CFNumberGetByteSize(number: CFNumberRef) -> CFIndex;
}
extern "C" {
    pub fn CFNumberIsFloatType(number: CFNumberRef) -> Boolean;
}
extern "C" {
    pub fn CFNumberGetValue(
        number: CFNumberRef,
        theType: CFNumberType,
        valuePtr: *mut ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFNumberCompare(
        number: CFNumberRef,
        otherNumber: CFNumberRef,
        context: *mut ::std::os::raw::c_void,
    ) -> CFComparisonResult;
}
pub type CFNumberFormatterKey = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNumberFormatter {
    _unused: [u8; 0],
}
pub type CFNumberFormatterRef = *mut __CFNumberFormatter;
extern "C" {
    pub fn CFNumberFormatterGetTypeID() -> CFTypeID;
}
pub type CFNumberFormatterStyle = CFIndex;
pub const kCFNumberFormatterNoStyle: _bindgen_ty_25 = 0;
pub const kCFNumberFormatterDecimalStyle: _bindgen_ty_25 = 1;
pub const kCFNumberFormatterCurrencyStyle: _bindgen_ty_25 = 2;
pub const kCFNumberFormatterPercentStyle: _bindgen_ty_25 = 3;
pub const kCFNumberFormatterScientificStyle: _bindgen_ty_25 = 4;
pub const kCFNumberFormatterSpellOutStyle: _bindgen_ty_25 = 5;
pub const kCFNumberFormatterOrdinalStyle: _bindgen_ty_25 = 6;
pub const kCFNumberFormatterCurrencyISOCodeStyle: _bindgen_ty_25 = 8;
pub const kCFNumberFormatterCurrencyPluralStyle: _bindgen_ty_25 = 9;
pub const kCFNumberFormatterCurrencyAccountingStyle: _bindgen_ty_25 = 10;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFNumberFormatterCreate(
        allocator: CFAllocatorRef,
        locale: CFLocaleRef,
        style: CFNumberFormatterStyle,
    ) -> CFNumberFormatterRef;
}
extern "C" {
    pub fn CFNumberFormatterGetLocale(formatter: CFNumberFormatterRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFNumberFormatterGetStyle(
        formatter: CFNumberFormatterRef,
    ) -> CFNumberFormatterStyle;
}
extern "C" {
    pub fn CFNumberFormatterGetFormat(formatter: CFNumberFormatterRef) -> CFStringRef;
}
extern "C" {
    pub fn CFNumberFormatterSetFormat(
        formatter: CFNumberFormatterRef,
        formatString: CFStringRef,
    );
}
extern "C" {
    pub fn CFNumberFormatterCreateStringWithNumber(
        allocator: CFAllocatorRef,
        formatter: CFNumberFormatterRef,
        number: CFNumberRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFNumberFormatterCreateStringWithValue(
        allocator: CFAllocatorRef,
        formatter: CFNumberFormatterRef,
        numberType: CFNumberType,
        valuePtr: *const ::std::os::raw::c_void,
    ) -> CFStringRef;
}
pub type CFNumberFormatterOptionFlags = CFOptionFlags;
pub const kCFNumberFormatterParseIntegersOnly: _bindgen_ty_26 = 1;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFNumberFormatterCreateNumberFromString(
        allocator: CFAllocatorRef,
        formatter: CFNumberFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
        options: CFOptionFlags,
    ) -> CFNumberRef;
}
extern "C" {
    pub fn CFNumberFormatterGetValueFromString(
        formatter: CFNumberFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
        numberType: CFNumberType,
        valuePtr: *mut ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFNumberFormatterSetProperty(
        formatter: CFNumberFormatterRef,
        key: CFNumberFormatterKey,
        value: CFTypeRef,
    );
}
extern "C" {
    pub fn CFNumberFormatterCopyProperty(
        formatter: CFNumberFormatterRef,
        key: CFNumberFormatterKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub static kCFNumberFormatterCurrencyCode: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterDecimalSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterCurrencyDecimalSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterAlwaysShowDecimalSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterGroupingSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterUseGroupingSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPercentSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterZeroSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterNaNSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterInfinitySymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinusSign: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPlusSign: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterCurrencySymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterExponentSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinIntegerDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMaxIntegerDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinFractionDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMaxFractionDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterGroupingSize: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterSecondaryGroupingSize: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterRoundingMode: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterRoundingIncrement: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterFormatWidth: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPaddingPosition: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPaddingCharacter: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterDefaultFormat: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMultiplier: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPositivePrefix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPositiveSuffix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterNegativePrefix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterNegativeSuffix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPerMillSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterInternationalCurrencySymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterCurrencyGroupingSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterIsLenient: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterUseSignificantDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinSignificantDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMaxSignificantDigits: CFNumberFormatterKey;
}
pub type CFNumberFormatterRoundingMode = CFIndex;
pub const kCFNumberFormatterRoundCeiling: _bindgen_ty_27 = 0;
pub const kCFNumberFormatterRoundFloor: _bindgen_ty_27 = 1;
pub const kCFNumberFormatterRoundDown: _bindgen_ty_27 = 2;
pub const kCFNumberFormatterRoundUp: _bindgen_ty_27 = 3;
pub const kCFNumberFormatterRoundHalfEven: _bindgen_ty_27 = 4;
pub const kCFNumberFormatterRoundHalfDown: _bindgen_ty_27 = 5;
pub const kCFNumberFormatterRoundHalfUp: _bindgen_ty_27 = 6;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub type CFNumberFormatterPadPosition = CFIndex;
pub const kCFNumberFormatterPadBeforePrefix: _bindgen_ty_28 = 0;
pub const kCFNumberFormatterPadAfterPrefix: _bindgen_ty_28 = 1;
pub const kCFNumberFormatterPadBeforeSuffix: _bindgen_ty_28 = 2;
pub const kCFNumberFormatterPadAfterSuffix: _bindgen_ty_28 = 3;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFNumberFormatterGetDecimalInfoForCurrencyCode(
        currencyCode: CFStringRef,
        defaultFractionDigits: *mut i32,
        roundingIncrement: *mut f64,
    ) -> Boolean;
}
extern "C" {
    pub static kCFPreferencesAnyApplication: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesCurrentApplication: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesAnyHost: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesCurrentHost: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesAnyUser: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesCurrentUser: CFStringRef;
}
extern "C" {
    pub fn CFPreferencesCopyAppValue(
        key: CFStringRef,
        applicationID: CFStringRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPreferencesGetAppBooleanValue(
        key: CFStringRef,
        applicationID: CFStringRef,
        keyExistsAndHasValidFormat: *mut Boolean,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPreferencesGetAppIntegerValue(
        key: CFStringRef,
        applicationID: CFStringRef,
        keyExistsAndHasValidFormat: *mut Boolean,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFPreferencesSetAppValue(
        key: CFStringRef,
        value: CFPropertyListRef,
        applicationID: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesAddSuitePreferencesToApp(
        applicationID: CFStringRef,
        suiteID: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesRemoveSuitePreferencesFromApp(
        applicationID: CFStringRef,
        suiteID: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesAppSynchronize(applicationID: CFStringRef) -> Boolean;
}
extern "C" {
    pub fn CFPreferencesCopyValue(
        key: CFStringRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPreferencesCopyMultiple(
        keysToFetch: CFArrayRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFPreferencesSetValue(
        key: CFStringRef,
        value: CFPropertyListRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesSetMultiple(
        keysToSet: CFDictionaryRef,
        keysToRemove: CFArrayRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesSynchronize(
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPreferencesCopyApplicationList(
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFPreferencesCopyKeyList(
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFPreferencesAppValueIsForced(
        key: CFStringRef,
        applicationID: CFStringRef,
    ) -> Boolean;
}
pub type CFURLPathStyle = CFIndex;
pub const kCFURLPOSIXPathStyle: _bindgen_ty_29 = 0;
pub const kCFURLHFSPathStyle: _bindgen_ty_29 = 1;
pub const kCFURLWindowsPathStyle: _bindgen_ty_29 = 2;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFURL {
    _unused: [u8; 0],
}
pub type CFURLRef = *const __CFURL;
extern "C" {
    pub fn CFURLGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFURLCreateWithBytes(
        allocator: CFAllocatorRef,
        URLBytes: *const UInt8,
        length: CFIndex,
        encoding: CFStringEncoding,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateData(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        encoding: CFStringEncoding,
        escapeWhitespace: Boolean,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLCreateWithString(
        allocator: CFAllocatorRef,
        URLString: CFStringRef,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateAbsoluteURLWithBytes(
        alloc: CFAllocatorRef,
        relativeURLBytes: *const UInt8,
        length: CFIndex,
        encoding: CFStringEncoding,
        baseURL: CFURLRef,
        useCompatibilityMode: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateWithFileSystemPath(
        allocator: CFAllocatorRef,
        filePath: CFStringRef,
        pathStyle: CFURLPathStyle,
        isDirectory: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateFromFileSystemRepresentation(
        allocator: CFAllocatorRef,
        buffer: *const UInt8,
        bufLen: CFIndex,
        isDirectory: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateWithFileSystemPathRelativeToBase(
        allocator: CFAllocatorRef,
        filePath: CFStringRef,
        pathStyle: CFURLPathStyle,
        isDirectory: Boolean,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateFromFileSystemRepresentationRelativeToBase(
        allocator: CFAllocatorRef,
        buffer: *const UInt8,
        bufLen: CFIndex,
        isDirectory: Boolean,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetFileSystemRepresentation(
        url: CFURLRef,
        resolveAgainstBase: Boolean,
        buffer: *mut UInt8,
        maxBufLen: CFIndex,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyAbsoluteURL(relativeURL: CFURLRef) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetString(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLGetBaseURL(anURL: CFURLRef) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCanBeDecomposed(anURL: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyScheme(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyNetLocation(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyPath(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyStrictPath(anURL: CFURLRef, isAbsolute: *mut Boolean) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyFileSystemPath(
        anURL: CFURLRef,
        pathStyle: CFURLPathStyle,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLHasDirectoryPath(anURL: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyResourceSpecifier(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyHostName(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLGetPortNumber(anURL: CFURLRef) -> SInt32;
}
extern "C" {
    pub fn CFURLCopyUserName(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyPassword(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyParameterString(
        anURL: CFURLRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyQueryString(
        anURL: CFURLRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyFragment(
        anURL: CFURLRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyLastPathComponent(url: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyPathExtension(url: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCreateCopyAppendingPathComponent(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        pathComponent: CFStringRef,
        isDirectory: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateCopyDeletingLastPathComponent(
        allocator: CFAllocatorRef,
        url: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateCopyAppendingPathExtension(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        extension: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateCopyDeletingPathExtension(
        allocator: CFAllocatorRef,
        url: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetBytes(
        url: CFURLRef,
        buffer: *mut UInt8,
        bufferLength: CFIndex,
    ) -> CFIndex;
}
pub type CFURLComponentType = CFIndex;
pub const kCFURLComponentScheme: _bindgen_ty_30 = 1;
pub const kCFURLComponentNetLocation: _bindgen_ty_30 = 2;
pub const kCFURLComponentPath: _bindgen_ty_30 = 3;
pub const kCFURLComponentResourceSpecifier: _bindgen_ty_30 = 4;
pub const kCFURLComponentUser: _bindgen_ty_30 = 5;
pub const kCFURLComponentPassword: _bindgen_ty_30 = 6;
pub const kCFURLComponentUserInfo: _bindgen_ty_30 = 7;
pub const kCFURLComponentHost: _bindgen_ty_30 = 8;
pub const kCFURLComponentPort: _bindgen_ty_30 = 9;
pub const kCFURLComponentParameterString: _bindgen_ty_30 = 10;
pub const kCFURLComponentQuery: _bindgen_ty_30 = 11;
pub const kCFURLComponentFragment: _bindgen_ty_30 = 12;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFURLGetByteRangeForComponent(
        url: CFURLRef,
        component: CFURLComponentType,
        rangeIncludingSeparators: *mut CFRange,
    ) -> CFRange;
}
extern "C" {
    pub fn CFURLCreateStringByReplacingPercentEscapes(
        allocator: CFAllocatorRef,
        originalString: CFStringRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCreateStringByReplacingPercentEscapesUsingEncoding(
        allocator: CFAllocatorRef,
        origString: CFStringRef,
        charsToLeaveEscaped: CFStringRef,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCreateStringByAddingPercentEscapes(
        allocator: CFAllocatorRef,
        originalString: CFStringRef,
        charactersToLeaveUnescaped: CFStringRef,
        legalURLCharactersToBeEscaped: CFStringRef,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLIsFileReferenceURL(url: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCreateFileReferenceURL(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateFilePathURL(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFURLRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSRef {
    _unused: [u8; 0],
}
extern "C" {
    pub fn CFURLCreateFromFSRef(
        allocator: CFAllocatorRef,
        fsRef: *const FSRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetFSRef(url: CFURLRef, fsRef: *mut FSRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyResourcePropertyForKey(
        url: CFURLRef,
        key: CFStringRef,
        propertyValueTypeRefPtr: *mut ::std::os::raw::c_void,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyResourcePropertiesForKeys(
        url: CFURLRef,
        keys: CFArrayRef,
        error: *mut CFErrorRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFURLSetResourcePropertyForKey(
        url: CFURLRef,
        key: CFStringRef,
        propertyValue: CFTypeRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLSetResourcePropertiesForKeys(
        url: CFURLRef,
        keyedPropertyValues: CFDictionaryRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub static kCFURLKeysOfUnsetValuesKey: CFStringRef;
}
extern "C" {
    pub fn CFURLClearResourcePropertyCacheForKey(url: CFURLRef, key: CFStringRef);
}
extern "C" {
    pub fn CFURLClearResourcePropertyCache(url: CFURLRef);
}
extern "C" {
    pub fn CFURLSetTemporaryResourcePropertyForKey(
        url: CFURLRef,
        key: CFStringRef,
        propertyValue: CFTypeRef,
    );
}
extern "C" {
    pub fn CFURLResourceIsReachable(url: CFURLRef, error: *mut CFErrorRef) -> Boolean;
}
extern "C" {
    pub static kCFURLNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLocalizedNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsRegularFileKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsDirectoryKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsSymbolicLinkKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsVolumeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsPackageKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsApplicationKey: CFStringRef;
}
extern "C" {
    pub static kCFURLApplicationIsScriptableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsSystemImmutableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsUserImmutableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsHiddenKey: CFStringRef;
}
extern "C" {
    pub static kCFURLHasHiddenExtensionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLCreationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLContentAccessDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLContentModificationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLAttributeModificationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileContentIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLMayShareFileContentKey: CFStringRef;
}
extern "C" {
    pub static kCFURLMayHaveExtendedAttributesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsPurgeableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsSparseKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLinkCountKey: CFStringRef;
}
extern "C" {
    pub static kCFURLParentDirectoryURLKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeURLKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTypeIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLocalizedTypeDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLabelNumberKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLabelColorKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLocalizedLabelKey: CFStringRef;
}
extern "C" {
    pub static kCFURLEffectiveIconKey: CFStringRef;
}
extern "C" {
    pub static kCFURLCustomIconKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLPreferredIOBlockSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsReadableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsWritableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsExecutableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileSecurityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsExcludedFromBackupKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTagNamesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLPathKey: CFStringRef;
}
extern "C" {
    pub static kCFURLCanonicalPathKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsMountTriggerKey: CFStringRef;
}
extern "C" {
    pub static kCFURLGenerationIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLDocumentIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLAddedToDirectoryDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLQuarantinePropertiesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeNamedPipe: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeCharacterSpecial: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeDirectory: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeBlockSpecial: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeRegular: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeSymbolicLink: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeSocket: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeUnknown: CFStringRef;
}
extern "C" {
    pub static kCFURLFileSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileAllocatedSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTotalFileSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTotalFileAllocatedSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsAliasFileKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionNone: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionComplete: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionCompleteUnlessOpen: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionCompleteUntilFirstUserAuthentication: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionCompleteWhenUserInactive: CFStringRef;
}
extern "C" {
    pub static kCFURLDirectoryEntryCountKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeLocalizedFormatDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeTotalCapacityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeAvailableCapacityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeAvailableCapacityForImportantUsageKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeAvailableCapacityForOpportunisticUsageKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeResourceCountKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsPersistentIDsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsSymbolicLinksKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsHardLinksKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsJournalingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsJournalingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsSparseFilesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsZeroRunsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsCaseSensitiveNamesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsCasePreservedNamesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsRootDirectoryDatesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsVolumeSizesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsRenamingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsAdvisoryFileLockingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsExtendedSecurityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsBrowsableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeMaximumFileSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsEjectableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsRemovableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsInternalKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsAutomountedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsLocalKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsReadOnlyKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeCreationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeURLForRemountingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeUUIDStringKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeLocalizedNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsEncryptedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsRootFileSystemKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsCompressionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsFileCloningKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsSwapRenamingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsExclusiveRenamingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsImmutableFilesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsAccessPermissionsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsFileProtectionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeTypeNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSubtypeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeMountFromLocationKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsUbiquitousItemKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemHasUnresolvedConflictsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsDownloadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsDownloadingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsUploadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsUploadingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemPercentDownloadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemPercentUploadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemUploadingErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsExcludedFromSyncKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusNotDownloaded: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusDownloaded: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusCurrent: CFStringRef;
}
pub type CFURLBookmarkCreationOptions = CFOptionFlags;
pub const kCFURLBookmarkCreationMinimalBookmarkMask: _bindgen_ty_31 = 512;
pub const kCFURLBookmarkCreationSuitableForBookmarkFile: _bindgen_ty_31 = 1024;
pub const kCFURLBookmarkCreationWithSecurityScope: _bindgen_ty_31 = 2048;
pub const kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess: _bindgen_ty_31 = 4096;
pub const kCFURLBookmarkCreationWithoutImplicitSecurityScope: _bindgen_ty_31 = 536870912;
pub const kCFURLBookmarkCreationPreferFileIDResolutionMask: _bindgen_ty_31 = 256;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub type CFURLBookmarkResolutionOptions = CFOptionFlags;
pub const kCFURLBookmarkResolutionWithoutUIMask: _bindgen_ty_32 = 256;
pub const kCFURLBookmarkResolutionWithoutMountingMask: _bindgen_ty_32 = 512;
pub const kCFURLBookmarkResolutionWithSecurityScope: _bindgen_ty_32 = 1024;
pub const kCFURLBookmarkResolutionWithoutImplicitStartAccessing: _bindgen_ty_32 = 32768;
pub const kCFBookmarkResolutionWithoutUIMask: _bindgen_ty_32 = 256;
pub const kCFBookmarkResolutionWithoutMountingMask: _bindgen_ty_32 = 512;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub type CFURLBookmarkFileCreationOptions = CFOptionFlags;
extern "C" {
    pub fn CFURLCreateBookmarkData(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        options: CFURLBookmarkCreationOptions,
        resourcePropertiesToInclude: CFArrayRef,
        relativeToURL: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLCreateByResolvingBookmarkData(
        allocator: CFAllocatorRef,
        bookmark: CFDataRef,
        options: CFURLBookmarkResolutionOptions,
        relativeToURL: CFURLRef,
        resourcePropertiesToInclude: CFArrayRef,
        isStale: *mut Boolean,
        error: *mut CFErrorRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateResourcePropertiesForKeysFromBookmarkData(
        allocator: CFAllocatorRef,
        resourcePropertiesToReturn: CFArrayRef,
        bookmark: CFDataRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFURLCreateResourcePropertyForKeyFromBookmarkData(
        allocator: CFAllocatorRef,
        resourcePropertyKey: CFStringRef,
        bookmark: CFDataRef,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFURLCreateBookmarkDataFromFile(
        allocator: CFAllocatorRef,
        fileURL: CFURLRef,
        errorRef: *mut CFErrorRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLWriteBookmarkDataToFile(
        bookmarkRef: CFDataRef,
        fileURL: CFURLRef,
        options: CFURLBookmarkFileCreationOptions,
        errorRef: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLCreateBookmarkDataFromAliasRecord(
        allocatorRef: CFAllocatorRef,
        aliasRecordDataRef: CFDataRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLStartAccessingSecurityScopedResource(url: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLStopAccessingSecurityScopedResource(url: CFURLRef);
}
pub type boolean_t = ::std::os::raw::c_int;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type vm32_offset_t = u32;
pub type vm32_address_t = u32;
pub type vm32_size_t = u32;
pub type mach_port_context_t = vm_offset_t;
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_status> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_status>(),
        40usize,
        concat!("Size of: ", stringify!(mach_port_status))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_status>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_pset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_pset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_seqno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_mscount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_mscount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_qlimit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_qlimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_msgcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_msgcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_sorights) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_sorights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_srights) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_srights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_pdrequest) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_pdrequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_nsrequest) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_nsrequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mps_flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_flags)
        )
    );
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_limits> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_limits>(),
        4usize,
        concat!("Size of: ", stringify!(mach_port_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_limits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpl_qlimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_limits),
            "::",
            stringify!(mpl_qlimit)
        )
    );
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_info_ext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_info_ext>(),
        68usize,
        concat!("Size of: ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_info_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpie_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(mpie_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpie_boost_cnt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(mpie_boost_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(reserved)
        )
    );
}
pub type mach_port_info_ext_t = mach_port_info_ext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_guard_info {
    pub mpgi_guard: u64,
}
#[test]
fn bindgen_test_layout_mach_port_guard_info() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_guard_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_guard_info>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_guard_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpgi_guard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_guard_info),
            "::",
            stringify!(mpgi_guard)
        )
    );
}
pub type mach_port_guard_info_t = mach_port_guard_info;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_qos {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_qos> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_qos>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_qos>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_qos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_qos),
            "::",
            stringify!(len)
        )
    );
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        name: ::std::os::raw::c_uint,
        prealloc: ::std::os::raw::c_uint,
        pad1: boolean_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name: u32 = unsafe { ::std::mem::transmute(name) };
            name as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prealloc: u32 = unsafe { ::std::mem::transmute(prealloc) };
            prealloc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_service_port_info {
    pub mspi_string_name: [::std::os::raw::c_char; 255usize],
    pub mspi_domain_type: u8,
}
#[test]
fn bindgen_test_layout_mach_service_port_info() {
    const UNINIT: ::std::mem::MaybeUninit<mach_service_port_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_service_port_info>(),
        256usize,
        concat!("Size of: ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_service_port_info>(),
        1usize,
        concat!("Alignment of ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mspi_string_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_service_port_info),
            "::",
            stringify!(mspi_string_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mspi_domain_type) as usize - ptr as usize },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_service_port_info),
            "::",
            stringify!(mspi_domain_type)
        )
    );
}
pub type mach_service_port_info_data_t = mach_service_port_info;
pub type mach_service_port_info_t = *mut mach_service_port_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub __bindgen_anon_1: mach_port_options__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_port_options__bindgen_ty_1 {
    pub reserved: [u64; 2usize],
    pub work_interval_port: mach_port_name_t,
    pub service_port_info: mach_service_port_info_t,
    pub service_port_name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_port_options__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_options__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_options__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).work_interval_port) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(work_interval_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_port_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(service_port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_port_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options__bindgen_ty_1),
            "::",
            stringify!(service_port_name)
        )
    );
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    const UNINIT: ::std::mem::MaybeUninit<mach_port_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_port_options>(),
        24usize,
        concat!("Size of: ", stringify!(mach_port_options))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(mpl)
        )
    );
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
pub const mach_port_guard_exception_codes_kGUARD_EXC_DESTROY:
    mach_port_guard_exception_codes = 1;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS:
    mach_port_guard_exception_codes = 2;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_OPTIONS:
    mach_port_guard_exception_codes = 3;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SET_CONTEXT:
    mach_port_guard_exception_codes = 4;
pub const mach_port_guard_exception_codes_kGUARD_EXC_THREAD_SET_STATE:
    mach_port_guard_exception_codes = 5;
pub const mach_port_guard_exception_codes_kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE:
    mach_port_guard_exception_codes = 6;
pub const mach_port_guard_exception_codes_kGUARD_EXC_UNGUARDED:
    mach_port_guard_exception_codes = 8;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INCORRECT_GUARD:
    mach_port_guard_exception_codes = 16;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE:
    mach_port_guard_exception_codes = 32;
pub const mach_port_guard_exception_codes_kGUARD_EXC_STRICT_REPLY:
    mach_port_guard_exception_codes = 64;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MSG_FILTERED:
    mach_port_guard_exception_codes = 128;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_RIGHT:
    mach_port_guard_exception_codes = 256;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_NAME:
    mach_port_guard_exception_codes = 512;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_VALUE:
    mach_port_guard_exception_codes = 1024;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_ARGUMENT:
    mach_port_guard_exception_codes = 2048;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RIGHT_EXISTS:
    mach_port_guard_exception_codes = 4096;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_NO_SPACE:
    mach_port_guard_exception_codes = 8192;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_FAILURE:
    mach_port_guard_exception_codes = 16384;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_RESOURCE:
    mach_port_guard_exception_codes = 32768;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_REPLY:
    mach_port_guard_exception_codes = 65536;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_VOUCHER:
    mach_port_guard_exception_codes = 131072;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_RIGHT:
    mach_port_guard_exception_codes = 262144;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_INVALID_NAME:
    mach_port_guard_exception_codes = 524288;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_GUARDED_DESC:
    mach_port_guard_exception_codes = 1048576;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS_NON_FATAL:
    mach_port_guard_exception_codes = 2097152;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE_NON_FATAL:
    mach_port_guard_exception_codes = 4194304;
pub const mach_port_guard_exception_codes_kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS:
    mach_port_guard_exception_codes = 8388608;
pub type mach_port_guard_exception_codes = ::std::os::raw::c_uint;
pub type CFRunLoopMode = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoop {
    _unused: [u8; 0],
}
pub type CFRunLoopRef = *mut __CFRunLoop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoopSource {
    _unused: [u8; 0],
}
pub type CFRunLoopSourceRef = *mut __CFRunLoopSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoopObserver {
    _unused: [u8; 0],
}
pub type CFRunLoopObserverRef = *mut __CFRunLoopObserver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoopTimer {
    _unused: [u8; 0],
}
pub type CFRunLoopTimerRef = *mut __CFRunLoopTimer;
pub type CFRunLoopRunResult = SInt32;
pub const kCFRunLoopRunFinished: _bindgen_ty_33 = 1;
pub const kCFRunLoopRunStopped: _bindgen_ty_33 = 2;
pub const kCFRunLoopRunTimedOut: _bindgen_ty_33 = 3;
pub const kCFRunLoopRunHandledSource: _bindgen_ty_33 = 4;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub type CFRunLoopActivity = CFOptionFlags;
pub const kCFRunLoopEntry: _bindgen_ty_34 = 1;
pub const kCFRunLoopBeforeTimers: _bindgen_ty_34 = 2;
pub const kCFRunLoopBeforeSources: _bindgen_ty_34 = 4;
pub const kCFRunLoopBeforeWaiting: _bindgen_ty_34 = 32;
pub const kCFRunLoopAfterWaiting: _bindgen_ty_34 = 64;
pub const kCFRunLoopExit: _bindgen_ty_34 = 128;
pub const kCFRunLoopAllActivities: _bindgen_ty_34 = 268435455;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
extern "C" {
    pub static kCFRunLoopDefaultMode: CFRunLoopMode;
}
extern "C" {
    pub static kCFRunLoopCommonModes: CFRunLoopMode;
}
extern "C" {
    pub fn CFRunLoopGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopGetCurrent() -> CFRunLoopRef;
}
extern "C" {
    pub fn CFRunLoopGetMain() -> CFRunLoopRef;
}
extern "C" {
    pub fn CFRunLoopCopyCurrentMode(rl: CFRunLoopRef) -> CFRunLoopMode;
}
extern "C" {
    pub fn CFRunLoopCopyAllModes(rl: CFRunLoopRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFRunLoopAddCommonMode(rl: CFRunLoopRef, mode: CFRunLoopMode);
}
extern "C" {
    pub fn CFRunLoopGetNextTimerFireDate(
        rl: CFRunLoopRef,
        mode: CFRunLoopMode,
    ) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFRunLoopRun();
}
extern "C" {
    pub fn CFRunLoopRunInMode(
        mode: CFRunLoopMode,
        seconds: CFTimeInterval,
        returnAfterSourceHandled: Boolean,
    ) -> CFRunLoopRunResult;
}
extern "C" {
    pub fn CFRunLoopIsWaiting(rl: CFRunLoopRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopWakeUp(rl: CFRunLoopRef);
}
extern "C" {
    pub fn CFRunLoopStop(rl: CFRunLoopRef);
}
extern "C" {
    pub fn CFRunLoopPerformBlock(
        rl: CFRunLoopRef,
        mode: CFTypeRef,
        block: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFRunLoopContainsSource(
        rl: CFRunLoopRef,
        source: CFRunLoopSourceRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopAddSource(
        rl: CFRunLoopRef,
        source: CFRunLoopSourceRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopRemoveSource(
        rl: CFRunLoopRef,
        source: CFRunLoopSourceRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopContainsObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopAddObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopRemoveObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopContainsTimer(
        rl: CFRunLoopRef,
        timer: CFRunLoopTimerRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopAddTimer(
        rl: CFRunLoopRef,
        timer: CFRunLoopTimerRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopRemoveTimer(
        rl: CFRunLoopRef,
        timer: CFRunLoopTimerRef,
        mode: CFRunLoopMode,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopSourceContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(
            info1: *const ::std::os::raw::c_void,
            info2: *const ::std::os::raw::c_void,
        ) -> Boolean,
    >,
    pub hash: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFHashCode,
    >,
    pub schedule: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut ::std::os::raw::c_void,
            rl: CFRunLoopRef,
            mode: CFRunLoopMode,
        ),
    >,
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut ::std::os::raw::c_void,
            rl: CFRunLoopRef,
            mode: CFRunLoopMode,
        ),
    >,
    pub perform:
        ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_CFRunLoopSourceContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFRunLoopSourceContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopSourceContext>(),
        80usize,
        concat!("Size of: ", stringify!(CFRunLoopSourceContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopSourceContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopSourceContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schedule) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(schedule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perform) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(perform)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopSourceContext1 {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(
            info1: *const ::std::os::raw::c_void,
            info2: *const ::std::os::raw::c_void,
        ) -> Boolean,
    >,
    pub hash: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFHashCode,
    >,
    pub getPort: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> mach_port_t,
    >,
    pub perform: ::std::option::Option<
        unsafe extern "C" fn(
            msg: *mut ::std::os::raw::c_void,
            size: CFIndex,
            allocator: CFAllocatorRef,
            info: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_CFRunLoopSourceContext1() {
    const UNINIT: ::std::mem::MaybeUninit<CFRunLoopSourceContext1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopSourceContext1>(),
        72usize,
        concat!("Size of: ", stringify!(CFRunLoopSourceContext1))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopSourceContext1>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopSourceContext1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getPort) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(getPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perform) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(perform)
        )
    );
}
extern "C" {
    pub fn CFRunLoopSourceGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopSourceCreate(
        allocator: CFAllocatorRef,
        order: CFIndex,
        context: *mut CFRunLoopSourceContext,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFRunLoopSourceGetOrder(source: CFRunLoopSourceRef) -> CFIndex;
}
extern "C" {
    pub fn CFRunLoopSourceInvalidate(source: CFRunLoopSourceRef);
}
extern "C" {
    pub fn CFRunLoopSourceIsValid(source: CFRunLoopSourceRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopSourceGetContext(
        source: CFRunLoopSourceRef,
        context: *mut CFRunLoopSourceContext,
    );
}
extern "C" {
    pub fn CFRunLoopSourceSignal(source: CFRunLoopSourceRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopObserverContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFRunLoopObserverContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFRunLoopObserverContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopObserverContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFRunLoopObserverContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopObserverContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopObserverContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
pub type CFRunLoopObserverCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        observer: CFRunLoopObserverRef,
        activity: CFRunLoopActivity,
        info: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn CFRunLoopObserverGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopObserverCreate(
        allocator: CFAllocatorRef,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        callout: CFRunLoopObserverCallBack,
        context: *mut CFRunLoopObserverContext,
    ) -> CFRunLoopObserverRef;
}
extern "C" {
    pub fn CFRunLoopObserverCreateWithHandler(
        allocator: CFAllocatorRef,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        block: *mut ::std::os::raw::c_void,
    ) -> CFRunLoopObserverRef;
}
extern "C" {
    pub fn CFRunLoopObserverGetActivities(
        observer: CFRunLoopObserverRef,
    ) -> CFOptionFlags;
}
extern "C" {
    pub fn CFRunLoopObserverDoesRepeat(observer: CFRunLoopObserverRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopObserverGetOrder(observer: CFRunLoopObserverRef) -> CFIndex;
}
extern "C" {
    pub fn CFRunLoopObserverInvalidate(observer: CFRunLoopObserverRef);
}
extern "C" {
    pub fn CFRunLoopObserverIsValid(observer: CFRunLoopObserverRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopObserverGetContext(
        observer: CFRunLoopObserverRef,
        context: *mut CFRunLoopObserverContext,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopTimerContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFRunLoopTimerContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFRunLoopTimerContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopTimerContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFRunLoopTimerContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopTimerContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopTimerContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
pub type CFRunLoopTimerCallBack = ::std::option::Option<
    unsafe extern "C" fn(timer: CFRunLoopTimerRef, info: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFRunLoopTimerGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopTimerCreate(
        allocator: CFAllocatorRef,
        fireDate: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        callout: CFRunLoopTimerCallBack,
        context: *mut CFRunLoopTimerContext,
    ) -> CFRunLoopTimerRef;
}
extern "C" {
    pub fn CFRunLoopTimerCreateWithHandler(
        allocator: CFAllocatorRef,
        fireDate: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        block: *mut ::std::os::raw::c_void,
    ) -> CFRunLoopTimerRef;
}
extern "C" {
    pub fn CFRunLoopTimerGetNextFireDate(timer: CFRunLoopTimerRef) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFRunLoopTimerSetNextFireDate(
        timer: CFRunLoopTimerRef,
        fireDate: CFAbsoluteTime,
    );
}
extern "C" {
    pub fn CFRunLoopTimerGetInterval(timer: CFRunLoopTimerRef) -> CFTimeInterval;
}
extern "C" {
    pub fn CFRunLoopTimerDoesRepeat(timer: CFRunLoopTimerRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopTimerGetOrder(timer: CFRunLoopTimerRef) -> CFIndex;
}
extern "C" {
    pub fn CFRunLoopTimerInvalidate(timer: CFRunLoopTimerRef);
}
extern "C" {
    pub fn CFRunLoopTimerIsValid(timer: CFRunLoopTimerRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopTimerGetContext(
        timer: CFRunLoopTimerRef,
        context: *mut CFRunLoopTimerContext,
    );
}
extern "C" {
    pub fn CFRunLoopTimerGetTolerance(timer: CFRunLoopTimerRef) -> CFTimeInterval;
}
extern "C" {
    pub fn CFRunLoopTimerSetTolerance(
        timer: CFRunLoopTimerRef,
        tolerance: CFTimeInterval,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFSocket {
    _unused: [u8; 0],
}
pub type CFSocketRef = *mut __CFSocket;
pub type CFSocketError = CFIndex;
pub const kCFSocketSuccess: _bindgen_ty_35 = 0;
pub const kCFSocketError: _bindgen_ty_35 = -1;
pub const kCFSocketTimeout: _bindgen_ty_35 = -2;
pub type _bindgen_ty_35 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSocketSignature {
    pub protocolFamily: SInt32,
    pub socketType: SInt32,
    pub protocol: SInt32,
    pub address: CFDataRef,
}
#[test]
fn bindgen_test_layout_CFSocketSignature() {
    const UNINIT: ::std::mem::MaybeUninit<CFSocketSignature> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFSocketSignature>(),
        24usize,
        concat!("Size of: ", stringify!(CFSocketSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSocketSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSocketSignature))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocolFamily) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(protocolFamily)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socketType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(socketType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(address)
        )
    );
}
pub type CFSocketCallBackType = CFOptionFlags;
pub const kCFSocketNoCallBack: _bindgen_ty_36 = 0;
pub const kCFSocketReadCallBack: _bindgen_ty_36 = 1;
pub const kCFSocketAcceptCallBack: _bindgen_ty_36 = 2;
pub const kCFSocketDataCallBack: _bindgen_ty_36 = 3;
pub const kCFSocketConnectCallBack: _bindgen_ty_36 = 4;
pub const kCFSocketWriteCallBack: _bindgen_ty_36 = 8;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
pub const kCFSocketAutomaticallyReenableReadCallBack: _bindgen_ty_37 = 1;
pub const kCFSocketAutomaticallyReenableAcceptCallBack: _bindgen_ty_37 = 2;
pub const kCFSocketAutomaticallyReenableDataCallBack: _bindgen_ty_37 = 3;
pub const kCFSocketAutomaticallyReenableWriteCallBack: _bindgen_ty_37 = 8;
pub const kCFSocketLeaveErrors: _bindgen_ty_37 = 64;
pub const kCFSocketCloseOnInvalidate: _bindgen_ty_37 = 128;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub type CFSocketCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        s: CFSocketRef,
        type_: CFSocketCallBackType,
        address: CFDataRef,
        data: *const ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSocketContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFSocketContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFSocketContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFSocketContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFSocketContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSocketContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSocketContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
pub type CFSocketNativeHandle = ::std::os::raw::c_int;
extern "C" {
    pub fn CFSocketGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFSocketCreate(
        allocator: CFAllocatorRef,
        protocolFamily: SInt32,
        socketType: SInt32,
        protocol: SInt32,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketCreateWithNative(
        allocator: CFAllocatorRef,
        sock: CFSocketNativeHandle,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketCreateWithSocketSignature(
        allocator: CFAllocatorRef,
        signature: *const CFSocketSignature,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketCreateConnectedToSocketSignature(
        allocator: CFAllocatorRef,
        signature: *const CFSocketSignature,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
        timeout: CFTimeInterval,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketSetAddress(s: CFSocketRef, address: CFDataRef) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketConnectToAddress(
        s: CFSocketRef,
        address: CFDataRef,
        timeout: CFTimeInterval,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketInvalidate(s: CFSocketRef);
}
extern "C" {
    pub fn CFSocketIsValid(s: CFSocketRef) -> Boolean;
}
extern "C" {
    pub fn CFSocketCopyAddress(s: CFSocketRef) -> CFDataRef;
}
extern "C" {
    pub fn CFSocketCopyPeerAddress(s: CFSocketRef) -> CFDataRef;
}
extern "C" {
    pub fn CFSocketGetContext(s: CFSocketRef, context: *mut CFSocketContext);
}
extern "C" {
    pub fn CFSocketGetNative(s: CFSocketRef) -> CFSocketNativeHandle;
}
extern "C" {
    pub fn CFSocketCreateRunLoopSource(
        allocator: CFAllocatorRef,
        s: CFSocketRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFSocketGetSocketFlags(s: CFSocketRef) -> CFOptionFlags;
}
extern "C" {
    pub fn CFSocketSetSocketFlags(s: CFSocketRef, flags: CFOptionFlags);
}
extern "C" {
    pub fn CFSocketDisableCallBacks(s: CFSocketRef, callBackTypes: CFOptionFlags);
}
extern "C" {
    pub fn CFSocketEnableCallBacks(s: CFSocketRef, callBackTypes: CFOptionFlags);
}
extern "C" {
    pub fn CFSocketSendData(
        s: CFSocketRef,
        address: CFDataRef,
        data: CFDataRef,
        timeout: CFTimeInterval,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketRegisterValue(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        value: CFPropertyListRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketCopyRegisteredValue(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        value: *mut CFPropertyListRef,
        nameServerAddress: *mut CFDataRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketRegisterSocketSignature(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        signature: *const CFSocketSignature,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketCopyRegisteredSocketSignature(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        signature: *mut CFSocketSignature,
        nameServerAddress: *mut CFDataRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketUnregister(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketSetDefaultNameRegistryPortNumber(port: UInt16);
}
extern "C" {
    pub fn CFSocketGetDefaultNameRegistryPortNumber() -> UInt16;
}
extern "C" {
    pub static kCFSocketCommandKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketNameKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketValueKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketResultKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketRegisterCommand: CFStringRef;
}
extern "C" {
    pub static kCFSocketRetrieveCommand: CFStringRef;
}
pub type os_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type os_block_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<accessx_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad_name_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_name_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad_pad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_pad)
        )
    );
}
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freadlink(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(
        arg1: ::std::os::raw::c_int,
        arg2: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        arg1: ::std::os::raw::c_int,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> isize;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(
        arg1: *const ::std::os::raw::c_char,
        arg2: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        arg1: ::std::os::raw::c_int,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(
        arg1: *mut uid_t,
        arg2: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(
        arg1: ::std::os::raw::c_int,
        arg2: *const gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_flock() {
    const UNINIT: ::std::mem::MaybeUninit<flock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        24usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[test]
fn bindgen_test_layout_flocktimeout() {
    const UNINIT: ::std::mem::MaybeUninit<flocktimeout> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flocktimeout>(),
        40usize,
        concat!("Size of: ", stringify!(flocktimeout))
    );
    assert_eq!(
        ::std::mem::align_of::<flocktimeout>(),
        8usize,
        concat!("Alignment of ", stringify!(flocktimeout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flocktimeout),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flocktimeout),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_radvisory() {
    const UNINIT: ::std::mem::MaybeUninit<radvisory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<radvisory>(),
        16usize,
        concat!("Size of: ", stringify!(radvisory))
    );
    assert_eq!(
        ::std::mem::align_of::<radvisory>(),
        8usize,
        concat!("Alignment of ", stringify!(radvisory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ra_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radvisory),
            "::",
            stringify!(ra_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ra_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radvisory),
            "::",
            stringify!(ra_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: usize,
    pub fs_fsignatures_size: usize,
    pub fs_cdhash: [::std::os::raw::c_char; 20usize],
    pub fs_hash_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fsignatures() {
    const UNINIT: ::std::mem::MaybeUninit<fsignatures> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fsignatures>(),
        56usize,
        concat!("Size of: ", stringify!(fsignatures))
    );
    assert_eq!(
        ::std::mem::align_of::<fsignatures>(),
        8usize,
        concat!("Alignment of ", stringify!(fsignatures))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_file_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_file_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_blob_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_blob_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_blob_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_blob_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).fs_fsignatures_size) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_fsignatures_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_cdhash) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_cdhash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_hash_type) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_hash_type)
        )
    );
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsupplement {
    pub fs_file_start: off_t,
    pub fs_blob_start: off_t,
    pub fs_blob_size: usize,
    pub fs_orig_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fsupplement() {
    const UNINIT: ::std::mem::MaybeUninit<fsupplement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fsupplement>(),
        32usize,
        concat!("Size of: ", stringify!(fsupplement))
    );
    assert_eq!(
        ::std::mem::align_of::<fsupplement>(),
        8usize,
        concat!("Alignment of ", stringify!(fsupplement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_file_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsupplement),
            "::",
            stringify!(fs_file_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_blob_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsupplement),
            "::",
            stringify!(fs_blob_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_blob_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsupplement),
            "::",
            stringify!(fs_blob_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_orig_fd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fsupplement),
            "::",
            stringify!(fs_orig_fd)
        )
    );
}
pub type fsupplement_t = fsupplement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: usize,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fchecklv() {
    const UNINIT: ::std::mem::MaybeUninit<fchecklv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fchecklv>(),
        24usize,
        concat!("Size of: ", stringify!(fchecklv))
    );
    assert_eq!(
        ::std::mem::align_of::<fchecklv>(),
        8usize,
        concat!("Alignment of ", stringify!(fchecklv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lv_file_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_file_start)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lv_error_message_size) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_error_message_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lv_error_message) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_error_message)
        )
    );
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fgetsigsinfo {
    pub fg_file_start: off_t,
    pub fg_info_request: ::std::os::raw::c_int,
    pub fg_sig_is_platform: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fgetsigsinfo() {
    const UNINIT: ::std::mem::MaybeUninit<fgetsigsinfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fgetsigsinfo>(),
        16usize,
        concat!("Size of: ", stringify!(fgetsigsinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<fgetsigsinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(fgetsigsinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fg_file_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fgetsigsinfo),
            "::",
            stringify!(fg_file_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fg_info_request) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fgetsigsinfo),
            "::",
            stringify!(fg_info_request)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).fg_sig_is_platform) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fgetsigsinfo),
            "::",
            stringify!(fg_sig_is_platform)
        )
    );
}
pub type fgetsigsinfo_t = fgetsigsinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
#[test]
fn bindgen_test_layout_fstore() {
    const UNINIT: ::std::mem::MaybeUninit<fstore> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fstore>(),
        32usize,
        concat!("Size of: ", stringify!(fstore))
    );
    assert_eq!(
        ::std::mem::align_of::<fstore>(),
        8usize,
        concat!("Alignment of ", stringify!(fstore))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fst_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fst_posmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_posmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fst_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fst_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fst_bytesalloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_bytesalloc)
        )
    );
}
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
#[test]
fn bindgen_test_layout_fpunchhole() {
    const UNINIT: ::std::mem::MaybeUninit<fpunchhole> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fpunchhole>(),
        24usize,
        concat!("Size of: ", stringify!(fpunchhole))
    );
    assert_eq!(
        ::std::mem::align_of::<fpunchhole>(),
        8usize,
        concat!("Alignment of ", stringify!(fpunchhole))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_length)
        )
    );
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
#[test]
fn bindgen_test_layout_ftrimactivefile() {
    const UNINIT: ::std::mem::MaybeUninit<ftrimactivefile> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ftrimactivefile>(),
        16usize,
        concat!("Size of: ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrimactivefile>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fta_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrimactivefile),
            "::",
            stringify!(fta_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fta_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrimactivefile),
            "::",
            stringify!(fta_length)
        )
    );
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspecread {
    pub fsr_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fsr_offset: off_t,
    pub fsr_length: off_t,
}
#[test]
fn bindgen_test_layout_fspecread() {
    const UNINIT: ::std::mem::MaybeUninit<fspecread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fspecread>(),
        24usize,
        concat!("Size of: ", stringify!(fspecread))
    );
    assert_eq!(
        ::std::mem::align_of::<fspecread>(),
        8usize,
        concat!("Alignment of ", stringify!(fspecread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsr_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fspecread),
            "::",
            stringify!(fsr_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fspecread),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsr_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fspecread),
            "::",
            stringify!(fsr_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsr_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fspecread),
            "::",
            stringify!(fsr_length)
        )
    );
}
pub type fspecread_t = fspecread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fattributiontag {
    pub ft_flags: ::std::os::raw::c_uint,
    pub ft_hash: ::std::os::raw::c_ulonglong,
    pub ft_attribution_name: [::std::os::raw::c_char; 255usize],
}
#[test]
fn bindgen_test_layout_fattributiontag() {
    const UNINIT: ::std::mem::MaybeUninit<fattributiontag> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fattributiontag>(),
        272usize,
        concat!("Size of: ", stringify!(fattributiontag))
    );
    assert_eq!(
        ::std::mem::align_of::<fattributiontag>(),
        8usize,
        concat!("Alignment of ", stringify!(fattributiontag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ft_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fattributiontag),
            "::",
            stringify!(ft_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ft_hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fattributiontag),
            "::",
            stringify!(ft_hash)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ft_attribution_name) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fattributiontag),
            "::",
            stringify!(ft_attribution_name)
        )
    );
}
pub type fattributiontag_t = fattributiontag;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
#[test]
fn bindgen_test_layout_log2phys() {
    const UNINIT: ::std::mem::MaybeUninit<log2phys> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<log2phys>(),
        20usize,
        concat!("Size of: ", stringify!(log2phys))
    );
    assert_eq!(
        ::std::mem::align_of::<log2phys>(),
        4usize,
        concat!("Alignment of ", stringify!(log2phys))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l2p_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(log2phys),
            "::",
            stringify!(l2p_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l2p_contigbytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(log2phys),
            "::",
            stringify!(l2p_contigbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l2p_devoffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(log2phys),
            "::",
            stringify!(l2p_devoffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open_dprotected_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat_dprotected_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat_authenticated_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flock(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_init() -> filesec_t;
}
extern "C" {
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
}
extern "C" {
    pub fn filesec_free(arg1: filesec_t);
}
extern "C" {
    pub fn filesec_get_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_query_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_set_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_unset_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_retain(object: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn os_release(object: *mut ::std::os::raw::c_void);
}
pub const os_clockid_t_OS_CLOCK_MACH_ABSOLUTE_TIME: os_clockid_t = 32;
pub type os_clockid_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_workgroup_attr_opaque_s {
    pub sig: u32,
    pub opaque: [::std::os::raw::c_char; 60usize],
}
#[test]
fn bindgen_test_layout_os_workgroup_attr_opaque_s() {
    const UNINIT: ::std::mem::MaybeUninit<os_workgroup_attr_opaque_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<os_workgroup_attr_opaque_s>(),
        64usize,
        concat!("Size of: ", stringify!(os_workgroup_attr_opaque_s))
    );
    assert_eq!(
        ::std::mem::align_of::<os_workgroup_attr_opaque_s>(),
        4usize,
        concat!("Alignment of ", stringify!(os_workgroup_attr_opaque_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(os_workgroup_attr_opaque_s),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(os_workgroup_attr_opaque_s),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_workgroup_interval_data_opaque_s {
    pub sig: u32,
    pub opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout_os_workgroup_interval_data_opaque_s() {
    const UNINIT: ::std::mem::MaybeUninit<os_workgroup_interval_data_opaque_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<os_workgroup_interval_data_opaque_s>(),
        60usize,
        concat!("Size of: ", stringify!(os_workgroup_interval_data_opaque_s))
    );
    assert_eq!(
        ::std::mem::align_of::<os_workgroup_interval_data_opaque_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(os_workgroup_interval_data_opaque_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(os_workgroup_interval_data_opaque_s),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(os_workgroup_interval_data_opaque_s),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_workgroup_join_token_opaque_s {
    pub sig: u32,
    pub opaque: [::std::os::raw::c_char; 36usize],
}
#[test]
fn bindgen_test_layout_os_workgroup_join_token_opaque_s() {
    const UNINIT: ::std::mem::MaybeUninit<os_workgroup_join_token_opaque_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<os_workgroup_join_token_opaque_s>(),
        40usize,
        concat!("Size of: ", stringify!(os_workgroup_join_token_opaque_s))
    );
    assert_eq!(
        ::std::mem::align_of::<os_workgroup_join_token_opaque_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(os_workgroup_join_token_opaque_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(os_workgroup_join_token_opaque_s),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(os_workgroup_join_token_opaque_s),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_workgroup_s {
    _unused: [u8; 0],
}
pub type os_workgroup_t = *mut os_workgroup_s;
pub type os_workgroup_attr_s = os_workgroup_attr_opaque_s;
pub type os_workgroup_attr_t = *mut os_workgroup_attr_opaque_s;
extern "C" {
    pub fn os_workgroup_copy_port(
        wg: os_workgroup_t,
        mach_port_out: *mut mach_port_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_workgroup_create_with_port(
        name: *const ::std::os::raw::c_char,
        mach_port: mach_port_t,
    ) -> os_workgroup_t;
}
extern "C" {
    pub fn os_workgroup_create_with_workgroup(
        name: *const ::std::os::raw::c_char,
        wg: os_workgroup_t,
    ) -> os_workgroup_t;
}
pub type os_workgroup_join_token_s = os_workgroup_join_token_opaque_s;
pub type os_workgroup_join_token_t = *mut os_workgroup_join_token_opaque_s;
extern "C" {
    pub fn os_workgroup_join(
        wg: os_workgroup_t,
        token_out: os_workgroup_join_token_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_workgroup_leave(wg: os_workgroup_t, token: os_workgroup_join_token_t);
}
pub type os_workgroup_index = u32;
pub type os_workgroup_working_arena_destructor_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn os_workgroup_set_working_arena(
        wg: os_workgroup_t,
        arena: *mut ::std::os::raw::c_void,
        max_workers: u32,
        destructor: os_workgroup_working_arena_destructor_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_workgroup_get_working_arena(
        wg: os_workgroup_t,
        index_out: *mut os_workgroup_index,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn os_workgroup_cancel(wg: os_workgroup_t);
}
extern "C" {
    pub fn os_workgroup_testcancel(wg: os_workgroup_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_workgroup_max_parallel_threads_attr_s {
    _unused: [u8; 0],
}
pub type os_workgroup_mpt_attr_s = os_workgroup_max_parallel_threads_attr_s;
pub type os_workgroup_mpt_attr_t = *mut os_workgroup_max_parallel_threads_attr_s;
extern "C" {
    pub fn os_workgroup_max_parallel_threads(
        wg: os_workgroup_t,
        attr: os_workgroup_mpt_attr_t,
    ) -> ::std::os::raw::c_int;
}
pub type os_workgroup_interval_t = os_workgroup_t;
pub type os_workgroup_interval_data_s = os_workgroup_interval_data_opaque_s;
pub type os_workgroup_interval_data_t = *mut os_workgroup_interval_data_opaque_s;
extern "C" {
    pub fn os_workgroup_interval_start(
        wg: os_workgroup_interval_t,
        start: u64,
        deadline: u64,
        data: os_workgroup_interval_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_workgroup_interval_update(
        wg: os_workgroup_interval_t,
        deadline: u64,
        data: os_workgroup_interval_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_workgroup_interval_finish(
        wg: os_workgroup_interval_t,
        data: os_workgroup_interval_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type os_workgroup_parallel_t = os_workgroup_t;
extern "C" {
    pub fn os_workgroup_parallel_create(
        name: *const ::std::os::raw::c_char,
        attr: os_workgroup_attr_t,
    ) -> os_workgroup_parallel_t;
}
pub type dispatch_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_value {
    pub seconds: integer_t,
    pub microseconds: integer_t,
}
#[test]
fn bindgen_test_layout_time_value() {
    const UNINIT: ::std::mem::MaybeUninit<time_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<time_value>(),
        8usize,
        concat!("Size of: ", stringify!(time_value))
    );
    assert_eq!(
        ::std::mem::align_of::<time_value>(),
        4usize,
        concat!("Alignment of ", stringify!(time_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(time_value),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).microseconds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(time_value),
            "::",
            stringify!(microseconds)
        )
    );
}
pub type time_value_t = time_value;
pub type alarm_type_t = ::std::os::raw::c_int;
pub type sleep_type_t = ::std::os::raw::c_int;
pub type clock_id_t = ::std::os::raw::c_int;
pub type clock_flavor_t = ::std::os::raw::c_int;
pub type clock_attr_t = *mut ::std::os::raw::c_int;
pub type clock_res_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_timespec {
    pub tv_sec: ::std::os::raw::c_uint,
    pub tv_nsec: clock_res_t,
}
#[test]
fn bindgen_test_layout_mach_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<mach_timespec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_timespec>(),
        8usize,
        concat!("Size of: ", stringify!(mach_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type mach_timespec_t = mach_timespec;
pub type dispatch_time_t = u64;
pub const DISPATCH_WALLTIME_NOW: _bindgen_ty_38 = 18446744073709551614;
pub type _bindgen_ty_38 = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_time(when: dispatch_time_t, delta: i64) -> dispatch_time_t;
}
extern "C" {
    pub fn dispatch_walltime(when: *const timespec, delta: i64) -> dispatch_time_t;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_39 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_39 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_39 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_39 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_39 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_39 = 0;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dispatch_object_t {
    pub _os_obj: *mut _os_object_s,
    pub _do: *mut dispatch_object_s,
    pub _dq: *mut dispatch_queue_s,
    pub _dqa: *mut dispatch_queue_attr_s,
    pub _dg: *mut dispatch_group_s,
    pub _ds: *mut dispatch_source_s,
    pub _dch: *mut dispatch_channel_s,
    pub _dm: *mut dispatch_mach_s,
    pub _dmsg: *mut dispatch_mach_msg_s,
    pub _dsema: *mut dispatch_semaphore_s,
    pub _ddata: *mut dispatch_data_s,
    pub _dchannel: *mut dispatch_io_s,
}
#[test]
fn bindgen_test_layout_dispatch_object_t() {
    const UNINIT: ::std::mem::MaybeUninit<dispatch_object_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dispatch_object_t>(),
        8usize,
        concat!("Size of: ", stringify!(dispatch_object_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dispatch_object_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dispatch_object_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._os_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_os_obj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._do) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_do)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dqa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dqa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dmsg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dmsg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dsema) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dsema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ddata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_ddata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dchannel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dchannel)
        )
    );
}
pub type dispatch_block_t = *mut ::std::os::raw::c_void;
pub type dispatch_qos_class_t = qos_class_t;
extern "C" {
    pub fn dispatch_retain(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_release(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_get_context(object: dispatch_object_t)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dispatch_set_context(
        object: dispatch_object_t,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dispatch_set_finalizer_f(
        object: dispatch_object_t,
        finalizer: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_activate(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_suspend(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_resume(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_set_qos_class_floor(
        object: dispatch_object_t,
        qos_class: dispatch_qos_class_t,
        relative_priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn dispatch_wait(
        object: *mut ::std::os::raw::c_void,
        timeout: dispatch_time_t,
    ) -> isize;
}
extern "C" {
    pub fn dispatch_notify(
        object: *mut ::std::os::raw::c_void,
        queue: dispatch_object_t,
        notification_block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_cancel(object: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dispatch_testcancel(object: *mut ::std::os::raw::c_void) -> isize;
}
extern "C" {
    pub fn dispatch_debug(
        object: dispatch_object_t,
        message: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn dispatch_debugv(
        object: dispatch_object_t,
        message: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
pub type dispatch_queue_t = *mut dispatch_queue_s;
pub type dispatch_queue_global_t = dispatch_queue_t;
pub type dispatch_queue_serial_executor_t = dispatch_queue_t;
pub type dispatch_queue_serial_t = dispatch_queue_t;
pub type dispatch_queue_main_t = dispatch_queue_serial_t;
pub type dispatch_queue_concurrent_t = dispatch_queue_t;
extern "C" {
    pub fn dispatch_async(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_async_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_sync(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_sync_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_async_and_wait(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_async_and_wait_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_apply(
        iterations: usize,
        queue: dispatch_queue_t,
        block: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dispatch_apply_f(
        iterations: usize,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, iteration: usize),
        >,
    );
}
extern "C" {
    pub fn dispatch_get_current_queue() -> dispatch_queue_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_queue_s {
    pub _address: u8,
}
extern "C" {
    pub static mut _dispatch_main_q: dispatch_queue_s;
}
pub type dispatch_queue_priority_t = ::std::os::raw::c_long;
extern "C" {
    pub fn dispatch_get_global_queue(
        identifier: isize,
        flags: usize,
    ) -> dispatch_queue_global_t;
}
pub type dispatch_queue_attr_t = *mut dispatch_queue_attr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_queue_attr_s {
    pub _address: u8,
}
extern "C" {
    pub static mut _dispatch_queue_attr_concurrent: dispatch_queue_attr_s;
}
extern "C" {
    pub fn dispatch_queue_attr_make_initially_inactive(
        attr: dispatch_queue_attr_t,
    ) -> dispatch_queue_attr_t;
}
pub const dispatch_autorelease_frequency_t_DISPATCH_AUTORELEASE_FREQUENCY_INHERIT:
    dispatch_autorelease_frequency_t = 0;
pub const dispatch_autorelease_frequency_t_DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:
    dispatch_autorelease_frequency_t = 1;
pub const dispatch_autorelease_frequency_t_DISPATCH_AUTORELEASE_FREQUENCY_NEVER:
    dispatch_autorelease_frequency_t = 2;
pub type dispatch_autorelease_frequency_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_queue_attr_make_with_autorelease_frequency(
        attr: dispatch_queue_attr_t,
        frequency: dispatch_autorelease_frequency_t,
    ) -> dispatch_queue_attr_t;
}
extern "C" {
    pub fn dispatch_queue_attr_make_with_qos_class(
        attr: dispatch_queue_attr_t,
        qos_class: dispatch_qos_class_t,
        relative_priority: ::std::os::raw::c_int,
    ) -> dispatch_queue_attr_t;
}
extern "C" {
    #[link_name = "\u{1}_dispatch_queue_create_with_target$V2"]
    pub fn dispatch_queue_create_with_target(
        label: *const ::std::os::raw::c_char,
        attr: dispatch_queue_attr_t,
        target: dispatch_queue_t,
    ) -> dispatch_queue_t;
}
extern "C" {
    pub fn dispatch_queue_create(
        label: *const ::std::os::raw::c_char,
        attr: dispatch_queue_attr_t,
    ) -> dispatch_queue_t;
}
extern "C" {
    pub fn dispatch_queue_get_label(
        queue: dispatch_queue_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn dispatch_queue_get_qos_class(
        queue: dispatch_queue_t,
        relative_priority_ptr: *mut ::std::os::raw::c_int,
    ) -> dispatch_qos_class_t;
}
extern "C" {
    pub fn dispatch_set_target_queue(object: dispatch_object_t, queue: dispatch_queue_t);
}
extern "C" {
    pub fn dispatch_main() -> !;
}
extern "C" {
    pub fn dispatch_after(
        when: dispatch_time_t,
        queue: dispatch_queue_t,
        block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_after_f(
        when: dispatch_time_t,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_barrier_async(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_barrier_async_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_barrier_sync(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_barrier_sync_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_barrier_async_and_wait(
        queue: dispatch_queue_t,
        block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_barrier_async_and_wait_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_queue_set_specific(
        queue: dispatch_queue_t,
        key: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        destructor: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_queue_get_specific(
        queue: dispatch_queue_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dispatch_get_specific(
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_dispatch_assert_queue$V2"]
    pub fn dispatch_assert_queue(queue: dispatch_queue_t);
}
extern "C" {
    pub fn dispatch_assert_queue_barrier(queue: dispatch_queue_t);
}
extern "C" {
    #[link_name = "\u{1}_dispatch_assert_queue_not$V2"]
    pub fn dispatch_assert_queue_not(queue: dispatch_queue_t);
}
extern "C" {
    pub fn dispatch_allow_send_signals(
        preserve_signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const dispatch_block_flags_t_DISPATCH_BLOCK_BARRIER: dispatch_block_flags_t = 1;
pub const dispatch_block_flags_t_DISPATCH_BLOCK_DETACHED: dispatch_block_flags_t = 2;
pub const dispatch_block_flags_t_DISPATCH_BLOCK_ASSIGN_CURRENT: dispatch_block_flags_t =
    4;
pub const dispatch_block_flags_t_DISPATCH_BLOCK_NO_QOS_CLASS: dispatch_block_flags_t = 8;
pub const dispatch_block_flags_t_DISPATCH_BLOCK_INHERIT_QOS_CLASS:
    dispatch_block_flags_t = 16;
pub const dispatch_block_flags_t_DISPATCH_BLOCK_ENFORCE_QOS_CLASS:
    dispatch_block_flags_t = 32;
pub type dispatch_block_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_block_create(
        flags: dispatch_block_flags_t,
        block: dispatch_block_t,
    ) -> dispatch_block_t;
}
extern "C" {
    pub fn dispatch_block_create_with_qos_class(
        flags: dispatch_block_flags_t,
        qos_class: dispatch_qos_class_t,
        relative_priority: ::std::os::raw::c_int,
        block: dispatch_block_t,
    ) -> dispatch_block_t;
}
extern "C" {
    pub fn dispatch_block_perform(flags: dispatch_block_flags_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_block_wait(
        block: dispatch_block_t,
        timeout: dispatch_time_t,
    ) -> isize;
}
extern "C" {
    pub fn dispatch_block_notify(
        block: dispatch_block_t,
        queue: dispatch_queue_t,
        notification_block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_block_cancel(block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_block_testcancel(block: dispatch_block_t) -> isize;
}
pub type kern_return_t = ::std::os::raw::c_int;
pub type mach_msg_timeout_t = natural_t;
pub type mach_msg_bits_t = ::std::os::raw::c_uint;
pub type mach_msg_size_t = natural_t;
pub type mach_msg_id_t = integer_t;
pub type mach_msg_priority_t = ::std::os::raw::c_uint;
pub type mach_msg_type_name_t = ::std::os::raw::c_uint;
pub type mach_msg_copy_options_t = ::std::os::raw::c_uint;
pub type mach_msg_guard_flags_t = ::std::os::raw::c_uint;
pub type mach_msg_descriptor_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_type_descriptor_t {
    pub pad1: natural_t,
    pub pad2: mach_msg_size_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_type_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_type_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_type_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_type_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_type_descriptor_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_type_descriptor_t),
            "::",
            stringify!(pad2)
        )
    );
}
impl mach_msg_type_descriptor_t {
    #[inline]
    pub fn pad3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pad3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad3: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pad3: u32 = unsafe { ::std::mem::transmute(pad3) };
            pad3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_port_descriptor_t {
    pub name: mach_port_t,
    pub pad1: mach_msg_size_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_port_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_port_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_port_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_port_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_port_descriptor_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_port_descriptor_t),
            "::",
            stringify!(pad1)
        )
    );
}
impl mach_msg_port_descriptor_t {
    #[inline]
    pub fn pad2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_pad2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad2: ::std::os::raw::c_uint,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let pad2: u32 = unsafe { ::std::mem::transmute(pad2) };
            pad2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor32_t {
    pub address: u32,
    pub size: mach_msg_size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor32_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_descriptor32_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor32_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor32_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor64_t {
    pub address: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor64_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_descriptor64_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor64_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor64_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor32_t {
    pub address: u32,
    pub count: mach_msg_size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor32_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_ports_descriptor32_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor32_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor32_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor32_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor64_t {
    pub address: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor64_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_ports_descriptor64_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor64_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor64_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor64_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_ool_ports_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor32_t {
    pub context: u32,
    pub name: mach_port_name_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor32_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_guarded_port_descriptor32_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor32_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(mach_msg_guarded_port_descriptor32_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor32_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor32_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor32_t),
            "::",
            stringify!(name)
        )
    );
}
impl mach_msg_guarded_port_descriptor32_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor64_t {
    pub context: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor64_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_guarded_port_descriptor64_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor64_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(mach_msg_guarded_port_descriptor64_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor64_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor64_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor64_t),
            "::",
            stringify!(name)
        )
    );
}
impl mach_msg_guarded_port_descriptor64_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor_t {
    pub context: mach_port_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_guarded_port_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_guarded_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_guarded_port_descriptor_t),
            "::",
            stringify!(name)
        )
    );
}
impl mach_msg_guarded_port_descriptor_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_descriptor_t {
    pub port: mach_msg_port_descriptor_t,
    pub out_of_line: mach_msg_ool_descriptor_t,
    pub ool_ports: mach_msg_ool_ports_descriptor_t,
    pub type_: mach_msg_type_descriptor_t,
    pub guarded_port: mach_msg_guarded_port_descriptor_t,
}
#[test]
fn bindgen_test_layout_mach_msg_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_of_line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(out_of_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ool_ports) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(ool_ports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guarded_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(guarded_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_body_t {
    pub msgh_descriptor_count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_body_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_body_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_body_t>(),
        4usize,
        concat!("Size of: ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_body_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).msgh_descriptor_count) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_body_t),
            "::",
            stringify!(msgh_descriptor_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_header_t {
    pub msgh_bits: mach_msg_bits_t,
    pub msgh_size: mach_msg_size_t,
    pub msgh_remote_port: mach_port_t,
    pub msgh_local_port: mach_port_t,
    pub msgh_voucher_port: mach_port_name_t,
    pub msgh_id: mach_msg_id_t,
}
#[test]
fn bindgen_test_layout_mach_msg_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_header_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_header_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_header_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_remote_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_local_port) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_voucher_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_voucher_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_base_t {
    pub header: mach_msg_header_t,
    pub body: mach_msg_body_t,
}
#[test]
fn bindgen_test_layout_mach_msg_base_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_base_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_base_t>(),
        28usize,
        concat!("Size of: ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_base_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_base_t),
            "::",
            stringify!(body)
        )
    );
}
pub type mach_msg_trailer_type_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_size_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_info_t = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_trailer_t>(),
        8usize,
        concat!("Size of: ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_seqno_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
}
#[test]
fn bindgen_test_layout_mach_msg_seqno_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_seqno_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_seqno_trailer_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_seqno_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct security_token_t {
    pub val: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_security_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<security_token_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<security_token_t>(),
        8usize,
        concat!("Size of: ", stringify!(security_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<security_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(security_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(security_token_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_security_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_security_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_security_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_security_trailer_t>(),
        20usize,
        concat!("Size of: ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_security_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_token_t {
    pub val: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_audit_token_t() {
    const UNINIT: ::std::mem::MaybeUninit<audit_token_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audit_token_t>(),
        32usize,
        concat!("Size of: ", stringify!(audit_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_token_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_token_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_audit_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_audit_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_audit_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_audit_trailer_t>(),
        52usize,
        concat!("Size of: ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_audit_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_context_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
}
#[test]
fn bindgen_test_layout_mach_msg_context_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_context_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_context_trailer_t>(),
        60usize,
        concat!("Size of: ", stringify!(mach_msg_context_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_context_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_context_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_context) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_context_trailer_t),
            "::",
            stringify!(msgh_context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_labels_t {
    pub sender: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_msg_labels_t() {
    const UNINIT: ::std::mem::MaybeUninit<msg_labels_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msg_labels_t>(),
        4usize,
        concat!("Size of: ", stringify!(msg_labels_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_labels_t>(),
        4usize,
        concat!("Alignment of ", stringify!(msg_labels_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_labels_t),
            "::",
            stringify!(sender)
        )
    );
}
pub type mach_msg_filter_id = ::std::os::raw::c_int;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_mac_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
    pub msgh_ad: mach_msg_filter_id,
    pub msgh_labels: msg_labels_t,
}
#[test]
fn bindgen_test_layout_mach_msg_mac_trailer_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_mac_trailer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_mac_trailer_t>(),
        68usize,
        concat!("Size of: ", stringify!(mach_msg_mac_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_mac_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_mac_trailer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_context) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_ad) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_ad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgh_labels) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_mac_trailer_t),
            "::",
            stringify!(msgh_labels)
        )
    );
}
pub type mach_msg_max_trailer_t = mach_msg_mac_trailer_t;
pub type mach_msg_format_0_trailer_t = mach_msg_security_trailer_t;
extern "C" {
    pub static KERNEL_SECURITY_TOKEN: security_token_t;
}
extern "C" {
    pub static KERNEL_AUDIT_TOKEN: audit_token_t;
}
pub type mach_msg_options_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_empty_send_t {
    pub header: mach_msg_header_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_send_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_empty_send_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_send_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_send_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_send_t),
            "::",
            stringify!(header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_empty_rcv_t {
    pub header: mach_msg_header_t,
    pub trailer: mach_msg_trailer_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_rcv_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_empty_rcv_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_rcv_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_rcv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_rcv_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_rcv_t),
            "::",
            stringify!(trailer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_empty_t {
    pub send: mach_msg_empty_send_t,
    pub rcv: mach_msg_empty_rcv_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_t() {
    const UNINIT: ::std::mem::MaybeUninit<mach_msg_empty_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_t),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_t),
            "::",
            stringify!(rcv)
        )
    );
}
pub type mach_msg_type_size_t = natural_t;
pub type mach_msg_type_number_t = natural_t;
pub type mach_msg_option_t = integer_t;
pub type mach_msg_return_t = kern_return_t;
extern "C" {
    pub fn mach_msg_overwrite(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
        rcv_msg: *mut mach_msg_header_t,
        rcv_limit: mach_msg_size_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_msg(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_voucher_deallocate(voucher: mach_port_name_t) -> kern_return_t;
}
pub type dispatch_source_t = *mut dispatch_source_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_source_type_s {
    _unused: [u8; 0],
}
pub type dispatch_source_type_t = *const dispatch_source_type_s;
extern "C" {
    pub static _dispatch_source_type_data_add: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_data_or: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_data_replace: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_mach_send: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_mach_recv: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_memorypressure: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_proc: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_read: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_signal: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_timer: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_vnode: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_write: dispatch_source_type_s;
}
pub type dispatch_source_mach_send_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_mach_recv_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_memorypressure_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_proc_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_vnode_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_timer_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_source_create(
        type_: dispatch_source_type_t,
        handle: usize,
        mask: usize,
        queue: dispatch_queue_t,
    ) -> dispatch_source_t;
}
extern "C" {
    pub fn dispatch_source_set_event_handler(
        source: dispatch_source_t,
        handler: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_source_set_event_handler_f(
        source: dispatch_source_t,
        handler: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_source_set_cancel_handler(
        source: dispatch_source_t,
        handler: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_source_set_cancel_handler_f(
        source: dispatch_source_t,
        handler: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_source_cancel(source: dispatch_source_t);
}
extern "C" {
    pub fn dispatch_source_testcancel(source: dispatch_source_t) -> isize;
}
extern "C" {
    pub fn dispatch_source_get_handle(source: dispatch_source_t) -> usize;
}
extern "C" {
    pub fn dispatch_source_get_mask(source: dispatch_source_t) -> usize;
}
extern "C" {
    pub fn dispatch_source_get_data(source: dispatch_source_t) -> usize;
}
extern "C" {
    pub fn dispatch_source_merge_data(source: dispatch_source_t, value: usize);
}
extern "C" {
    pub fn dispatch_source_set_timer(
        source: dispatch_source_t,
        start: dispatch_time_t,
        interval: u64,
        leeway: u64,
    );
}
extern "C" {
    pub fn dispatch_source_set_registration_handler(
        source: dispatch_source_t,
        handler: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_source_set_registration_handler_f(
        source: dispatch_source_t,
        handler: dispatch_function_t,
    );
}
pub type dispatch_group_t = *mut dispatch_group_s;
extern "C" {
    pub fn dispatch_group_create() -> dispatch_group_t;
}
extern "C" {
    pub fn dispatch_group_async(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_group_async_f(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_group_wait(
        group: dispatch_group_t,
        timeout: dispatch_time_t,
    ) -> isize;
}
extern "C" {
    pub fn dispatch_group_notify(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_group_notify_f(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_group_enter(group: dispatch_group_t);
}
extern "C" {
    pub fn dispatch_group_leave(group: dispatch_group_t);
}
pub type dispatch_semaphore_t = *mut dispatch_semaphore_s;
extern "C" {
    pub fn dispatch_semaphore_create(value: isize) -> dispatch_semaphore_t;
}
extern "C" {
    pub fn dispatch_semaphore_wait(
        dsema: dispatch_semaphore_t,
        timeout: dispatch_time_t,
    ) -> isize;
}
extern "C" {
    pub fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) -> isize;
}
pub type dispatch_once_t = isize;
extern "C" {
    pub fn dispatch_once(predicate: *mut dispatch_once_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_once_f(
        predicate: *mut dispatch_once_t,
        context: *mut ::std::os::raw::c_void,
        function: dispatch_function_t,
    );
}
pub type dispatch_data_t = *mut dispatch_data_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_data_s {
    pub _address: u8,
}
extern "C" {
    pub static mut _dispatch_data_empty: dispatch_data_s;
}
extern "C" {
    pub static _dispatch_data_destructor_free: dispatch_block_t;
}
extern "C" {
    pub static _dispatch_data_destructor_munmap: dispatch_block_t;
}
extern "C" {
    pub fn dispatch_data_create(
        buffer: *const ::std::os::raw::c_void,
        size: usize,
        queue: dispatch_queue_t,
        destructor: dispatch_block_t,
    ) -> dispatch_data_t;
}
extern "C" {
    pub fn dispatch_data_get_size(data: dispatch_data_t) -> usize;
}
extern "C" {
    pub fn dispatch_data_create_map(
        data: dispatch_data_t,
        buffer_ptr: *mut *const ::std::os::raw::c_void,
        size_ptr: *mut usize,
    ) -> dispatch_data_t;
}
extern "C" {
    pub fn dispatch_data_create_concat(
        data1: dispatch_data_t,
        data2: dispatch_data_t,
    ) -> dispatch_data_t;
}
extern "C" {
    pub fn dispatch_data_create_subrange(
        data: dispatch_data_t,
        offset: usize,
        length: usize,
    ) -> dispatch_data_t;
}
pub type dispatch_data_applier_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn dispatch_data_apply(
        data: dispatch_data_t,
        applier: dispatch_data_applier_t,
    ) -> bool;
}
extern "C" {
    pub fn dispatch_data_copy_region(
        data: dispatch_data_t,
        location: usize,
        offset_ptr: *mut usize,
    ) -> dispatch_data_t;
}
pub type dispatch_fd_t = ::std::os::raw::c_int;
extern "C" {
    pub fn dispatch_read(
        fd: dispatch_fd_t,
        length: usize,
        queue: dispatch_queue_t,
        handler: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dispatch_write(
        fd: dispatch_fd_t,
        data: dispatch_data_t,
        queue: dispatch_queue_t,
        handler: *mut ::std::os::raw::c_void,
    );
}
pub type dispatch_io_t = *mut dispatch_io_s;
pub type dispatch_io_type_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_io_create(
        type_: dispatch_io_type_t,
        fd: dispatch_fd_t,
        queue: dispatch_queue_t,
        cleanup_handler: *mut ::std::os::raw::c_void,
    ) -> dispatch_io_t;
}
extern "C" {
    pub fn dispatch_io_create_with_path(
        type_: dispatch_io_type_t,
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        mode: mode_t,
        queue: dispatch_queue_t,
        cleanup_handler: *mut ::std::os::raw::c_void,
    ) -> dispatch_io_t;
}
extern "C" {
    pub fn dispatch_io_create_with_io(
        type_: dispatch_io_type_t,
        io: dispatch_io_t,
        queue: dispatch_queue_t,
        cleanup_handler: *mut ::std::os::raw::c_void,
    ) -> dispatch_io_t;
}
pub type dispatch_io_handler_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn dispatch_io_read(
        channel: dispatch_io_t,
        offset: off_t,
        length: usize,
        queue: dispatch_queue_t,
        io_handler: dispatch_io_handler_t,
    );
}
extern "C" {
    pub fn dispatch_io_write(
        channel: dispatch_io_t,
        offset: off_t,
        data: dispatch_data_t,
        queue: dispatch_queue_t,
        io_handler: dispatch_io_handler_t,
    );
}
pub type dispatch_io_close_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_io_close(channel: dispatch_io_t, flags: dispatch_io_close_flags_t);
}
extern "C" {
    pub fn dispatch_io_barrier(channel: dispatch_io_t, barrier: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_io_get_descriptor(channel: dispatch_io_t) -> dispatch_fd_t;
}
extern "C" {
    pub fn dispatch_io_set_high_water(channel: dispatch_io_t, high_water: usize);
}
extern "C" {
    pub fn dispatch_io_set_low_water(channel: dispatch_io_t, low_water: usize);
}
pub type dispatch_io_interval_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_io_set_interval(
        channel: dispatch_io_t,
        interval: u64,
        flags: dispatch_io_interval_flags_t,
    );
}
pub type dispatch_workloop_t = dispatch_queue_t;
extern "C" {
    pub fn dispatch_workloop_create(
        label: *const ::std::os::raw::c_char,
    ) -> dispatch_workloop_t;
}
extern "C" {
    pub fn dispatch_workloop_create_inactive(
        label: *const ::std::os::raw::c_char,
    ) -> dispatch_workloop_t;
}
extern "C" {
    pub fn dispatch_workloop_set_autorelease_frequency(
        workloop: dispatch_workloop_t,
        frequency: dispatch_autorelease_frequency_t,
    );
}
extern "C" {
    pub fn dispatch_workloop_set_os_workgroup(
        workloop: dispatch_workloop_t,
        workgroup: os_workgroup_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStreamError {
    pub domain: CFIndex,
    pub error: SInt32,
}
#[test]
fn bindgen_test_layout_CFStreamError() {
    const UNINIT: ::std::mem::MaybeUninit<CFStreamError> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFStreamError>(),
        16usize,
        concat!("Size of: ", stringify!(CFStreamError))
    );
    assert_eq!(
        ::std::mem::align_of::<CFStreamError>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStreamError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamError),
            "::",
            stringify!(error)
        )
    );
}
pub type CFStreamPropertyKey = CFStringRef;
pub type CFStreamStatus = CFIndex;
pub const kCFStreamStatusNotOpen: _bindgen_ty_40 = 0;
pub const kCFStreamStatusOpening: _bindgen_ty_40 = 1;
pub const kCFStreamStatusOpen: _bindgen_ty_40 = 2;
pub const kCFStreamStatusReading: _bindgen_ty_40 = 3;
pub const kCFStreamStatusWriting: _bindgen_ty_40 = 4;
pub const kCFStreamStatusAtEnd: _bindgen_ty_40 = 5;
pub const kCFStreamStatusClosed: _bindgen_ty_40 = 6;
pub const kCFStreamStatusError: _bindgen_ty_40 = 7;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub type CFStreamEventType = CFOptionFlags;
pub const kCFStreamEventNone: _bindgen_ty_41 = 0;
pub const kCFStreamEventOpenCompleted: _bindgen_ty_41 = 1;
pub const kCFStreamEventHasBytesAvailable: _bindgen_ty_41 = 2;
pub const kCFStreamEventCanAcceptBytes: _bindgen_ty_41 = 4;
pub const kCFStreamEventErrorOccurred: _bindgen_ty_41 = 8;
pub const kCFStreamEventEndEncountered: _bindgen_ty_41 = 16;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStreamClientContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFStreamClientContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFStreamClientContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFStreamClientContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFStreamClientContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFStreamClientContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStreamClientContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFReadStream {
    _unused: [u8; 0],
}
pub type CFReadStreamRef = *mut __CFReadStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFWriteStream {
    _unused: [u8; 0],
}
pub type CFWriteStreamRef = *mut __CFWriteStream;
pub type CFReadStreamClientCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        stream: CFReadStreamRef,
        type_: CFStreamEventType,
        clientCallBackInfo: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFWriteStreamClientCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        stream: CFWriteStreamRef,
        type_: CFStreamEventType,
        clientCallBackInfo: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn CFReadStreamGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFWriteStreamGetTypeID() -> CFTypeID;
}
extern "C" {
    pub static mut kCFStreamPropertyDataWritten: CFStreamPropertyKey;
}
extern "C" {
    pub fn CFReadStreamCreateWithBytesNoCopy(
        alloc: CFAllocatorRef,
        bytes: *const UInt8,
        length: CFIndex,
        bytesDeallocator: CFAllocatorRef,
    ) -> CFReadStreamRef;
}
extern "C" {
    pub fn CFWriteStreamCreateWithBuffer(
        alloc: CFAllocatorRef,
        buffer: *mut UInt8,
        bufferCapacity: CFIndex,
    ) -> CFWriteStreamRef;
}
extern "C" {
    pub fn CFWriteStreamCreateWithAllocatedBuffers(
        alloc: CFAllocatorRef,
        bufferAllocator: CFAllocatorRef,
    ) -> CFWriteStreamRef;
}
extern "C" {
    pub fn CFReadStreamCreateWithFile(
        alloc: CFAllocatorRef,
        fileURL: CFURLRef,
    ) -> CFReadStreamRef;
}
extern "C" {
    pub fn CFWriteStreamCreateWithFile(
        alloc: CFAllocatorRef,
        fileURL: CFURLRef,
    ) -> CFWriteStreamRef;
}
extern "C" {
    pub fn CFStreamCreateBoundPair(
        alloc: CFAllocatorRef,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
        transferBufferSize: CFIndex,
    );
}
extern "C" {
    pub static mut kCFStreamPropertyAppendToFile: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertyFileCurrentOffset: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertySocketNativeHandle: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertySocketRemoteHostName: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertySocketRemotePortNumber: CFStreamPropertyKey;
}
extern "C" {
    pub static kCFStreamErrorDomainSOCKS: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSProxy: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSProxyHost: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSProxyPort: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSVersion: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSOCKSVersion4: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSOCKSVersion5: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSUser: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSPassword: CFStringRef;
}
extern "C" {
    pub static kCFStreamErrorDomainSSL: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut kCFStreamPropertySocketSecurityLevel: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelNone: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelSSLv2: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelSSLv3: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelTLSv1: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelNegotiatedSSL: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertyShouldCloseNativeSocket: CFStringRef;
}
extern "C" {
    pub fn CFStreamCreatePairWithSocket(
        alloc: CFAllocatorRef,
        sock: CFSocketNativeHandle,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
}
extern "C" {
    pub fn CFStreamCreatePairWithSocketToHost(
        alloc: CFAllocatorRef,
        host: CFStringRef,
        port: UInt32,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
}
extern "C" {
    pub fn CFStreamCreatePairWithPeerSocketSignature(
        alloc: CFAllocatorRef,
        signature: *const CFSocketSignature,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
}
extern "C" {
    pub fn CFReadStreamGetStatus(stream: CFReadStreamRef) -> CFStreamStatus;
}
extern "C" {
    pub fn CFWriteStreamGetStatus(stream: CFWriteStreamRef) -> CFStreamStatus;
}
extern "C" {
    pub fn CFReadStreamCopyError(stream: CFReadStreamRef) -> CFErrorRef;
}
extern "C" {
    pub fn CFWriteStreamCopyError(stream: CFWriteStreamRef) -> CFErrorRef;
}
extern "C" {
    pub fn CFReadStreamOpen(stream: CFReadStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamOpen(stream: CFWriteStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamClose(stream: CFReadStreamRef);
}
extern "C" {
    pub fn CFWriteStreamClose(stream: CFWriteStreamRef);
}
extern "C" {
    pub fn CFReadStreamHasBytesAvailable(stream: CFReadStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamRead(
        stream: CFReadStreamRef,
        buffer: *mut UInt8,
        bufferLength: CFIndex,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFReadStreamGetBuffer(
        stream: CFReadStreamRef,
        maxBytesToRead: CFIndex,
        numBytesRead: *mut CFIndex,
    ) -> *const UInt8;
}
extern "C" {
    pub fn CFWriteStreamCanAcceptBytes(stream: CFWriteStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamWrite(
        stream: CFWriteStreamRef,
        buffer: *const UInt8,
        bufferLength: CFIndex,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFReadStreamCopyProperty(
        stream: CFReadStreamRef,
        propertyName: CFStreamPropertyKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFWriteStreamCopyProperty(
        stream: CFWriteStreamRef,
        propertyName: CFStreamPropertyKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFReadStreamSetProperty(
        stream: CFReadStreamRef,
        propertyName: CFStreamPropertyKey,
        propertyValue: CFTypeRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamSetProperty(
        stream: CFWriteStreamRef,
        propertyName: CFStreamPropertyKey,
        propertyValue: CFTypeRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamSetClient(
        stream: CFReadStreamRef,
        streamEvents: CFOptionFlags,
        clientCB: CFReadStreamClientCallBack,
        clientContext: *mut CFStreamClientContext,
    ) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamSetClient(
        stream: CFWriteStreamRef,
        streamEvents: CFOptionFlags,
        clientCB: CFWriteStreamClientCallBack,
        clientContext: *mut CFStreamClientContext,
    ) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamScheduleWithRunLoop(
        stream: CFReadStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFWriteStreamScheduleWithRunLoop(
        stream: CFWriteStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFReadStreamUnscheduleFromRunLoop(
        stream: CFReadStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFWriteStreamUnscheduleFromRunLoop(
        stream: CFWriteStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFReadStreamSetDispatchQueue(stream: CFReadStreamRef, q: dispatch_queue_t);
}
extern "C" {
    pub fn CFWriteStreamSetDispatchQueue(stream: CFWriteStreamRef, q: dispatch_queue_t);
}
extern "C" {
    pub fn CFReadStreamCopyDispatchQueue(stream: CFReadStreamRef) -> dispatch_queue_t;
}
extern "C" {
    pub fn CFWriteStreamCopyDispatchQueue(stream: CFWriteStreamRef) -> dispatch_queue_t;
}
pub type CFStreamErrorDomain = CFIndex;
pub const kCFStreamErrorDomainCustom: _bindgen_ty_42 = -1;
pub const kCFStreamErrorDomainPOSIX: _bindgen_ty_42 = 1;
pub const kCFStreamErrorDomainMacOSStatus: _bindgen_ty_42 = 2;
pub type _bindgen_ty_42 = ::std::os::raw::c_int;
extern "C" {
    pub fn CFReadStreamGetError(stream: CFReadStreamRef) -> CFStreamError;
}
extern "C" {
    pub fn CFWriteStreamGetError(stream: CFWriteStreamRef) -> CFStreamError;
}
pub type CFPropertyListMutabilityOptions = CFOptionFlags;
pub const kCFPropertyListImmutable: _bindgen_ty_43 = 0;
pub const kCFPropertyListMutableContainers: _bindgen_ty_43 = 1;
pub const kCFPropertyListMutableContainersAndLeaves: _bindgen_ty_43 = 2;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFPropertyListCreateFromXMLData(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        mutabilityOption: CFOptionFlags,
        errorString: *mut CFStringRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPropertyListCreateXMLData(
        allocator: CFAllocatorRef,
        propertyList: CFPropertyListRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFPropertyListCreateDeepCopy(
        allocator: CFAllocatorRef,
        propertyList: CFPropertyListRef,
        mutabilityOption: CFOptionFlags,
    ) -> CFPropertyListRef;
}
pub type CFPropertyListFormat = CFIndex;
pub const kCFPropertyListOpenStepFormat: _bindgen_ty_44 = 1;
pub const kCFPropertyListXMLFormat_v1_0: _bindgen_ty_44 = 100;
pub const kCFPropertyListBinaryFormat_v1_0: _bindgen_ty_44 = 200;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFPropertyListIsValid(
        plist: CFPropertyListRef,
        format: CFPropertyListFormat,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPropertyListWriteToStream(
        propertyList: CFPropertyListRef,
        stream: CFWriteStreamRef,
        format: CFPropertyListFormat,
        errorString: *mut CFStringRef,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFPropertyListCreateFromStream(
        allocator: CFAllocatorRef,
        stream: CFReadStreamRef,
        streamLength: CFIndex,
        mutabilityOption: CFOptionFlags,
        format: *mut CFPropertyListFormat,
        errorString: *mut CFStringRef,
    ) -> CFPropertyListRef;
}
pub const kCFPropertyListReadCorruptError: _bindgen_ty_45 = 3840;
pub const kCFPropertyListReadUnknownVersionError: _bindgen_ty_45 = 3841;
pub const kCFPropertyListReadStreamError: _bindgen_ty_45 = 3842;
pub const kCFPropertyListWriteStreamError: _bindgen_ty_45 = 3851;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFPropertyListCreateWithData(
        allocator: CFAllocatorRef,
        data: CFDataRef,
        options: CFOptionFlags,
        format: *mut CFPropertyListFormat,
        error: *mut CFErrorRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPropertyListCreateWithStream(
        allocator: CFAllocatorRef,
        stream: CFReadStreamRef,
        streamLength: CFIndex,
        options: CFOptionFlags,
        format: *mut CFPropertyListFormat,
        error: *mut CFErrorRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPropertyListWrite(
        propertyList: CFPropertyListRef,
        stream: CFWriteStreamRef,
        format: CFPropertyListFormat,
        options: CFOptionFlags,
        error: *mut CFErrorRef,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFPropertyListCreateData(
        allocator: CFAllocatorRef,
        propertyList: CFPropertyListRef,
        format: CFPropertyListFormat,
        options: CFOptionFlags,
        error: *mut CFErrorRef,
    ) -> CFDataRef;
}
#[doc = "@typedef CFSetRetainCallBack\nType of the callback function used by CFSets for retaining values.\n@param allocator The allocator of the CFSet.\n@param value The value to retain.\n@result The value to store in the set, which is usually the value\nparameter passed to this callback, but may be a different\nvalue if a different value should be stored in the set."]
pub type CFSetRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
#[doc = "@typedef CFSetReleaseCallBack\nType of the callback function used by CFSets for releasing a retain on values.\n@param allocator The allocator of the CFSet.\n@param value The value to release."]
pub type CFSetReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
#[doc = "@typedef CFSetCopyDescriptionCallBack\nType of the callback function used by CFSets for describing values.\n@param value The value to describe.\n@result A description of the specified value."]
pub type CFSetCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
#[doc = "@typedef CFSetEqualCallBack\nType of the callback function used by CFSets for comparing values.\n@param value1 The first value to compare.\n@param value2 The second value to compare.\n@result True if the values are equal, otherwise false."]
pub type CFSetEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
#[doc = "@typedef CFSetHashCallBack\nType of the callback function used by CFSets for hashing values.\n@param value The value to hash.\n@result The hash of the value."]
pub type CFSetHashCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFHashCode,
>;
#[doc = "@typedef CFSetCallBacks\nStructure containing the callbacks of a CFSet.\n@field version The version number of the structure type being passed\nin as a parameter to the CFSet creation functions. This\nstructure is version 0.\n@field retain The callback used to add a retain for the set on\nvalues as they are put into the set. This callback returns\nthe value to store in the set, which is usually the value\nparameter passed to this callback, but may be a different\nvalue if a different value should be stored in the set.\nThe set's allocator is passed as the first argument.\n@field release The callback used to remove a retain previously added\nfor the set from values as they are removed from the\nset. The set's allocator is passed as the first\nargument.\n@field copyDescription The callback used to create a descriptive\nstring representation of each value in the set. This is\nused by the CFCopyDescription() function.\n@field equal The callback used to compare values in the set for\nequality for some operations.\n@field hash The callback used to compare values in the set for\nuniqueness for some operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSetCallBacks {
    pub version: CFIndex,
    pub retain: CFSetRetainCallBack,
    pub release: CFSetReleaseCallBack,
    pub copyDescription: CFSetCopyDescriptionCallBack,
    pub equal: CFSetEqualCallBack,
    pub hash: CFSetHashCallBack,
}
#[test]
fn bindgen_test_layout_CFSetCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFSetCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFSetCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFSetCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSetCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSetCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    #[doc = "@constant kCFTypeSetCallBacks\nPredefined CFSetCallBacks structure containing a set of callbacks\nappropriate for use when the values in a CFSet are all CFTypes."]
    pub static kCFTypeSetCallBacks: CFSetCallBacks;
}
extern "C" {
    #[doc = "@constant kCFCopyStringSetCallBacks\nPredefined CFSetCallBacks structure containing a set of callbacks\nappropriate for use when the values in a CFSet should be copies\nof a CFString."]
    pub static kCFCopyStringSetCallBacks: CFSetCallBacks;
}
#[doc = "@typedef CFSetApplierFunction\nType of the callback function used by the apply functions of\nCFSets.\n@param value The current value from the set.\n@param context The user-defined context parameter given to the apply\nfunction."]
pub type CFSetApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFSet {
    _unused: [u8; 0],
}
#[doc = "@typedef CFSetRef\nThis is the type of a reference to immutable CFSets."]
pub type CFSetRef = *const __CFSet;
#[doc = "@typedef CFMutableSetRef\nThis is the type of a reference to mutable CFSets."]
pub type CFMutableSetRef = *mut __CFSet;
extern "C" {
    #[doc = "@function CFSetGetTypeID\nReturns the type identifier of all CFSet instances."]
    pub fn CFSetGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFSetCreate\nCreates a new immutable set with the given values.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the set and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param values A C array of the pointer-sized values to be in the\nset.  This C array is not changed or freed by this function.\nIf this parameter is not a valid pointer to a C array of at\nleast numValues pointers, the behavior is undefined.\n@param numValues The number of values to copy from the values C\narray into the CFSet. This number will be the count of the\nset.  If this parameter is zero, negative, or greater than\nthe number of values actually in the values C array, the\nbehavior is undefined.\n@param callBacks A C pointer to a CFSetCallBacks structure\ninitialized with the callbacks for the set to use on each\nvalue in the set. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a\nstructure on the stack can be passed in, or can be reused\nfor multiple set creations. If the version field of this\ncallbacks structure is not one of the defined ones for\nCFSet, the behavior is undefined. The retain field may be\nNULL, in which case the CFSet will do nothing to add a\nretain to the contained values for the set. The release\nfield may be NULL, in which case the CFSet will do nothing\nto remove the set's retain (if any) on the values when the\nset is destroyed. If the copyDescription field is NULL,\nthe set will create a simple description for the value. If\nthe equal field is NULL, the set will use pointer equality\nto test for equality of values. The hash field may be NULL,\nin which case the CFSet will determine uniqueness by pointer\nequality. This callbacks parameter\nitself may be NULL, which is treated as if a valid structure\nof version 0 with all fields NULL had been passed in.\nOtherwise, if any of the fields are not valid pointers to\nfunctions of the correct type, or this parameter is not a\nvalid pointer to a  CFSetCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\nset is not one understood by one of the callback functions\nthe behavior when that callback function is used is\nundefined.\n@result A reference to the new immutable CFSet."]
    pub fn CFSetCreate(
        allocator: CFAllocatorRef,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        callBacks: *const CFSetCallBacks,
    ) -> CFSetRef;
}
extern "C" {
    #[doc = "@function CFSetCreateCopy\nCreates a new immutable set with the values from the given set.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the set and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param theSet The set which is to be copied. The values from the\nset are copied as pointers into the new set (that is,\nthe values themselves are copied, not that which the values\npoint to, if anything). However, the values are also\nretained by the new set. The count of the new set will\nbe the same as the copied set. The new set uses the same\ncallbacks as the set to be copied. If this parameter is\nnot a valid CFSet, the behavior is undefined.\n@result A reference to the new immutable CFSet."]
    pub fn CFSetCreateCopy(allocator: CFAllocatorRef, theSet: CFSetRef) -> CFSetRef;
}
extern "C" {
    #[doc = "@function CFSetCreateMutable\nCreates a new empty mutable set.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the set and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFSet. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. A set's actual capacity is only limited by\naddress space and available memory constraints). If this\nparameter is negative, the behavior is undefined.\n@param callBacks A C pointer to a CFSetCallBacks structure\ninitialized with the callbacks for the set to use on each\nvalue in the set. A copy of the contents of the\ncallbacks structure is made, so that a pointer to a\nstructure on the stack can be passed in, or can be reused\nfor multiple set creations. If the version field of this\ncallbacks structure is not one of the defined ones for\nCFSet, the behavior is undefined. The retain field may be\nNULL, in which case the CFSet will do nothing to add a\nretain to the contained values for the set. The release\nfield may be NULL, in which case the CFSet will do nothing\nto remove the set's retain (if any) on the values when the\nset is destroyed. If the copyDescription field is NULL,\nthe set will create a simple description for the value. If\nthe equal field is NULL, the set will use pointer equality\nto test for equality of values. The hash field may be NULL,\nin which case the CFSet will determine uniqueness by pointer\nequality. This callbacks parameter\nitself may be NULL, which is treated as if a valid structure\nof version 0 with all fields NULL had been passed in.\nOtherwise, if any of the fields are not valid pointers to\nfunctions of the correct type, or this parameter is not a\nvalid pointer to a  CFSetCallBacks callbacks structure,\nthe behavior is undefined. If any of the values put into the\nset is not one understood by one of the callback functions\nthe behavior when that callback function is used is\nundefined.\n@result A reference to the new mutable CFSet."]
    pub fn CFSetCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFSetCallBacks,
    ) -> CFMutableSetRef;
}
extern "C" {
    #[doc = "@function CFSetCreateMutableCopy\nCreates a new immutable set with the values from the given set.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the set and its storage for values. This\nparameter may be NULL in which case the current default\nCFAllocator is used. If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param capacity A hint about the number of values that will be held\nby the CFSet. Pass 0 for no hint. The implementation may\nignore this hint, or may use it to optimize various\noperations. A set's actual capacity is only limited by\naddress space and available memory constraints).\nThis parameter must be greater than or equal\nto the count of the set which is to be copied, or the\nbehavior is undefined. If this parameter is negative, the\nbehavior is undefined.\n@param theSet The set which is to be copied. The values from the\nset are copied as pointers into the new set (that is,\nthe values themselves are copied, not that which the values\npoint to, if anything). However, the values are also\nretained by the new set. The count of the new set will\nbe the same as the copied set. The new set uses the same\ncallbacks as the set to be copied. If this parameter is\nnot a valid CFSet, the behavior is undefined.\n@result A reference to the new mutable CFSet."]
    pub fn CFSetCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theSet: CFSetRef,
    ) -> CFMutableSetRef;
}
extern "C" {
    #[doc = "@function CFSetGetCount\nReturns the number of values currently in the set.\n@param theSet The set to be queried. If this parameter is not a valid\nCFSet, the behavior is undefined.\n@result The number of values in the set."]
    pub fn CFSetGetCount(theSet: CFSetRef) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFSetGetCountOfValue\nCounts the number of times the given value occurs in the set. Since\nsets by definition contain only one instance of a value, this function\nis synonymous to CFSetContainsValue.\n@param theSet The set to be searched. If this parameter is not a\nvalid CFSet, the behavior is undefined.\n@param value The value for which to find matches in the set. The\nequal() callback provided when the set was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the set, are not understood by the equal() callback,\nthe behavior is undefined.\n@result The number of times the given value occurs in the set."]
    pub fn CFSetGetCountOfValue(
        theSet: CFSetRef,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFSetContainsValue\nReports whether or not the value is in the set.\n@param theSet The set to be searched. If this parameter is not a\nvalid CFSet, the behavior is undefined.\n@param value The value for which to find matches in the set. The\nequal() callback provided when the set was created is\nused to compare. If the equal() callback was NULL, pointer\nequality (in C, ==) is used. If value, or any of the values\nin the set, are not understood by the equal() callback,\nthe behavior is undefined.\n@result true, if the value is in the set, otherwise false."]
    pub fn CFSetContainsValue(
        theSet: CFSetRef,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFSetGetValue\nRetrieves a value in the set which hashes the same as the specified value.\n@param theSet The set to be queried. If this parameter is not a\nvalid CFSet, the behavior is undefined.\n@param value The value to retrieve. The equal() callback provided when\nthe set was created is used to compare. If the equal() callback\nwas NULL, pointer equality (in C, ==) is used. If a value, or\nany of the values in the set, are not understood by the equal()\ncallback, the behavior is undefined.\n@result The value in the set with the given hash."]
    pub fn CFSetGetValue(
        theSet: CFSetRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function CFSetGetValueIfPresent\nRetrieves a value in the set which hashes the same as the specified value,\nif present.\n@param theSet The set to be queried. If this parameter is not a\nvalid CFSet, the behavior is undefined.\n@param candidate This value is hashed and compared with values in the\nset to determine which value to retrieve. The equal() callback provided when\nthe set was created is used to compare. If the equal() callback\nwas NULL, pointer equality (in C, ==) is used. If a value, or\nany of the values in the set, are not understood by the equal()\ncallback, the behavior is undefined.\n@param value A pointer to memory which should be filled with the\npointer-sized value if a matching value is found. If no\nmatch is found, the contents of the storage pointed to by\nthis parameter are undefined. This parameter may be NULL,\nin which case the value from the dictionary is not returned\n(but the return value of this function still indicates\nwhether or not the value was present).\n@result True if the value was present in the set, otherwise false."]
    pub fn CFSetGetValueIfPresent(
        theSet: CFSetRef,
        candidate: *const ::std::os::raw::c_void,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFSetGetValues\nFills the buffer with values from the set.\n@param theSet The set to be queried. If this parameter is not a\nvalid CFSet, the behavior is undefined.\n@param values A C array of pointer-sized values to be filled with\nvalues from the set. The values in the C array are ordered\nin the same order in which they appear in the set. If this\nparameter is not a valid pointer to a C array of at least\nCFSetGetCount() pointers, the behavior is undefined."]
    pub fn CFSetGetValues(theSet: CFSetRef, values: *mut *const ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "@function CFSetApplyFunction\nCalls a function once for each value in the set.\n@param theSet The set to be operated upon. If this parameter is not\na valid CFSet, the behavior is undefined.\n@param applier The callback function to call once for each value in\nthe given set. If this parameter is not a\npointer to a function of the correct prototype, the behavior\nis undefined. If there are values in the set which the\napplier function does not expect or cannot properly apply\nto, the behavior is undefined.\n@param context A pointer-sized user-defined value, which is passed\nas the second parameter to the applier function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the applier function, the behavior is\nundefined."]
    pub fn CFSetApplyFunction(
        theSet: CFSetRef,
        applier: CFSetApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFSetAddValue\nAdds the value to the set if it is not already present.\n@param theSet The set to which the value is to be added. If this\nparameter is not a valid mutable CFSet, the behavior is\nundefined.\n@param value The value to add to the set. The value is retained by\nthe set using the retain callback provided when the set\nwas created. If the value is not of the sort expected by the\nretain callback, the behavior is undefined. The count of the\nset is increased by one."]
    pub fn CFSetAddValue(theSet: CFMutableSetRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "@function CFSetReplaceValue\nReplaces the value in the set if it is present.\n@param theSet The set to which the value is to be replaced. If this\nparameter is not a valid mutable CFSet, the behavior is\nundefined.\n@param value The value to replace in the set. The equal() callback provided when\nthe set was created is used to compare. If the equal() callback\nwas NULL, pointer equality (in C, ==) is used. If a value, or\nany of the values in the set, are not understood by the equal()\ncallback, the behavior is undefined. The value is retained by\nthe set using the retain callback provided when the set\nwas created. If the value is not of the sort expected by the\nretain callback, the behavior is undefined. The count of the\nset is increased by one."]
    pub fn CFSetReplaceValue(
        theSet: CFMutableSetRef,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFSetSetValue\nReplaces the value in the set if it is present, or adds the value to\nthe set if it is absent.\n@param theSet The set to which the value is to be replaced. If this\nparameter is not a valid mutable CFSet, the behavior is\nundefined.\n@param value The value to set in the CFSet. The equal() callback provided when\nthe set was created is used to compare. If the equal() callback\nwas NULL, pointer equality (in C, ==) is used. If a value, or\nany of the values in the set, are not understood by the equal()\ncallback, the behavior is undefined. The value is retained by\nthe set using the retain callback provided when the set\nwas created. If the value is not of the sort expected by the\nretain callback, the behavior is undefined. The count of the\nset is increased by one."]
    pub fn CFSetSetValue(theSet: CFMutableSetRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "@function CFSetRemoveValue\nRemoves the specified value from the set.\n@param theSet The set from which the value is to be removed.\nIf this parameter is not a valid mutable CFSet,\nthe behavior is undefined.\n@param value The value to remove. The equal() callback provided when\nthe set was created is used to compare. If the equal() callback\nwas NULL, pointer equality (in C, ==) is used. If a value, or\nany of the values in the set, are not understood by the equal()\ncallback, the behavior is undefined."]
    pub fn CFSetRemoveValue(
        theSet: CFMutableSetRef,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFSetRemoveAllValues\nRemoves all the values from the set, making it empty.\n@param theSet The set from which all of the values are to be\nremoved. If this parameter is not a valid mutable CFSet,\nthe behavior is undefined."]
    pub fn CFSetRemoveAllValues(theSet: CFMutableSetRef);
}
pub type CFStringEncodings = CFIndex;
pub const kCFStringEncodingMacJapanese: _bindgen_ty_46 = 1;
pub const kCFStringEncodingMacChineseTrad: _bindgen_ty_46 = 2;
pub const kCFStringEncodingMacKorean: _bindgen_ty_46 = 3;
pub const kCFStringEncodingMacArabic: _bindgen_ty_46 = 4;
pub const kCFStringEncodingMacHebrew: _bindgen_ty_46 = 5;
pub const kCFStringEncodingMacGreek: _bindgen_ty_46 = 6;
pub const kCFStringEncodingMacCyrillic: _bindgen_ty_46 = 7;
pub const kCFStringEncodingMacDevanagari: _bindgen_ty_46 = 9;
pub const kCFStringEncodingMacGurmukhi: _bindgen_ty_46 = 10;
pub const kCFStringEncodingMacGujarati: _bindgen_ty_46 = 11;
pub const kCFStringEncodingMacOriya: _bindgen_ty_46 = 12;
pub const kCFStringEncodingMacBengali: _bindgen_ty_46 = 13;
pub const kCFStringEncodingMacTamil: _bindgen_ty_46 = 14;
pub const kCFStringEncodingMacTelugu: _bindgen_ty_46 = 15;
pub const kCFStringEncodingMacKannada: _bindgen_ty_46 = 16;
pub const kCFStringEncodingMacMalayalam: _bindgen_ty_46 = 17;
pub const kCFStringEncodingMacSinhalese: _bindgen_ty_46 = 18;
pub const kCFStringEncodingMacBurmese: _bindgen_ty_46 = 19;
pub const kCFStringEncodingMacKhmer: _bindgen_ty_46 = 20;
pub const kCFStringEncodingMacThai: _bindgen_ty_46 = 21;
pub const kCFStringEncodingMacLaotian: _bindgen_ty_46 = 22;
pub const kCFStringEncodingMacGeorgian: _bindgen_ty_46 = 23;
pub const kCFStringEncodingMacArmenian: _bindgen_ty_46 = 24;
pub const kCFStringEncodingMacChineseSimp: _bindgen_ty_46 = 25;
pub const kCFStringEncodingMacTibetan: _bindgen_ty_46 = 26;
pub const kCFStringEncodingMacMongolian: _bindgen_ty_46 = 27;
pub const kCFStringEncodingMacEthiopic: _bindgen_ty_46 = 28;
pub const kCFStringEncodingMacCentralEurRoman: _bindgen_ty_46 = 29;
pub const kCFStringEncodingMacVietnamese: _bindgen_ty_46 = 30;
pub const kCFStringEncodingMacExtArabic: _bindgen_ty_46 = 31;
pub const kCFStringEncodingMacSymbol: _bindgen_ty_46 = 33;
pub const kCFStringEncodingMacDingbats: _bindgen_ty_46 = 34;
pub const kCFStringEncodingMacTurkish: _bindgen_ty_46 = 35;
pub const kCFStringEncodingMacCroatian: _bindgen_ty_46 = 36;
pub const kCFStringEncodingMacIcelandic: _bindgen_ty_46 = 37;
pub const kCFStringEncodingMacRomanian: _bindgen_ty_46 = 38;
pub const kCFStringEncodingMacCeltic: _bindgen_ty_46 = 39;
pub const kCFStringEncodingMacGaelic: _bindgen_ty_46 = 40;
pub const kCFStringEncodingMacFarsi: _bindgen_ty_46 = 140;
pub const kCFStringEncodingMacUkrainian: _bindgen_ty_46 = 152;
pub const kCFStringEncodingMacInuit: _bindgen_ty_46 = 236;
pub const kCFStringEncodingMacVT100: _bindgen_ty_46 = 252;
pub const kCFStringEncodingMacHFS: _bindgen_ty_46 = 255;
pub const kCFStringEncodingISOLatin2: _bindgen_ty_46 = 514;
pub const kCFStringEncodingISOLatin3: _bindgen_ty_46 = 515;
pub const kCFStringEncodingISOLatin4: _bindgen_ty_46 = 516;
pub const kCFStringEncodingISOLatinCyrillic: _bindgen_ty_46 = 517;
pub const kCFStringEncodingISOLatinArabic: _bindgen_ty_46 = 518;
pub const kCFStringEncodingISOLatinGreek: _bindgen_ty_46 = 519;
pub const kCFStringEncodingISOLatinHebrew: _bindgen_ty_46 = 520;
pub const kCFStringEncodingISOLatin5: _bindgen_ty_46 = 521;
pub const kCFStringEncodingISOLatin6: _bindgen_ty_46 = 522;
pub const kCFStringEncodingISOLatinThai: _bindgen_ty_46 = 523;
pub const kCFStringEncodingISOLatin7: _bindgen_ty_46 = 525;
pub const kCFStringEncodingISOLatin8: _bindgen_ty_46 = 526;
pub const kCFStringEncodingISOLatin9: _bindgen_ty_46 = 527;
pub const kCFStringEncodingISOLatin10: _bindgen_ty_46 = 528;
pub const kCFStringEncodingDOSLatinUS: _bindgen_ty_46 = 1024;
pub const kCFStringEncodingDOSGreek: _bindgen_ty_46 = 1029;
pub const kCFStringEncodingDOSBalticRim: _bindgen_ty_46 = 1030;
pub const kCFStringEncodingDOSLatin1: _bindgen_ty_46 = 1040;
pub const kCFStringEncodingDOSGreek1: _bindgen_ty_46 = 1041;
pub const kCFStringEncodingDOSLatin2: _bindgen_ty_46 = 1042;
pub const kCFStringEncodingDOSCyrillic: _bindgen_ty_46 = 1043;
pub const kCFStringEncodingDOSTurkish: _bindgen_ty_46 = 1044;
pub const kCFStringEncodingDOSPortuguese: _bindgen_ty_46 = 1045;
pub const kCFStringEncodingDOSIcelandic: _bindgen_ty_46 = 1046;
pub const kCFStringEncodingDOSHebrew: _bindgen_ty_46 = 1047;
pub const kCFStringEncodingDOSCanadianFrench: _bindgen_ty_46 = 1048;
pub const kCFStringEncodingDOSArabic: _bindgen_ty_46 = 1049;
pub const kCFStringEncodingDOSNordic: _bindgen_ty_46 = 1050;
pub const kCFStringEncodingDOSRussian: _bindgen_ty_46 = 1051;
pub const kCFStringEncodingDOSGreek2: _bindgen_ty_46 = 1052;
pub const kCFStringEncodingDOSThai: _bindgen_ty_46 = 1053;
pub const kCFStringEncodingDOSJapanese: _bindgen_ty_46 = 1056;
pub const kCFStringEncodingDOSChineseSimplif: _bindgen_ty_46 = 1057;
pub const kCFStringEncodingDOSKorean: _bindgen_ty_46 = 1058;
pub const kCFStringEncodingDOSChineseTrad: _bindgen_ty_46 = 1059;
pub const kCFStringEncodingWindowsLatin2: _bindgen_ty_46 = 1281;
pub const kCFStringEncodingWindowsCyrillic: _bindgen_ty_46 = 1282;
pub const kCFStringEncodingWindowsGreek: _bindgen_ty_46 = 1283;
pub const kCFStringEncodingWindowsLatin5: _bindgen_ty_46 = 1284;
pub const kCFStringEncodingWindowsHebrew: _bindgen_ty_46 = 1285;
pub const kCFStringEncodingWindowsArabic: _bindgen_ty_46 = 1286;
pub const kCFStringEncodingWindowsBalticRim: _bindgen_ty_46 = 1287;
pub const kCFStringEncodingWindowsVietnamese: _bindgen_ty_46 = 1288;
pub const kCFStringEncodingWindowsKoreanJohab: _bindgen_ty_46 = 1296;
pub const kCFStringEncodingANSEL: _bindgen_ty_46 = 1537;
pub const kCFStringEncodingJIS_X0201_76: _bindgen_ty_46 = 1568;
pub const kCFStringEncodingJIS_X0208_83: _bindgen_ty_46 = 1569;
pub const kCFStringEncodingJIS_X0208_90: _bindgen_ty_46 = 1570;
pub const kCFStringEncodingJIS_X0212_90: _bindgen_ty_46 = 1571;
pub const kCFStringEncodingJIS_C6226_78: _bindgen_ty_46 = 1572;
pub const kCFStringEncodingShiftJIS_X0213: _bindgen_ty_46 = 1576;
pub const kCFStringEncodingShiftJIS_X0213_MenKuTen: _bindgen_ty_46 = 1577;
pub const kCFStringEncodingGB_2312_80: _bindgen_ty_46 = 1584;
pub const kCFStringEncodingGBK_95: _bindgen_ty_46 = 1585;
pub const kCFStringEncodingGB_18030_2000: _bindgen_ty_46 = 1586;
pub const kCFStringEncodingKSC_5601_87: _bindgen_ty_46 = 1600;
pub const kCFStringEncodingKSC_5601_92_Johab: _bindgen_ty_46 = 1601;
pub const kCFStringEncodingCNS_11643_92_P1: _bindgen_ty_46 = 1617;
pub const kCFStringEncodingCNS_11643_92_P2: _bindgen_ty_46 = 1618;
pub const kCFStringEncodingCNS_11643_92_P3: _bindgen_ty_46 = 1619;
pub const kCFStringEncodingISO_2022_JP: _bindgen_ty_46 = 2080;
pub const kCFStringEncodingISO_2022_JP_2: _bindgen_ty_46 = 2081;
pub const kCFStringEncodingISO_2022_JP_1: _bindgen_ty_46 = 2082;
pub const kCFStringEncodingISO_2022_JP_3: _bindgen_ty_46 = 2083;
pub const kCFStringEncodingISO_2022_CN: _bindgen_ty_46 = 2096;
pub const kCFStringEncodingISO_2022_CN_EXT: _bindgen_ty_46 = 2097;
pub const kCFStringEncodingISO_2022_KR: _bindgen_ty_46 = 2112;
pub const kCFStringEncodingEUC_JP: _bindgen_ty_46 = 2336;
pub const kCFStringEncodingEUC_CN: _bindgen_ty_46 = 2352;
pub const kCFStringEncodingEUC_TW: _bindgen_ty_46 = 2353;
pub const kCFStringEncodingEUC_KR: _bindgen_ty_46 = 2368;
pub const kCFStringEncodingShiftJIS: _bindgen_ty_46 = 2561;
pub const kCFStringEncodingKOI8_R: _bindgen_ty_46 = 2562;
pub const kCFStringEncodingBig5: _bindgen_ty_46 = 2563;
pub const kCFStringEncodingMacRomanLatin1: _bindgen_ty_46 = 2564;
pub const kCFStringEncodingHZ_GB_2312: _bindgen_ty_46 = 2565;
pub const kCFStringEncodingBig5_HKSCS_1999: _bindgen_ty_46 = 2566;
pub const kCFStringEncodingVISCII: _bindgen_ty_46 = 2567;
pub const kCFStringEncodingKOI8_U: _bindgen_ty_46 = 2568;
pub const kCFStringEncodingBig5_E: _bindgen_ty_46 = 2569;
pub const kCFStringEncodingNextStepJapanese: _bindgen_ty_46 = 2818;
pub const kCFStringEncodingEBCDIC_US: _bindgen_ty_46 = 3073;
pub const kCFStringEncodingEBCDIC_CP037: _bindgen_ty_46 = 3074;
pub const kCFStringEncodingUTF7: _bindgen_ty_46 = 67109120;
pub const kCFStringEncodingUTF7_IMAP: _bindgen_ty_46 = 2576;
pub const kCFStringEncodingShiftJIS_X0213_00: _bindgen_ty_46 = 1576;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
#[doc = "@typedef CFTreeRetainCallBack\nType of the callback function used to add a retain to the user-specified\ninfo parameter.  This callback may returns the value to use whenever the\ninfo parameter is retained, which is usually the value parameter passed\nto this callback, but may be a different value if a different value\nshould be used.\n@param info A user-supplied info parameter provided in a CFTreeContext.\n@result The retained info parameter."]
pub type CFTreeRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
#[doc = "@typedef CFTreeReleaseCallBack\nType of the callback function used to remove a retain previously\nadded to the user-specified info parameter.\n@param info A user-supplied info parameter provided in a CFTreeContext."]
pub type CFTreeReleaseCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>;
#[doc = "@typedef CFTreeCopyDescriptionCallBack\nType of the callback function used to provide a description of the\nuser-specified info parameter.\n@param info A user-supplied info parameter provided in a CFTreeContext.\n@result A description of the info parameter."]
pub type CFTreeCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
>;
#[doc = "@typedef CFTreeContext\nStructure containing user-specified data and callbacks for a CFTree.\n@field version The version number of the structure type being passed\nin as a parameter to the CFTree creation function.\nThis structure is version 0.\n@field info A C pointer to a user-specified block of data.\n@field retain The callback used to add a retain for the info field.\nIf this parameter is not a pointer to a function of the correct\nprototype, the behavior is undefined.  The value may be NULL.\n@field release The calllback used to remove a retain previously added\nfor the info field.  If this parameter is not a pointer to a\nfunction of the correct prototype, the behavior is undefined.\nThe value may be NULL.\n@field copyDescription The callback used to provide a description of\nthe info field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFTreeContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: CFTreeRetainCallBack,
    pub release: CFTreeReleaseCallBack,
    pub copyDescription: CFTreeCopyDescriptionCallBack,
}
#[test]
fn bindgen_test_layout_CFTreeContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFTreeContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFTreeContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFTreeContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFTreeContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFTreeContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
#[doc = "@typedef CFTreeApplierFunction\nType of the callback function used by the apply functions of\nCFTree.\n@param value The current value from the CFTree\n@param context The user-defined context parameter give to the apply\nfunction."]
pub type CFTreeApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFTree {
    _unused: [u8; 0],
}
#[doc = "@typedef CFTreeRef\nThis is the type of a reference to CFTrees."]
pub type CFTreeRef = *mut __CFTree;
extern "C" {
    #[doc = "@function CFTreeGetTypeID\nReturns the type identifier of all CFTree instances."]
    pub fn CFTreeGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFTreeCreate\nCreates a new mutable tree.\n@param allocator The CFAllocator which should be used to allocate\nmemory for the tree and storage for its children.  This\nparameter may be NULL in which case the current default\nCFAllocator is used.  If this reference is not a valid\nCFAllocator, the behavior is undefined.\n@param context A C pointer to a CFTreeContext structure to be copied\nand used as the context of the new tree.  The info parameter\nwill be retained by the tree if a retain function is provided.\nIf this value is not a valid C pointer to a CFTreeContext\nstructure-sized block of storage, the result is undefined.\nIf the version number of the storage is not a valid CFTreeContext\nversion number, the result is undefined.\n@result A reference to the new CFTree."]
    pub fn CFTreeCreate(
        allocator: CFAllocatorRef,
        context: *const CFTreeContext,
    ) -> CFTreeRef;
}
extern "C" {
    #[doc = "@function CFTreeGetParent\nReturns the parent of the specified tree.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@result The parent of the tree."]
    pub fn CFTreeGetParent(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    #[doc = "@function CFTreeGetNextSibling\nReturns the sibling after the specified tree in the parent tree's list.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@result The next sibling of the tree."]
    pub fn CFTreeGetNextSibling(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    #[doc = "@function CFTreeGetFirstChild\nReturns the first child of the tree.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@result The first child of the tree."]
    pub fn CFTreeGetFirstChild(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    #[doc = "@function CFTreeGetContext\nReturns the context of the specified tree.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param context A C pointer to a CFTreeContext structure to be filled in with\nthe context of the specified tree.  If this value is not a valid C\npointer to a CFTreeContext structure-sized block of storage, the\nresult is undefined.  If the version number of the storage is not\na valid CFTreeContext version number, the result is undefined."]
    pub fn CFTreeGetContext(tree: CFTreeRef, context: *mut CFTreeContext);
}
extern "C" {
    #[doc = "@function CFTreeGetChildCount\nReturns the number of children of the specified tree.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@result The number of children."]
    pub fn CFTreeGetChildCount(tree: CFTreeRef) -> CFIndex;
}
extern "C" {
    #[doc = "@function CFTreeGetChildAtIndex\nReturns the nth child of the specified tree.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param idx The index of the child tree to be returned.  If this parameter\nis less than zero or greater than the number of children of the\ntree, the result is undefined.\n@result A reference to the specified child tree."]
    pub fn CFTreeGetChildAtIndex(tree: CFTreeRef, idx: CFIndex) -> CFTreeRef;
}
extern "C" {
    #[doc = "@function CFTreeGetChildren\nFills the buffer with children from the tree.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param children A C array of pointer-sized values to be filled with\nchildren from the tree.  If this parameter is not a valid pointer to a\nC array of at least CFTreeGetChildCount() pointers, the behavior is undefined."]
    pub fn CFTreeGetChildren(tree: CFTreeRef, children: *mut CFTreeRef);
}
extern "C" {
    #[doc = "@function CFTreeApplyFunctionToChildren\nCalls a function once for each child of the tree.  Note that the applier\nonly operates one level deep, and does not operate on descendents further\nremoved than the immediate children of the tree.\n@param tree The tree to be operated upon.  If this parameter is not a\nvalid CFTree, the behavior is undefined.\n@param applier The callback function to call once for each child of\nthe given tree.  If this parameter is not a pointer to a\nfunction of the correct prototype, the behavior is undefined.\nIf there are values in the tree which the applier function does\nnot expect or cannot properly apply to, the behavior is undefined.\n@param context A pointer-sized user-defined value, which is passed\nas the second parameter to the applier function, but is\notherwise unused by this function.  If the context is not\nwhat is expected by the applier function, the behavior is\nundefined."]
    pub fn CFTreeApplyFunctionToChildren(
        tree: CFTreeRef,
        applier: CFTreeApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@function CFTreeFindRoot\nReturns the root tree of which the specified tree is a descendent.\n@param tree The tree to be queried.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@result A reference to the root of the tree."]
    pub fn CFTreeFindRoot(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    #[doc = "@function CFTreeSetContext\nReplaces the context of a tree.  The tree releases its retain on the\ninfo of the previous context, and retains the info of the new context.\n@param tree The tree to be operated on.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param context A C pointer to a CFTreeContext structure to be copied\nand used as the context of the new tree.  The info parameter\nwill be retained by the tree if a retain function is provided.\nIf this value is not a valid C pointer to a CFTreeContext\nstructure-sized block of storage, the result is undefined.\nIf the version number of the storage is not a valid CFTreeContext\nversion number, the result is undefined."]
    pub fn CFTreeSetContext(tree: CFTreeRef, context: *const CFTreeContext);
}
extern "C" {
    #[doc = "@function CFTreePrependChild\nAdds the newChild to the specified tree as the first in its list of children.\n@param tree The tree to be operated on.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param newChild The child to be added.\nIf this parameter is not a valid CFTree, the behavior is undefined.\nIf this parameter is a tree which is already a child of any tree,\nthe behavior is undefined."]
    pub fn CFTreePrependChild(tree: CFTreeRef, newChild: CFTreeRef);
}
extern "C" {
    #[doc = "@function CFTreeAppendChild\nAdds the newChild to the specified tree as the last in its list of children.\n@param tree The tree to be operated on.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param newChild The child to be added.\nIf this parameter is not a valid CFTree, the behavior is undefined.\nIf this parameter is a tree which is already a child of any tree,\nthe behavior is undefined."]
    pub fn CFTreeAppendChild(tree: CFTreeRef, newChild: CFTreeRef);
}
extern "C" {
    #[doc = "@function CFTreeInsertSibling\nInserts newSibling into the the parent tree's linked list of children after\ntree.  The newSibling will have the same parent as tree.\n@param tree The tree to insert newSibling after.  If this parameter is not a valid\nCFTree, the behavior is undefined.  If the tree does not have a\nparent, the behavior is undefined.\n@param newSibling The sibling to be added.\nIf this parameter is not a valid CFTree, the behavior is undefined.\nIf this parameter is a tree which is already a child of any tree,\nthe behavior is undefined."]
    pub fn CFTreeInsertSibling(tree: CFTreeRef, newSibling: CFTreeRef);
}
extern "C" {
    #[doc = "@function CFTreeRemove\nRemoves the tree from its parent.\n@param tree The tree to be removed.  If this parameter is not a valid\nCFTree, the behavior is undefined."]
    pub fn CFTreeRemove(tree: CFTreeRef);
}
extern "C" {
    #[doc = "@function CFTreeRemoveAllChildren\nRemoves all the children of the tree.\n@param tree The tree to remove all children from.  If this parameter is not a valid\nCFTree, the behavior is undefined."]
    pub fn CFTreeRemoveAllChildren(tree: CFTreeRef);
}
extern "C" {
    #[doc = "@function CFTreeSortChildren\nSorts the children of the specified tree using the specified comparator function.\n@param tree The tree to be operated on.  If this parameter is not a valid\nCFTree, the behavior is undefined.\n@param comparator The function with the comparator function type\nsignature which is used in the sort operation to compare\nchildren of the tree with the given value. If this parameter\nis not a pointer to a function of the correct prototype, the\nthe behavior is undefined. The children of the tree are sorted\nfrom least to greatest according to this function.\n@param context A pointer-sized user-defined value, which is passed\nas the third parameter to the comparator function, but is\notherwise unused by this function. If the context is not\nwhat is expected by the comparator function, the behavior is\nundefined."]
    pub fn CFTreeSortChildren(
        tree: CFTreeRef,
        comparator: CFComparatorFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFURLCreateDataAndPropertiesFromResource(
        alloc: CFAllocatorRef,
        url: CFURLRef,
        resourceData: *mut CFDataRef,
        properties: *mut CFDictionaryRef,
        desiredProperties: CFArrayRef,
        errorCode: *mut SInt32,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLWriteDataAndPropertiesToResource(
        url: CFURLRef,
        dataToWrite: CFDataRef,
        propertiesToWrite: CFDictionaryRef,
        errorCode: *mut SInt32,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLDestroyResource(url: CFURLRef, errorCode: *mut SInt32) -> Boolean;
}
extern "C" {
    pub fn CFURLCreatePropertyFromResource(
        alloc: CFAllocatorRef,
        url: CFURLRef,
        property: CFStringRef,
        errorCode: *mut SInt32,
    ) -> CFTypeRef;
}
pub type CFURLError = CFIndex;
pub const kCFURLUnknownError: _bindgen_ty_47 = -10;
pub const kCFURLUnknownSchemeError: _bindgen_ty_47 = -11;
pub const kCFURLResourceNotFoundError: _bindgen_ty_47 = -12;
pub const kCFURLResourceAccessViolationError: _bindgen_ty_47 = -13;
pub const kCFURLRemoteHostUnavailableError: _bindgen_ty_47 = -14;
pub const kCFURLImproperArgumentsError: _bindgen_ty_47 = -15;
pub const kCFURLUnknownPropertyKeyError: _bindgen_ty_47 = -16;
pub const kCFURLPropertyKeyUnavailableError: _bindgen_ty_47 = -17;
pub const kCFURLTimeoutError: _bindgen_ty_47 = -18;
pub type _bindgen_ty_47 = ::std::os::raw::c_int;
extern "C" {
    pub static kCFURLFileExists: CFStringRef;
}
extern "C" {
    pub static kCFURLFileDirectoryContents: CFStringRef;
}
extern "C" {
    pub static kCFURLFileLength: CFStringRef;
}
extern "C" {
    pub static kCFURLFileLastModificationTime: CFStringRef;
}
extern "C" {
    pub static kCFURLFilePOSIXMode: CFStringRef;
}
extern "C" {
    pub static kCFURLFileOwnerID: CFStringRef;
}
extern "C" {
    pub static kCFURLHTTPStatusCode: CFStringRef;
}
extern "C" {
    pub static kCFURLHTTPStatusLine: CFStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFUUID {
    _unused: [u8; 0],
}
pub type CFUUIDRef = *const __CFUUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFUUIDBytes {
    pub byte0: UInt8,
    pub byte1: UInt8,
    pub byte2: UInt8,
    pub byte3: UInt8,
    pub byte4: UInt8,
    pub byte5: UInt8,
    pub byte6: UInt8,
    pub byte7: UInt8,
    pub byte8: UInt8,
    pub byte9: UInt8,
    pub byte10: UInt8,
    pub byte11: UInt8,
    pub byte12: UInt8,
    pub byte13: UInt8,
    pub byte14: UInt8,
    pub byte15: UInt8,
}
#[test]
fn bindgen_test_layout_CFUUIDBytes() {
    const UNINIT: ::std::mem::MaybeUninit<CFUUIDBytes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFUUIDBytes>(),
        16usize,
        concat!("Size of: ", stringify!(CFUUIDBytes))
    );
    assert_eq!(
        ::std::mem::align_of::<CFUUIDBytes>(),
        1usize,
        concat!("Alignment of ", stringify!(CFUUIDBytes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte3) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte4) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte5) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte6) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte7) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte8) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte9) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte10) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte11) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte12) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte13) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte14) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte15) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte15)
        )
    );
}
extern "C" {
    pub fn CFUUIDGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFUUIDCreate(alloc: CFAllocatorRef) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDCreateWithBytes(
        alloc: CFAllocatorRef,
        byte0: UInt8,
        byte1: UInt8,
        byte2: UInt8,
        byte3: UInt8,
        byte4: UInt8,
        byte5: UInt8,
        byte6: UInt8,
        byte7: UInt8,
        byte8: UInt8,
        byte9: UInt8,
        byte10: UInt8,
        byte11: UInt8,
        byte12: UInt8,
        byte13: UInt8,
        byte14: UInt8,
        byte15: UInt8,
    ) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDCreateFromString(
        alloc: CFAllocatorRef,
        uuidStr: CFStringRef,
    ) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDCreateString(alloc: CFAllocatorRef, uuid: CFUUIDRef) -> CFStringRef;
}
extern "C" {
    pub fn CFUUIDGetConstantUUIDWithBytes(
        alloc: CFAllocatorRef,
        byte0: UInt8,
        byte1: UInt8,
        byte2: UInt8,
        byte3: UInt8,
        byte4: UInt8,
        byte5: UInt8,
        byte6: UInt8,
        byte7: UInt8,
        byte8: UInt8,
        byte9: UInt8,
        byte10: UInt8,
        byte11: UInt8,
        byte12: UInt8,
        byte13: UInt8,
        byte14: UInt8,
        byte15: UInt8,
    ) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDGetUUIDBytes(uuid: CFUUIDRef) -> CFUUIDBytes;
}
extern "C" {
    pub fn CFUUIDCreateFromUUIDBytes(
        alloc: CFAllocatorRef,
        bytes: CFUUIDBytes,
    ) -> CFUUIDRef;
}
extern "C" {
    pub fn CFCopyHomeDirectoryURL() -> CFURLRef;
}
pub type cpu_type_t = integer_t;
pub type cpu_subtype_t = integer_t;
pub type cpu_threadtype_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBundle {
    _unused: [u8; 0],
}
pub type CFBundleRef = *mut __CFBundle;
pub type CFPlugInRef = *mut __CFBundle;
extern "C" {
    pub static kCFBundleInfoDictionaryVersionKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleExecutableKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleVersionKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleDevelopmentRegionKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleNameKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleLocalizationsKey: CFStringRef;
}
extern "C" {
    pub fn CFBundleGetMainBundle() -> CFBundleRef;
}
extern "C" {
    pub fn CFBundleGetBundleWithIdentifier(bundleID: CFStringRef) -> CFBundleRef;
}
extern "C" {
    pub fn CFBundleGetAllBundles() -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBundleCreate(allocator: CFAllocatorRef, bundleURL: CFURLRef) -> CFBundleRef;
}
extern "C" {
    pub fn CFBundleCreateBundlesFromDirectory(
        allocator: CFAllocatorRef,
        directoryURL: CFURLRef,
        bundleType: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyBundleURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleGetValueForInfoDictionaryKey(
        bundle: CFBundleRef,
        key: CFStringRef,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFBundleGetInfoDictionary(bundle: CFBundleRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleGetLocalInfoDictionary(bundle: CFBundleRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleGetPackageInfo(
        bundle: CFBundleRef,
        packageType: *mut UInt32,
        packageCreator: *mut UInt32,
    );
}
extern "C" {
    pub fn CFBundleGetIdentifier(bundle: CFBundleRef) -> CFStringRef;
}
extern "C" {
    pub fn CFBundleGetVersionNumber(bundle: CFBundleRef) -> UInt32;
}
extern "C" {
    pub fn CFBundleGetDevelopmentRegion(bundle: CFBundleRef) -> CFStringRef;
}
extern "C" {
    pub fn CFBundleCopySupportFilesDirectoryURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourcesDirectoryURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyPrivateFrameworksURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopySharedFrameworksURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopySharedSupportURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyBuiltInPlugInsURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyInfoDictionaryInDirectory(bundleURL: CFURLRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleGetPackageInfoInDirectory(
        url: CFURLRef,
        packageType: *mut UInt32,
        packageCreator: *mut UInt32,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBundleCopyResourceURL(
        bundle: CFBundleRef,
        resourceName: CFStringRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLsOfType(
        bundle: CFBundleRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyLocalizedString(
        bundle: CFBundleRef,
        key: CFStringRef,
        value: CFStringRef,
        tableName: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLInDirectory(
        bundleURL: CFURLRef,
        resourceName: CFStringRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLsOfTypeInDirectory(
        bundleURL: CFURLRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyBundleLocalizations(bundle: CFBundleRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyPreferredLocalizationsFromArray(
        locArray: CFArrayRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyLocalizationsForPreferences(
        locArray: CFArrayRef,
        prefArray: CFArrayRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLForLocalization(
        bundle: CFBundleRef,
        resourceName: CFStringRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
        localizationName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLsOfTypeForLocalization(
        bundle: CFBundleRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
        localizationName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyInfoDictionaryForURL(url: CFURLRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleCopyLocalizationsForURL(url: CFURLRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyExecutableArchitecturesForURL(url: CFURLRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyExecutableURL(bundle: CFBundleRef) -> CFURLRef;
}
pub const kCFBundleExecutableArchitectureI386: _bindgen_ty_48 = 7;
pub const kCFBundleExecutableArchitecturePPC: _bindgen_ty_48 = 18;
pub const kCFBundleExecutableArchitectureX86_64: _bindgen_ty_48 = 16777223;
pub const kCFBundleExecutableArchitecturePPC64: _bindgen_ty_48 = 16777234;
pub const kCFBundleExecutableArchitectureARM64: _bindgen_ty_48 = 16777228;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFBundleCopyExecutableArchitectures(bundle: CFBundleRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundlePreflightExecutable(
        bundle: CFBundleRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBundleLoadExecutableAndReturnError(
        bundle: CFBundleRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBundleLoadExecutable(bundle: CFBundleRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleIsExecutableLoaded(bundle: CFBundleRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleUnloadExecutable(bundle: CFBundleRef);
}
extern "C" {
    pub fn CFBundleGetFunctionPointerForName(
        bundle: CFBundleRef,
        functionName: CFStringRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFBundleGetFunctionPointersForNames(
        bundle: CFBundleRef,
        functionNames: CFArrayRef,
        ftbl: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBundleGetDataPointerForName(
        bundle: CFBundleRef,
        symbolName: CFStringRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFBundleGetDataPointersForNames(
        bundle: CFBundleRef,
        symbolNames: CFArrayRef,
        stbl: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBundleCopyAuxiliaryExecutableURL(
        bundle: CFBundleRef,
        executableName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleIsExecutableLoadable(bundle: CFBundleRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleIsExecutableLoadableForURL(url: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleIsArchitectureLoadable(arch: cpu_type_t) -> Boolean;
}
extern "C" {
    pub fn CFBundleGetPlugIn(bundle: CFBundleRef) -> CFPlugInRef;
}
pub type CFBundleRefNum = ::std::os::raw::c_int;
extern "C" {
    pub fn CFBundleOpenBundleResourceMap(bundle: CFBundleRef) -> CFBundleRefNum;
}
extern "C" {
    pub fn CFBundleOpenBundleResourceFiles(
        bundle: CFBundleRef,
        refNum: *mut CFBundleRefNum,
        localizedRefNum: *mut CFBundleRefNum,
    ) -> SInt32;
}
extern "C" {
    pub fn CFBundleCloseBundleResourceMap(bundle: CFBundleRef, refNum: CFBundleRefNum);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFMessagePort {
    _unused: [u8; 0],
}
pub type CFMessagePortRef = *mut __CFMessagePort;
pub const kCFMessagePortSuccess: _bindgen_ty_49 = 0;
pub const kCFMessagePortSendTimeout: _bindgen_ty_49 = -1;
pub const kCFMessagePortReceiveTimeout: _bindgen_ty_49 = -2;
pub const kCFMessagePortIsInvalid: _bindgen_ty_49 = -3;
pub const kCFMessagePortTransportError: _bindgen_ty_49 = -4;
pub const kCFMessagePortBecameInvalidError: _bindgen_ty_49 = -5;
pub type _bindgen_ty_49 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFMessagePortContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFMessagePortContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFMessagePortContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFMessagePortContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFMessagePortContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFMessagePortContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFMessagePortContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
pub type CFMessagePortCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        local: CFMessagePortRef,
        msgid: SInt32,
        data: CFDataRef,
        info: *mut ::std::os::raw::c_void,
    ) -> CFDataRef,
>;
pub type CFMessagePortInvalidationCallBack = ::std::option::Option<
    unsafe extern "C" fn(ms: CFMessagePortRef, info: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFMessagePortGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFMessagePortCreateLocal(
        allocator: CFAllocatorRef,
        name: CFStringRef,
        callout: CFMessagePortCallBack,
        context: *mut CFMessagePortContext,
        shouldFreeInfo: *mut Boolean,
    ) -> CFMessagePortRef;
}
extern "C" {
    pub fn CFMessagePortCreateRemote(
        allocator: CFAllocatorRef,
        name: CFStringRef,
    ) -> CFMessagePortRef;
}
extern "C" {
    pub fn CFMessagePortIsRemote(ms: CFMessagePortRef) -> Boolean;
}
extern "C" {
    pub fn CFMessagePortGetName(ms: CFMessagePortRef) -> CFStringRef;
}
extern "C" {
    pub fn CFMessagePortSetName(ms: CFMessagePortRef, newName: CFStringRef) -> Boolean;
}
extern "C" {
    pub fn CFMessagePortGetContext(
        ms: CFMessagePortRef,
        context: *mut CFMessagePortContext,
    );
}
extern "C" {
    pub fn CFMessagePortInvalidate(ms: CFMessagePortRef);
}
extern "C" {
    pub fn CFMessagePortIsValid(ms: CFMessagePortRef) -> Boolean;
}
extern "C" {
    pub fn CFMessagePortGetInvalidationCallBack(
        ms: CFMessagePortRef,
    ) -> CFMessagePortInvalidationCallBack;
}
extern "C" {
    pub fn CFMessagePortSetInvalidationCallBack(
        ms: CFMessagePortRef,
        callout: CFMessagePortInvalidationCallBack,
    );
}
extern "C" {
    pub fn CFMessagePortSendRequest(
        remote: CFMessagePortRef,
        msgid: SInt32,
        data: CFDataRef,
        sendTimeout: CFTimeInterval,
        rcvTimeout: CFTimeInterval,
        replyMode: CFStringRef,
        returnData: *mut CFDataRef,
    ) -> SInt32;
}
extern "C" {
    pub fn CFMessagePortCreateRunLoopSource(
        allocator: CFAllocatorRef,
        local: CFMessagePortRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFMessagePortSetDispatchQueue(ms: CFMessagePortRef, queue: dispatch_queue_t);
}
extern "C" {
    pub static kCFPlugInDynamicRegistrationKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInDynamicRegisterFunctionKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInUnloadFunctionKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInFactoriesKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInTypesKey: CFStringRef;
}
pub type CFPlugInDynamicRegisterFunction =
    ::std::option::Option<unsafe extern "C" fn(plugIn: CFPlugInRef)>;
pub type CFPlugInUnloadFunction =
    ::std::option::Option<unsafe extern "C" fn(plugIn: CFPlugInRef)>;
pub type CFPlugInFactoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        typeUUID: CFUUIDRef,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn CFPlugInGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFPlugInCreate(allocator: CFAllocatorRef, plugInURL: CFURLRef) -> CFPlugInRef;
}
extern "C" {
    pub fn CFPlugInGetBundle(plugIn: CFPlugInRef) -> CFBundleRef;
}
extern "C" {
    pub fn CFPlugInSetLoadOnDemand(plugIn: CFPlugInRef, flag: Boolean);
}
extern "C" {
    pub fn CFPlugInIsLoadOnDemand(plugIn: CFPlugInRef) -> Boolean;
}
extern "C" {
    pub fn CFPlugInFindFactoriesForPlugInType(typeUUID: CFUUIDRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFPlugInFindFactoriesForPlugInTypeInPlugIn(
        typeUUID: CFUUIDRef,
        plugIn: CFPlugInRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFPlugInInstanceCreate(
        allocator: CFAllocatorRef,
        factoryUUID: CFUUIDRef,
        typeUUID: CFUUIDRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFPlugInRegisterFactoryFunction(
        factoryUUID: CFUUIDRef,
        func: CFPlugInFactoryFunction,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInRegisterFactoryFunctionByName(
        factoryUUID: CFUUIDRef,
        plugIn: CFPlugInRef,
        functionName: CFStringRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInUnregisterFactory(factoryUUID: CFUUIDRef) -> Boolean;
}
extern "C" {
    pub fn CFPlugInRegisterPlugInType(
        factoryUUID: CFUUIDRef,
        typeUUID: CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInUnregisterPlugInType(
        factoryUUID: CFUUIDRef,
        typeUUID: CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInAddInstanceForFactory(factoryID: CFUUIDRef);
}
extern "C" {
    pub fn CFPlugInRemoveInstanceForFactory(factoryID: CFUUIDRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFPlugInInstance {
    _unused: [u8; 0],
}
pub type CFPlugInInstanceRef = *mut __CFPlugInInstance;
pub type CFPlugInInstanceGetInterfaceFunction = ::std::option::Option<
    unsafe extern "C" fn(
        instance: CFPlugInInstanceRef,
        interfaceName: CFStringRef,
        ftbl: *mut *mut ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type CFPlugInInstanceDeallocateInstanceDataFunction = ::std::option::Option<
    unsafe extern "C" fn(instanceData: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFPlugInInstanceGetInterfaceFunctionTable(
        instance: CFPlugInInstanceRef,
        interfaceName: CFStringRef,
        ftbl: *mut *mut ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInInstanceGetFactoryName(instance: CFPlugInInstanceRef) -> CFStringRef;
}
extern "C" {
    pub fn CFPlugInInstanceGetInstanceData(
        instance: CFPlugInInstanceRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFPlugInInstanceGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFPlugInInstanceCreateWithInstanceDataSize(
        allocator: CFAllocatorRef,
        instanceDataSize: CFIndex,
        deallocateInstanceFunction: CFPlugInInstanceDeallocateInstanceDataFunction,
        factoryName: CFStringRef,
        getInterfaceFunction: CFPlugInInstanceGetInterfaceFunction,
    ) -> CFPlugInInstanceRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFMachPort {
    _unused: [u8; 0],
}
pub type CFMachPortRef = *mut __CFMachPort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFMachPortContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFMachPortContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFMachPortContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFMachPortContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFMachPortContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFMachPortContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFMachPortContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
pub type CFMachPortCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        port: CFMachPortRef,
        msg: *mut ::std::os::raw::c_void,
        size: CFIndex,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFMachPortInvalidationCallBack = ::std::option::Option<
    unsafe extern "C" fn(port: CFMachPortRef, info: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFMachPortGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFMachPortCreate(
        allocator: CFAllocatorRef,
        callout: CFMachPortCallBack,
        context: *mut CFMachPortContext,
        shouldFreeInfo: *mut Boolean,
    ) -> CFMachPortRef;
}
extern "C" {
    pub fn CFMachPortCreateWithPort(
        allocator: CFAllocatorRef,
        portNum: mach_port_t,
        callout: CFMachPortCallBack,
        context: *mut CFMachPortContext,
        shouldFreeInfo: *mut Boolean,
    ) -> CFMachPortRef;
}
extern "C" {
    pub fn CFMachPortGetPort(port: CFMachPortRef) -> mach_port_t;
}
extern "C" {
    pub fn CFMachPortGetContext(port: CFMachPortRef, context: *mut CFMachPortContext);
}
extern "C" {
    pub fn CFMachPortInvalidate(port: CFMachPortRef);
}
extern "C" {
    pub fn CFMachPortIsValid(port: CFMachPortRef) -> Boolean;
}
extern "C" {
    pub fn CFMachPortGetInvalidationCallBack(
        port: CFMachPortRef,
    ) -> CFMachPortInvalidationCallBack;
}
extern "C" {
    pub fn CFMachPortSetInvalidationCallBack(
        port: CFMachPortRef,
        callout: CFMachPortInvalidationCallBack,
    );
}
extern "C" {
    pub fn CFMachPortCreateRunLoopSource(
        allocator: CFAllocatorRef,
        port: CFMachPortRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAttributedString {
    _unused: [u8; 0],
}
pub type CFAttributedStringRef = *const __CFAttributedString;
pub type CFMutableAttributedStringRef = *mut __CFAttributedString;
extern "C" {
    #[doc = " @function CFAttributedStringGetTypeID\nReturns the type identifier of all CFAttributedString instances."]
    pub fn CFAttributedStringGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = " @function CFAttributedStringCreate\nCreates an attributed string with the specified string and attributes (both copied)."]
    pub fn CFAttributedStringCreate(
        alloc: CFAllocatorRef,
        str_: CFStringRef,
        attributes: CFDictionaryRef,
    ) -> CFAttributedStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringCreateWithSubstring\nCreates a sub-attributed string from the specified range. It's a programming error for range to specify characters outside the bounds of aStr."]
    pub fn CFAttributedStringCreateWithSubstring(
        alloc: CFAllocatorRef,
        aStr: CFAttributedStringRef,
        range: CFRange,
    ) -> CFAttributedStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringCreateCopy\nCreates an immutable attributed string copy."]
    pub fn CFAttributedStringCreateCopy(
        alloc: CFAllocatorRef,
        aStr: CFAttributedStringRef,
    ) -> CFAttributedStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringGetString\nReturns the string for the attributed string. For performance reasons, this will often point at the backing store of the attributed string, and it might change if the attributed string is edited.  However, this is an implementation detail, and definitely not something that should be counted on."]
    pub fn CFAttributedStringGetString(aStr: CFAttributedStringRef) -> CFStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringGetLength\nReturns the length of the attributed string in characters; same as CFStringGetLength(CFAttributedStringGetString(aStr))"]
    pub fn CFAttributedStringGetLength(aStr: CFAttributedStringRef) -> CFIndex;
}
extern "C" {
    #[doc = " @function CFAttributedStringGetAttributes\nReturns the attributes at the specified location. If effectiveRange is not NULL, upon return *effectiveRange contains a range over which the exact same set of attributes apply. Note that for performance reasons, the returned effectiveRange is not necessarily the maximal range - for that, use CFAttributedStringGetAttributesAndLongestEffectiveRange().  It's a programming error for loc to specify a location outside the bounds of the attributed string.\n\nNote that the returned attribute dictionary might change in unpredictable ways from under the caller if the attributed string is edited after this call. If you wish to hang on to the dictionary long-term, you should make an actual copy of it rather than just retaining it.  Also, no assumptions should be made about the relationship of the actual CFDictionaryRef returned by this call and the dictionary originally used to set the attributes, other than the fact that the values stored in the dictionary will be identical (that is, ==) to those originally specified."]
    pub fn CFAttributedStringGetAttributes(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        effectiveRange: *mut CFRange,
    ) -> CFDictionaryRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringGetAttribute\nReturns the value of a single attribute at the specified location. If the specified attribute doesn't exist at the location, returns NULL. If effectiveRange is not NULL, upon return *effectiveRange contains a range over which the exact same attribute value applies. Note that for performance reasons, the returned effectiveRange is not necessarily the maximal range - for that, use CFAttributedStringGetAttributeAndLongestEffectiveRange(). It's a programming error for loc to specify a location outside the bounds of the attributed string."]
    pub fn CFAttributedStringGetAttribute(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        attrName: CFStringRef,
        effectiveRange: *mut CFRange,
    ) -> CFTypeRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringGetAttributesAndLongestEffectiveRange\nReturns the attributes at the specified location. If longestEffectiveRange is not NULL, upon return *longestEffectiveRange contains the maximal range within inRange over which the exact same set of attributes apply. The returned range is clipped to inRange. It's a programming error for loc or inRange to specify locations outside the bounds of the attributed string."]
    pub fn CFAttributedStringGetAttributesAndLongestEffectiveRange(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        inRange: CFRange,
        longestEffectiveRange: *mut CFRange,
    ) -> CFDictionaryRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringGetAttributeAndLongestEffectiveRange\nReturns the value of a single attribute at the specified location. If longestEffectiveRange is not NULL, upon return *longestEffectiveRange contains the maximal range within inRange over which the exact same attribute value applies. The returned range is clipped to inRange. It's a programming error for loc or inRange to specify locations outside the bounds of the attributed string."]
    pub fn CFAttributedStringGetAttributeAndLongestEffectiveRange(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        attrName: CFStringRef,
        inRange: CFRange,
        longestEffectiveRange: *mut CFRange,
    ) -> CFTypeRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringCreateMutableCopy\nCreates a mutable attributed string copy. maxLength, if not 0, is a hard bound on the length of the attributed string; exceeding this size limit during any editing operation is a programming error. If 0, there is no limit on the length."]
    pub fn CFAttributedStringCreateMutableCopy(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
        aStr: CFAttributedStringRef,
    ) -> CFMutableAttributedStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringCreateMutable\nCreates a mutable empty attributed string. maxLength, if not 0, is a hard bound on the length of the attributed string; exceeding this size limit during any editing operation is a programming error. If 0, there is no limit on the length."]
    pub fn CFAttributedStringCreateMutable(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
    ) -> CFMutableAttributedStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringReplaceString\nModifies the string for the attributed string, much like CFStringReplace().  It's an error for range to specify characters outside the bounds of aStr.\n\n(Note: This function is a convenience on CFAttributedStringGetMutableString(); however, until CFAttributedStringGetMutableString() is implemented, it remains the only way to edit the string of the attributed string.)"]
    pub fn CFAttributedStringReplaceString(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        replacement: CFStringRef,
    );
}
extern "C" {
    #[doc = " @function CFAttributedStringGetMutableString\nGets the string for the attributed string as a mutable string, allowing editing the character contents of the string as if it were an CFMutableString. Attributes corresponding to the edited range are appropriately modified. If, as a result of the edit, new characters are introduced into the string, they inherit the attributes of the first replaced character from range. If no existing characters are replaced by the edit, the new characters inherit the attributes of the character preceding range if it has any, otherwise of the character following range. If the initial string is empty, the attributes for the new characters are also empty.\n\n(Note: This function is not yet implemented and will return NULL except for toll-free bridged instances.)"]
    pub fn CFAttributedStringGetMutableString(
        aStr: CFMutableAttributedStringRef,
    ) -> CFMutableStringRef;
}
extern "C" {
    #[doc = " @function CFAttributedStringSetAttributes\nSets the value of multiple attributes over the specified range, which should be valid. If clearOtherAttributes is false, existing attributes (which aren't being replaced) are left alone; otherwise they are cleared. The dictionary should be setup for \"usual\" CF type usage --- CFString keys, and arbitrary CFType values. Note that after this call, further mutations to the replacement dictionary argument by the caller will not affect the contents of the attributed string."]
    pub fn CFAttributedStringSetAttributes(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        replacement: CFDictionaryRef,
        clearOtherAttributes: Boolean,
    );
}
extern "C" {
    #[doc = " @function CFAttributedStringSetAttribute\nSets the value of a single attribute over the specified range, which should be valid. value should not be NULL."]
    pub fn CFAttributedStringSetAttribute(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        attrName: CFStringRef,
        value: CFTypeRef,
    );
}
extern "C" {
    #[doc = " @function CFAttributedStringRemoveAttribute\nRemoves the value of a single attribute over the specified range, which should be valid. It's OK for the attribute not the exist over the specified range."]
    pub fn CFAttributedStringRemoveAttribute(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        attrName: CFStringRef,
    );
}
extern "C" {
    #[doc = " @function CFAttributedStringReplaceAttributedString\nReplaces the attributed substring over the specified range with the attributed string specified in replacement. range should be valid. To delete a range of the attributed string, call CFAttributedStringReplaceString() with empty string and specified range."]
    pub fn CFAttributedStringReplaceAttributedString(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        replacement: CFAttributedStringRef,
    );
}
extern "C" {
    #[doc = " @function CFAttributedStringBeginEditing\nIn cases where attributed string might do a bunch of work to assure self-consistency, CFAttributedStringBeginEditing/CFAttributedStringEndEditing allow disabling that to allow deferring and coalescing any work. It's a good idea to call these around a set of related mutation calls which don't require the string to be in consistent state in between. These calls can be nested."]
    pub fn CFAttributedStringBeginEditing(aStr: CFMutableAttributedStringRef);
}
extern "C" {
    #[doc = " @function CFAttributedStringEndEditing\nIn cases where attributed string might do a bunch of work to assure self-consistency, CFAttributedStringBeginEditing/CFAttributedStringEndEditing allow disabling that to allow deferring and coalescing any work. It's a good idea to call these around a set of related mutation calls which don't require the string to be in consistent state in between. These calls can be nested."]
    pub fn CFAttributedStringEndEditing(aStr: CFMutableAttributedStringRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFURLEnumerator {
    _unused: [u8; 0],
}
pub type CFURLEnumeratorRef = *const __CFURLEnumerator;
extern "C" {
    pub fn CFURLEnumeratorGetTypeID() -> CFTypeID;
}
pub type CFURLEnumeratorOptions = CFOptionFlags;
pub const kCFURLEnumeratorDefaultBehavior: _bindgen_ty_50 = 0;
pub const kCFURLEnumeratorDescendRecursively: _bindgen_ty_50 = 1;
pub const kCFURLEnumeratorSkipInvisibles: _bindgen_ty_50 = 2;
pub const kCFURLEnumeratorGenerateFileReferenceURLs: _bindgen_ty_50 = 4;
pub const kCFURLEnumeratorSkipPackageContents: _bindgen_ty_50 = 8;
pub const kCFURLEnumeratorIncludeDirectoriesPreOrder: _bindgen_ty_50 = 16;
pub const kCFURLEnumeratorIncludeDirectoriesPostOrder: _bindgen_ty_50 = 32;
pub const kCFURLEnumeratorGenerateRelativePathURLs: _bindgen_ty_50 = 64;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFURLEnumeratorCreateForDirectoryURL(
        alloc: CFAllocatorRef,
        directoryURL: CFURLRef,
        option: CFURLEnumeratorOptions,
        propertyKeys: CFArrayRef,
    ) -> CFURLEnumeratorRef;
}
extern "C" {
    pub fn CFURLEnumeratorCreateForMountedVolumes(
        alloc: CFAllocatorRef,
        option: CFURLEnumeratorOptions,
        propertyKeys: CFArrayRef,
    ) -> CFURLEnumeratorRef;
}
pub type CFURLEnumeratorResult = CFIndex;
pub const kCFURLEnumeratorSuccess: _bindgen_ty_51 = 1;
pub const kCFURLEnumeratorEnd: _bindgen_ty_51 = 2;
pub const kCFURLEnumeratorError: _bindgen_ty_51 = 3;
pub const kCFURLEnumeratorDirectoryPostOrderSuccess: _bindgen_ty_51 = 4;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFURLEnumeratorGetNextURL(
        enumerator: CFURLEnumeratorRef,
        url: *mut CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFURLEnumeratorResult;
}
extern "C" {
    pub fn CFURLEnumeratorSkipDescendents(enumerator: CFURLEnumeratorRef);
}
extern "C" {
    pub fn CFURLEnumeratorGetDescendentLevel(enumerator: CFURLEnumeratorRef) -> CFIndex;
}
extern "C" {
    pub fn CFURLEnumeratorGetSourceDidChange(enumerator: CFURLEnumeratorRef) -> Boolean;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union guid_t {
    pub g_guid: [::std::os::raw::c_uchar; 16usize],
    pub g_guid_asint: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_guid_t() {
    const UNINIT: ::std::mem::MaybeUninit<guid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<guid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(guid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(guid_t),
            "::",
            stringify!(g_guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_guid_asint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(guid_t),
            "::",
            stringify!(g_guid_asint)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ntsid_t {
    pub sid_kind: u_int8_t,
    pub sid_authcount: u_int8_t,
    pub sid_authority: [u_int8_t; 6usize],
    pub sid_authorities: [u_int32_t; 16usize],
}
#[test]
fn bindgen_test_layout_ntsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<ntsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ntsid_t>(),
        72usize,
        concat!("Size of: ", stringify!(ntsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ntsid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ntsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_authcount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_authority) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid_authorities) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authorities)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_identity_extlookup {
    pub el_seqno: u_int32_t,
    pub el_result: u_int32_t,
    pub el_flags: u_int32_t,
    pub el_info_pid: __darwin_pid_t,
    pub el_extend: u_int64_t,
    pub el_info_reserved_1: u_int32_t,
    pub el_uid: uid_t,
    pub el_uguid: guid_t,
    pub el_uguid_valid: u_int32_t,
    pub el_usid: ntsid_t,
    pub el_usid_valid: u_int32_t,
    pub el_gid: gid_t,
    pub el_gguid: guid_t,
    pub el_gguid_valid: u_int32_t,
    pub el_gsid: ntsid_t,
    pub el_gsid_valid: u_int32_t,
    pub el_member_valid: u_int32_t,
    pub el_sup_grp_cnt: u_int32_t,
    pub el_sup_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_kauth_identity_extlookup() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_identity_extlookup> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_identity_extlookup>(),
        304usize,
        concat!("Size of: ", stringify!(kauth_identity_extlookup))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_identity_extlookup>(),
        8usize,
        concat!("Alignment of ", stringify!(kauth_identity_extlookup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_seqno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_seqno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_info_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_info_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_extend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_extend)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).el_info_reserved_1) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_info_reserved_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_uguid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uguid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_uguid_valid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uguid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_usid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_usid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_usid_valid) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_usid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gid) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gguid) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gguid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gguid_valid) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gguid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gsid) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_gsid_valid) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gsid_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_member_valid) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_member_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_sup_grp_cnt) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_sup_grp_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_sup_groups) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_sup_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kauth_cache_sizes {
    pub kcs_group_size: u_int32_t,
    pub kcs_id_size: u_int32_t,
}
#[test]
fn bindgen_test_layout_kauth_cache_sizes() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_cache_sizes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_cache_sizes>(),
        8usize,
        concat!("Size of: ", stringify!(kauth_cache_sizes))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_cache_sizes>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_cache_sizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kcs_group_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_cache_sizes),
            "::",
            stringify!(kcs_group_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kcs_id_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_cache_sizes),
            "::",
            stringify!(kcs_id_size)
        )
    );
}
pub type kauth_ace_rights_t = u_int32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_ace {
    pub ace_applicable: guid_t,
    pub ace_flags: u_int32_t,
    pub ace_rights: kauth_ace_rights_t,
}
#[test]
fn bindgen_test_layout_kauth_ace() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_ace> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_ace>(),
        24usize,
        concat!("Size of: ", stringify!(kauth_ace))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_ace>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_ace))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ace_applicable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_applicable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ace_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ace_rights) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_rights)
        )
    );
}
pub type kauth_ace_t = *mut kauth_ace;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_acl {
    pub acl_entrycount: u_int32_t,
    pub acl_flags: u_int32_t,
    pub acl_ace: [kauth_ace; 1usize],
}
#[test]
fn bindgen_test_layout_kauth_acl() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_acl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_acl>(),
        32usize,
        concat!("Size of: ", stringify!(kauth_acl))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_acl>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_acl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl_entrycount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_entrycount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acl_ace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_ace)
        )
    );
}
pub type kauth_acl_t = *mut kauth_acl;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kauth_filesec {
    pub fsec_magic: u_int32_t,
    pub fsec_owner: guid_t,
    pub fsec_group: guid_t,
    pub fsec_acl: kauth_acl,
}
#[test]
fn bindgen_test_layout_kauth_filesec() {
    const UNINIT: ::std::mem::MaybeUninit<kauth_filesec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kauth_filesec>(),
        68usize,
        concat!("Size of: ", stringify!(kauth_filesec))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_filesec>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_filesec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_owner) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_group) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsec_acl) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_acl)
        )
    );
}
pub type kauth_filesec_t = *mut kauth_filesec;
pub const acl_perm_t_ACL_READ_DATA: acl_perm_t = 2;
pub const acl_perm_t_ACL_LIST_DIRECTORY: acl_perm_t = 2;
pub const acl_perm_t_ACL_WRITE_DATA: acl_perm_t = 4;
pub const acl_perm_t_ACL_ADD_FILE: acl_perm_t = 4;
pub const acl_perm_t_ACL_EXECUTE: acl_perm_t = 8;
pub const acl_perm_t_ACL_SEARCH: acl_perm_t = 8;
pub const acl_perm_t_ACL_DELETE: acl_perm_t = 16;
pub const acl_perm_t_ACL_APPEND_DATA: acl_perm_t = 32;
pub const acl_perm_t_ACL_ADD_SUBDIRECTORY: acl_perm_t = 32;
pub const acl_perm_t_ACL_DELETE_CHILD: acl_perm_t = 64;
pub const acl_perm_t_ACL_READ_ATTRIBUTES: acl_perm_t = 128;
pub const acl_perm_t_ACL_WRITE_ATTRIBUTES: acl_perm_t = 256;
pub const acl_perm_t_ACL_READ_EXTATTRIBUTES: acl_perm_t = 512;
pub const acl_perm_t_ACL_WRITE_EXTATTRIBUTES: acl_perm_t = 1024;
pub const acl_perm_t_ACL_READ_SECURITY: acl_perm_t = 2048;
pub const acl_perm_t_ACL_WRITE_SECURITY: acl_perm_t = 4096;
pub const acl_perm_t_ACL_CHANGE_OWNER: acl_perm_t = 8192;
pub const acl_perm_t_ACL_SYNCHRONIZE: acl_perm_t = 1048576;
pub type acl_perm_t = ::std::os::raw::c_uint;
pub const acl_tag_t_ACL_UNDEFINED_TAG: acl_tag_t = 0;
pub const acl_tag_t_ACL_EXTENDED_ALLOW: acl_tag_t = 1;
pub const acl_tag_t_ACL_EXTENDED_DENY: acl_tag_t = 2;
pub type acl_tag_t = ::std::os::raw::c_uint;
pub const acl_type_t_ACL_TYPE_EXTENDED: acl_type_t = 256;
pub const acl_type_t_ACL_TYPE_ACCESS: acl_type_t = 0;
pub const acl_type_t_ACL_TYPE_DEFAULT: acl_type_t = 1;
pub const acl_type_t_ACL_TYPE_AFS: acl_type_t = 2;
pub const acl_type_t_ACL_TYPE_CODA: acl_type_t = 3;
pub const acl_type_t_ACL_TYPE_NTFS: acl_type_t = 4;
pub const acl_type_t_ACL_TYPE_NWFS: acl_type_t = 5;
pub type acl_type_t = ::std::os::raw::c_uint;
pub const acl_entry_id_t_ACL_FIRST_ENTRY: acl_entry_id_t = 0;
pub const acl_entry_id_t_ACL_NEXT_ENTRY: acl_entry_id_t = -1;
pub const acl_entry_id_t_ACL_LAST_ENTRY: acl_entry_id_t = -2;
pub type acl_entry_id_t = ::std::os::raw::c_int;
pub const acl_flag_t_ACL_FLAG_DEFER_INHERIT: acl_flag_t = 1;
pub const acl_flag_t_ACL_FLAG_NO_INHERIT: acl_flag_t = 131072;
pub const acl_flag_t_ACL_ENTRY_INHERITED: acl_flag_t = 16;
pub const acl_flag_t_ACL_ENTRY_FILE_INHERIT: acl_flag_t = 32;
pub const acl_flag_t_ACL_ENTRY_DIRECTORY_INHERIT: acl_flag_t = 64;
pub const acl_flag_t_ACL_ENTRY_LIMIT_INHERIT: acl_flag_t = 128;
pub const acl_flag_t_ACL_ENTRY_ONLY_INHERIT: acl_flag_t = 256;
pub type acl_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_permset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_flagset {
    _unused: [u8; 0],
}
pub type acl_t = *mut _acl;
pub type acl_entry_t = *mut _acl_entry;
pub type acl_permset_t = *mut _acl_permset;
pub type acl_flagset_t = *mut _acl_flagset;
pub type acl_permset_mask_t = u_int64_t;
extern "C" {
    pub fn acl_dup(acl: acl_t) -> acl_t;
}
extern "C" {
    pub fn acl_free(obj_p: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_init(count: ::std::os::raw::c_int) -> acl_t;
}
extern "C" {
    pub fn acl_copy_entry(
        dest_d: acl_entry_t,
        src_d: acl_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_create_entry(
        acl_p: *mut acl_t,
        entry_p: *mut acl_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_create_entry_np(
        acl_p: *mut acl_t,
        entry_p: *mut acl_entry_t,
        entry_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_entry(acl: acl_t, entry_d: acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_entry(
        acl: acl_t,
        entry_id: ::std::os::raw::c_int,
        entry_p: *mut acl_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid(acl: acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_fd_np(
        fd: ::std::os::raw::c_int,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_file_np(
        path: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_link_np(
        path: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_add_perm(
        permset_d: acl_permset_t,
        perm: acl_perm_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_calc_mask(acl_p: *mut acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_clear_perms(permset_d: acl_permset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_perm(
        permset_d: acl_permset_t,
        perm: acl_perm_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_perm_np(
        permset_d: acl_permset_t,
        perm: acl_perm_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_permset(
        entry_d: acl_entry_t,
        permset_p: *mut acl_permset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_permset(
        entry_d: acl_entry_t,
        permset_d: acl_permset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_maximal_permset_mask_np(
        mask_p: *mut acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_permset_mask_np(
        entry_d: acl_entry_t,
        mask_p: *mut acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_permset_mask_np(
        entry_d: acl_entry_t,
        mask: acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_add_flag_np(
        flagset_d: acl_flagset_t,
        flag: acl_flag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_clear_flags_np(flagset_d: acl_flagset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_flag_np(
        flagset_d: acl_flagset_t,
        flag: acl_flag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_flag_np(
        flagset_d: acl_flagset_t,
        flag: acl_flag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_flagset_np(
        obj_p: *mut ::std::os::raw::c_void,
        flagset_p: *mut acl_flagset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_flagset_np(
        obj_p: *mut ::std::os::raw::c_void,
        flagset_d: acl_flagset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_qualifier(entry_d: acl_entry_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn acl_get_tag_type(
        entry_d: acl_entry_t,
        tag_type_p: *mut acl_tag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_qualifier(
        entry_d: acl_entry_t,
        tag_qualifier_p: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_tag_type(
        entry_d: acl_entry_t,
        tag_type: acl_tag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_def_file(
        path_p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_fd(fd: ::std::os::raw::c_int) -> acl_t;
}
extern "C" {
    pub fn acl_get_fd_np(fd: ::std::os::raw::c_int, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_get_file(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
    ) -> acl_t;
}
extern "C" {
    pub fn acl_get_link_np(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
    ) -> acl_t;
}
extern "C" {
    pub fn acl_set_fd(fd: ::std::os::raw::c_int, acl: acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_fd_np(
        fd: ::std::os::raw::c_int,
        acl: acl_t,
        acl_type: acl_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_file(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_link_np(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_copy_ext(
        buf_p: *mut ::std::os::raw::c_void,
        acl: acl_t,
        size: isize,
    ) -> isize;
}
extern "C" {
    pub fn acl_copy_ext_native(
        buf_p: *mut ::std::os::raw::c_void,
        acl: acl_t,
        size: isize,
    ) -> isize;
}
extern "C" {
    pub fn acl_copy_int(buf_p: *const ::std::os::raw::c_void) -> acl_t;
}
extern "C" {
    pub fn acl_copy_int_native(buf_p: *const ::std::os::raw::c_void) -> acl_t;
}
extern "C" {
    pub fn acl_from_text(buf_p: *const ::std::os::raw::c_char) -> acl_t;
}
extern "C" {
    pub fn acl_size(acl: acl_t) -> isize;
}
extern "C" {
    pub fn acl_to_text(acl: acl_t, len_p: *mut isize) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFFileSecurity {
    _unused: [u8; 0],
}
pub type CFFileSecurityRef = *mut __CFFileSecurity;
extern "C" {
    pub fn CFFileSecurityGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFFileSecurityCreate(allocator: CFAllocatorRef) -> CFFileSecurityRef;
}
extern "C" {
    pub fn CFFileSecurityCreateCopy(
        allocator: CFAllocatorRef,
        fileSec: CFFileSecurityRef,
    ) -> CFFileSecurityRef;
}
extern "C" {
    pub fn CFFileSecurityCopyOwnerUUID(
        fileSec: CFFileSecurityRef,
        ownerUUID: *mut CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetOwnerUUID(
        fileSec: CFFileSecurityRef,
        ownerUUID: CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityCopyGroupUUID(
        fileSec: CFFileSecurityRef,
        groupUUID: *mut CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetGroupUUID(
        fileSec: CFFileSecurityRef,
        groupUUID: CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityCopyAccessControlList(
        fileSec: CFFileSecurityRef,
        accessControlList: *mut acl_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetAccessControlList(
        fileSec: CFFileSecurityRef,
        accessControlList: acl_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityGetOwner(
        fileSec: CFFileSecurityRef,
        owner: *mut uid_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetOwner(fileSec: CFFileSecurityRef, owner: uid_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityGetGroup(
        fileSec: CFFileSecurityRef,
        group: *mut gid_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetGroup(fileSec: CFFileSecurityRef, group: gid_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityGetMode(
        fileSec: CFFileSecurityRef,
        mode: *mut mode_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetMode(fileSec: CFFileSecurityRef, mode: mode_t) -> Boolean;
}
pub type CFFileSecurityClearOptions = CFOptionFlags;
pub const kCFFileSecurityClearOwner: _bindgen_ty_52 = 1;
pub const kCFFileSecurityClearGroup: _bindgen_ty_52 = 2;
pub const kCFFileSecurityClearMode: _bindgen_ty_52 = 4;
pub const kCFFileSecurityClearOwnerUUID: _bindgen_ty_52 = 8;
pub const kCFFileSecurityClearGroupUUID: _bindgen_ty_52 = 16;
pub const kCFFileSecurityClearAccessControlList: _bindgen_ty_52 = 32;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
extern "C" {
    pub fn CFFileSecurityClearProperties(
        fileSec: CFFileSecurityRef,
        clearPropertyMask: CFFileSecurityClearOptions,
    ) -> Boolean;
}
extern "C" {
    #[doc = "@function CFStringTokenizerCopyBestStringLanguage\n@abstract Guesses the language of a string and returns the BCP 47 string of the\nlanguage.\n@param string The string whose language is to be guessed.\n@param range The range of characters in string whose language to be\nguessed. The specified range must not exceed the bounds of the string.\n@result A language represented in BCP 47 string. NULL is returned either if\nstring is NULL, the location of range is negative, the length of range\nis 0, or the language of the string cannot be guessed.\n@discussion The result is not guaranteed to be accurate. Typically 200-400\ncharacters are required to reliably guess the language of a string."]
    pub fn CFStringTokenizerCopyBestStringLanguage(
        string: CFStringRef,
        range: CFRange,
    ) -> CFStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFStringTokenizer {
    _unused: [u8; 0],
}
pub type CFStringTokenizerRef = *mut __CFStringTokenizer;
#[doc = "Tokenization Unit\nUse one of tokenization unit options with CFStringTokenizerCreate to\nspecify how the string should be tokenized."]
pub const kCFStringTokenizerUnitWord: _bindgen_ty_53 = 0;
#[doc = "Tokenization Unit\nUse one of tokenization unit options with CFStringTokenizerCreate to\nspecify how the string should be tokenized."]
pub const kCFStringTokenizerUnitSentence: _bindgen_ty_53 = 1;
#[doc = "Tokenization Unit\nUse one of tokenization unit options with CFStringTokenizerCreate to\nspecify how the string should be tokenized."]
pub const kCFStringTokenizerUnitParagraph: _bindgen_ty_53 = 2;
#[doc = "Tokenization Unit\nUse one of tokenization unit options with CFStringTokenizerCreate to\nspecify how the string should be tokenized."]
pub const kCFStringTokenizerUnitLineBreak: _bindgen_ty_53 = 3;
#[doc = "Tokenization Unit\nUse one of tokenization unit options with CFStringTokenizerCreate to\nspecify how the string should be tokenized."]
pub const kCFStringTokenizerUnitWordBoundary: _bindgen_ty_53 = 4;
#[doc = "Attribute Specifier\nUse attribute specifier to tell tokenizer to prepare the specified attribute\nwhen it tokenizes the given string. The attribute value can be retrieved by\ncalling CFStringTokenizerCopyCurrentTokenAttribute with one of the attribute\noption."]
pub const kCFStringTokenizerAttributeLatinTranscription: _bindgen_ty_53 = 65536;
#[doc = "Attribute Specifier\nUse attribute specifier to tell tokenizer to prepare the specified attribute\nwhen it tokenizes the given string. The attribute value can be retrieved by\ncalling CFStringTokenizerCopyCurrentTokenAttribute with one of the attribute\noption."]
pub const kCFStringTokenizerAttributeLanguage: _bindgen_ty_53 = 131072;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
#[doc = "Token type\nCFStringTokenizerGoToTokenAtIndex / CFStringTokenizerAdvanceToNextToken returns\nthe type of current token."]
pub type CFStringTokenizerTokenType = CFOptionFlags;
pub const kCFStringTokenizerTokenNone: _bindgen_ty_54 = 0;
pub const kCFStringTokenizerTokenNormal: _bindgen_ty_54 = 1;
#[doc = "Compound token which may contain subtokens but with no derived subtokens.\nIts subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens."]
pub const kCFStringTokenizerTokenHasSubTokensMask: _bindgen_ty_54 = 2;
#[doc = "Compound token which may contain derived subtokens.\nIts subtokens and derived subtokens can be obtained by calling\nCFStringTokenizerGetCurrentSubTokens."]
pub const kCFStringTokenizerTokenHasDerivedSubTokensMask: _bindgen_ty_54 = 4;
#[doc = "Compound token which may contain derived subtokens.\nIts subtokens and derived subtokens can be obtained by calling\nCFStringTokenizerGetCurrentSubTokens."]
pub const kCFStringTokenizerTokenHasHasNumbersMask: _bindgen_ty_54 = 8;
#[doc = "Compound token which may contain derived subtokens.\nIts subtokens and derived subtokens can be obtained by calling\nCFStringTokenizerGetCurrentSubTokens."]
pub const kCFStringTokenizerTokenHasNonLettersMask: _bindgen_ty_54 = 16;
#[doc = "Compound token which may contain derived subtokens.\nIts subtokens and derived subtokens can be obtained by calling\nCFStringTokenizerGetCurrentSubTokens."]
pub const kCFStringTokenizerTokenIsCJWordMask: _bindgen_ty_54 = 32;
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "@function CFStringTokenizerGetTypeID\n@abstract Get the type identifier.\n@result the type identifier of all CFStringTokenizer instances."]
    pub fn CFStringTokenizerGetTypeID() -> CFTypeID;
}
extern "C" {
    #[doc = "@function CFStringTokenizerCreate\n@abstract Creates a tokenizer instance.\n@param alloc The CFAllocator which should be used to allocate memory for the\ntokenizer and its storage for values. This parameter may be NULL in which\ncase the current default CFAllocator is used.\n@param string The string to tokenize.\n@param range The range of characters within the string to be tokenized. The\nspecified range must not exceed the length of the string.\n@param options Use one of the Tokenization Unit options to specify how the\nstring should be tokenized. Optionally specify one or more attribute\nspecifiers to tell the tokenizer to prepare specified attributes when it\ntokenizes the string.\n@param locale The locale to specify language or region specific behavior. Pass\nNULL if you want tokenizer to identify the locale automatically.\n@result A reference to the new CFStringTokenizer."]
    pub fn CFStringTokenizerCreate(
        alloc: CFAllocatorRef,
        string: CFStringRef,
        range: CFRange,
        options: CFOptionFlags,
        locale: CFLocaleRef,
    ) -> CFStringTokenizerRef;
}
extern "C" {
    #[doc = "@function CFStringTokenizerSetString\n@abstract Set the string to tokenize.\n@param tokenizer The reference to CFStringTokenizer returned by\nCFStringTokenizerCreate.\n@param string The string to tokenize.\n@param range The range of characters within the string to be tokenized. The\nspecified range must not exceed the length of the string."]
    pub fn CFStringTokenizerSetString(
        tokenizer: CFStringTokenizerRef,
        string: CFStringRef,
        range: CFRange,
    );
}
extern "C" {
    #[doc = "@function CFStringTokenizerGoToTokenAtIndex\n@abstract Random access to a token. Find a token that includes the character specified\nby character index, and set it as the current token.\n@param tokenizer The reference to CFStringTokenizer returned by\nCFStringTokenizerCreate.\n@param index The index of the Unicode character in the CFString.\n@result Type of the token if succeeded in finding a token and setting it as\ncurrent token. kCFStringTokenizerTokenNone if failed in finding a token.\n@discussion The range and attribute of the token can be obtained by calling\nCFStringTokenizerGetCurrentTokenRange and CFStringTokenizerCopyCurrentTokenAttribute.\nIf the token is a compound (with type kCFStringTokenizerTokenHasSubTokensMask or\nkCFStringTokenizerTokenHasDerivedSubTokensMask), its subtokens and\n(or) derived subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens."]
    pub fn CFStringTokenizerGoToTokenAtIndex(
        tokenizer: CFStringTokenizerRef,
        index: CFIndex,
    ) -> CFStringTokenizerTokenType;
}
extern "C" {
    #[doc = "@function CFStringTokenizerAdvanceToNextToken\n@abstract Token enumerator.\n@param tokenizer The reference to CFStringTokenizer returned by\nCFStringTokenizerCreate.\n@result Type of the token if succeeded in finding a token and setting it as\ncurrent token. kCFStringTokenizerTokenNone if failed in finding a token.\n@discussion If there is no preceding call to CFStringTokenizerGoToTokenAtIndex\nor CFStringTokenizerAdvanceToNextToken, it finds the first token in the range\nspecified to CFStringTokenizerCreate. If there is a current token after successful\ncall to CFStringTokenizerGoToTokenAtIndex or CFStringTokenizerAdvanceToNextToken,\nit proceeds to the next token. If succeeded in finding a token, set it as current\ntoken and return its token type. Otherwise invalidate current token and return\nkCFStringTokenizerTokenNone.\nThe range and attribute of the token can be obtained by calling\nCFStringTokenizerGetCurrentTokenRange and\nCFStringTokenizerCopyCurrentTokenAttribute. If the token is a compound\n(with type kCFStringTokenizerTokenHasSubTokensMask or\nkCFStringTokenizerTokenHasDerivedSubTokensMask), its subtokens and\n(or) derived subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens."]
    pub fn CFStringTokenizerAdvanceToNextToken(
        tokenizer: CFStringTokenizerRef,
    ) -> CFStringTokenizerTokenType;
}
extern "C" {
    #[doc = "@function CFStringTokenizerGetCurrentTokenRange\n@abstract Returns the range of current token.\n@param tokenizer The reference to CFStringTokenizer returned by\nCFStringTokenizerCreate.\n@result Range of current token, or {kCFNotFound,0} if there is no current token."]
    pub fn CFStringTokenizerGetCurrentTokenRange(
        tokenizer: CFStringTokenizerRef,
    ) -> CFRange;
}
extern "C" {
    #[doc = "@function CFStringTokenizerCopyCurrentTokenAttribute\n@abstract Copies the specified attribute of current token.\n@param tokenizer The reference to CFStringTokenizer returned by\nCFStringTokenizerCreate.\n@param attribute Specify a token attribute you want to obtain. The value is\none of kCFStringTokenizerAttributeLatinTranscription or\nkCFStringTokenizerAttributeLanguage.\n@result Token attribute, or NULL if current token does not have the specified\nattribute or if there is no current token."]
    pub fn CFStringTokenizerCopyCurrentTokenAttribute(
        tokenizer: CFStringTokenizerRef,
        attribute: CFOptionFlags,
    ) -> CFTypeRef;
}
extern "C" {
    #[doc = "@function CFStringTokenizerGetCurrentSubTokens\n@abstract Retrieves the subtokens or derived subtokens contained in the compound token.\n@param tokenizer The reference to CFStringTokenizer returned by CFStringTokenizerCreate.\n@param ranges An array of CFRange to fill in with the ranges of subtokens. The filled in\nranges are relative to the string specified to CFStringTokenizerCreate. This parameter\ncan be NULL.\n@param maxRangeLength The maximum number of ranges to return.\n@param derivedSubTokens An array of CFMutableArray to which the derived subtokens are to\nbe added. This parameter can be NULL.\n@result number of subtokens.\n@discussion If token type is kCFStringTokenizerTokenNone, the ranges array and\nderivedSubTokens array are untouched and the return value is 0.\nIf token type is kCFStringTokenizerTokenNormal, the ranges array has one item\nfilled in with the entire range of the token (if maxRangeLength >= 1) and a string\ntaken from the entire token range is added to the derivedSubTokens array and the\nreturn value is 1.\nIf token type is kCFStringTokenizerTokenHasSubTokensMask or\nkCFStringTokenizerTokenHasDerivedSubTokensMask, the ranges array is filled\nin with as many items as there are subtokens (up to a limit of maxRangeLength).\nThe derivedSubTokens array will have sub tokens added even when the sub token is a\nsubstring of the token. If token type is kCFStringTokenizerTokenHasSubTokensMask,\nthe ordinary non-derived subtokens are added to the derivedSubTokens array."]
    pub fn CFStringTokenizerGetCurrentSubTokens(
        tokenizer: CFStringTokenizerRef,
        ranges: *mut CFRange,
        maxRangeLength: CFIndex,
        derivedSubTokens: CFMutableArrayRef,
    ) -> CFIndex;
}
pub type CFFileDescriptorNativeDescriptor = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFFileDescriptor {
    _unused: [u8; 0],
}
pub type CFFileDescriptorRef = *mut __CFFileDescriptor;
pub const kCFFileDescriptorReadCallBack: _bindgen_ty_55 = 1;
pub const kCFFileDescriptorWriteCallBack: _bindgen_ty_55 = 2;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub type CFFileDescriptorCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        f: CFFileDescriptorRef,
        callBackTypes: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFFileDescriptorContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFFileDescriptorContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFFileDescriptorContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFFileDescriptorContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFFileDescriptorContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFFileDescriptorContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFFileDescriptorContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
extern "C" {
    pub fn CFFileDescriptorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFFileDescriptorCreate(
        allocator: CFAllocatorRef,
        fd: CFFileDescriptorNativeDescriptor,
        closeOnInvalidate: Boolean,
        callout: CFFileDescriptorCallBack,
        context: *const CFFileDescriptorContext,
    ) -> CFFileDescriptorRef;
}
extern "C" {
    pub fn CFFileDescriptorGetNativeDescriptor(
        f: CFFileDescriptorRef,
    ) -> CFFileDescriptorNativeDescriptor;
}
extern "C" {
    pub fn CFFileDescriptorGetContext(
        f: CFFileDescriptorRef,
        context: *mut CFFileDescriptorContext,
    );
}
extern "C" {
    pub fn CFFileDescriptorEnableCallBacks(
        f: CFFileDescriptorRef,
        callBackTypes: CFOptionFlags,
    );
}
extern "C" {
    pub fn CFFileDescriptorDisableCallBacks(
        f: CFFileDescriptorRef,
        callBackTypes: CFOptionFlags,
    );
}
extern "C" {
    pub fn CFFileDescriptorInvalidate(f: CFFileDescriptorRef);
}
extern "C" {
    pub fn CFFileDescriptorIsValid(f: CFFileDescriptorRef) -> Boolean;
}
extern "C" {
    pub fn CFFileDescriptorCreateRunLoopSource(
        allocator: CFAllocatorRef,
        f: CFFileDescriptorRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFUserNotification {
    _unused: [u8; 0],
}
pub type CFUserNotificationRef = *mut __CFUserNotification;
pub type CFUserNotificationCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        userNotification: CFUserNotificationRef,
        responseFlags: CFOptionFlags,
    ),
>;
extern "C" {
    pub fn CFUserNotificationGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFUserNotificationCreate(
        allocator: CFAllocatorRef,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        error: *mut SInt32,
        dictionary: CFDictionaryRef,
    ) -> CFUserNotificationRef;
}
extern "C" {
    pub fn CFUserNotificationReceiveResponse(
        userNotification: CFUserNotificationRef,
        timeout: CFTimeInterval,
        responseFlags: *mut CFOptionFlags,
    ) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationGetResponseValue(
        userNotification: CFUserNotificationRef,
        key: CFStringRef,
        idx: CFIndex,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFUserNotificationGetResponseDictionary(
        userNotification: CFUserNotificationRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFUserNotificationUpdate(
        userNotification: CFUserNotificationRef,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        dictionary: CFDictionaryRef,
    ) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationCancel(userNotification: CFUserNotificationRef) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationCreateRunLoopSource(
        allocator: CFAllocatorRef,
        userNotification: CFUserNotificationRef,
        callout: CFUserNotificationCallBack,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFUserNotificationDisplayNotice(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        iconURL: CFURLRef,
        soundURL: CFURLRef,
        localizationURL: CFURLRef,
        alertHeader: CFStringRef,
        alertMessage: CFStringRef,
        defaultButtonTitle: CFStringRef,
    ) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationDisplayAlert(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        iconURL: CFURLRef,
        soundURL: CFURLRef,
        localizationURL: CFURLRef,
        alertHeader: CFStringRef,
        alertMessage: CFStringRef,
        defaultButtonTitle: CFStringRef,
        alternateButtonTitle: CFStringRef,
        otherButtonTitle: CFStringRef,
        responseFlags: *mut CFOptionFlags,
    ) -> SInt32;
}
pub const kCFUserNotificationStopAlertLevel: _bindgen_ty_56 = 0;
pub const kCFUserNotificationNoteAlertLevel: _bindgen_ty_56 = 1;
pub const kCFUserNotificationCautionAlertLevel: _bindgen_ty_56 = 2;
pub const kCFUserNotificationPlainAlertLevel: _bindgen_ty_56 = 3;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const kCFUserNotificationDefaultResponse: _bindgen_ty_57 = 0;
pub const kCFUserNotificationAlternateResponse: _bindgen_ty_57 = 1;
pub const kCFUserNotificationOtherResponse: _bindgen_ty_57 = 2;
pub const kCFUserNotificationCancelResponse: _bindgen_ty_57 = 3;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const kCFUserNotificationNoDefaultButtonFlag: _bindgen_ty_58 = 32;
pub const kCFUserNotificationUseRadioButtonsFlag: _bindgen_ty_58 = 64;
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
extern "C" {
    pub static kCFUserNotificationIconURLKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationSoundURLKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationLocalizationURLKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlertHeaderKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlertMessageKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationDefaultButtonTitleKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlternateButtonTitleKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationOtherButtonTitleKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationProgressIndicatorValueKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationPopUpTitlesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationTextFieldTitlesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationCheckBoxTitlesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationTextFieldValuesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationPopUpSelectionKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlertTopMostKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationKeyboardTypesKey: CFStringRef;
}
pub const kCFXMLNodeCurrentVersion: _bindgen_ty_59 = 1;
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFXMLNode {
    _unused: [u8; 0],
}
pub type CFXMLNodeRef = *const __CFXMLNode;
pub type CFXMLTreeRef = CFTreeRef;
pub type CFXMLNodeTypeCode = CFIndex;
pub const kCFXMLNodeTypeDocument: _bindgen_ty_60 = 1;
pub const kCFXMLNodeTypeElement: _bindgen_ty_60 = 2;
pub const kCFXMLNodeTypeAttribute: _bindgen_ty_60 = 3;
pub const kCFXMLNodeTypeProcessingInstruction: _bindgen_ty_60 = 4;
pub const kCFXMLNodeTypeComment: _bindgen_ty_60 = 5;
pub const kCFXMLNodeTypeText: _bindgen_ty_60 = 6;
pub const kCFXMLNodeTypeCDATASection: _bindgen_ty_60 = 7;
pub const kCFXMLNodeTypeDocumentFragment: _bindgen_ty_60 = 8;
pub const kCFXMLNodeTypeEntity: _bindgen_ty_60 = 9;
pub const kCFXMLNodeTypeEntityReference: _bindgen_ty_60 = 10;
pub const kCFXMLNodeTypeDocumentType: _bindgen_ty_60 = 11;
pub const kCFXMLNodeTypeWhitespace: _bindgen_ty_60 = 12;
pub const kCFXMLNodeTypeNotation: _bindgen_ty_60 = 13;
pub const kCFXMLNodeTypeElementTypeDeclaration: _bindgen_ty_60 = 14;
pub const kCFXMLNodeTypeAttributeListDeclaration: _bindgen_ty_60 = 15;
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLElementInfo {
    pub attributes: CFDictionaryRef,
    pub attributeOrder: CFArrayRef,
    pub isEmpty: Boolean,
    pub _reserved: [::std::os::raw::c_char; 3usize],
}
#[test]
fn bindgen_test_layout_CFXMLElementInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLElementInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLElementInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CFXMLElementInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLElementInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLElementInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributeOrder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(attributeOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isEmpty) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(isEmpty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(_reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLProcessingInstructionInfo {
    pub dataString: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLProcessingInstructionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLProcessingInstructionInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLProcessingInstructionInfo>(),
        8usize,
        concat!("Size of: ", stringify!(CFXMLProcessingInstructionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLProcessingInstructionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLProcessingInstructionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLProcessingInstructionInfo),
            "::",
            stringify!(dataString)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLDocumentInfo {
    pub sourceURL: CFURLRef,
    pub encoding: CFStringEncoding,
}
#[test]
fn bindgen_test_layout_CFXMLDocumentInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLDocumentInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLDocumentInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLDocumentInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLDocumentInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLDocumentInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLDocumentInfo),
            "::",
            stringify!(sourceURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLDocumentInfo),
            "::",
            stringify!(encoding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLExternalID {
    pub systemID: CFURLRef,
    pub publicID: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLExternalID() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLExternalID> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLExternalID>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLExternalID))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLExternalID>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLExternalID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).systemID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLExternalID),
            "::",
            stringify!(systemID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publicID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLExternalID),
            "::",
            stringify!(publicID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLDocumentTypeInfo {
    pub externalID: CFXMLExternalID,
}
#[test]
fn bindgen_test_layout_CFXMLDocumentTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLDocumentTypeInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLDocumentTypeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLDocumentTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLDocumentTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLDocumentTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).externalID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLDocumentTypeInfo),
            "::",
            stringify!(externalID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLNotationInfo {
    pub externalID: CFXMLExternalID,
}
#[test]
fn bindgen_test_layout_CFXMLNotationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLNotationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLNotationInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLNotationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLNotationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLNotationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).externalID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLNotationInfo),
            "::",
            stringify!(externalID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLElementTypeDeclarationInfo {
    pub contentDescription: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLElementTypeDeclarationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLElementTypeDeclarationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLElementTypeDeclarationInfo>(),
        8usize,
        concat!("Size of: ", stringify!(CFXMLElementTypeDeclarationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLElementTypeDeclarationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLElementTypeDeclarationInfo))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).contentDescription) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementTypeDeclarationInfo),
            "::",
            stringify!(contentDescription)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLAttributeDeclarationInfo {
    pub attributeName: CFStringRef,
    pub typeString: CFStringRef,
    pub defaultString: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLAttributeDeclarationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLAttributeDeclarationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLAttributeDeclarationInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CFXMLAttributeDeclarationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLAttributeDeclarationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLAttributeDeclarationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributeName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeDeclarationInfo),
            "::",
            stringify!(attributeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeString) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeDeclarationInfo),
            "::",
            stringify!(typeString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultString) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeDeclarationInfo),
            "::",
            stringify!(defaultString)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLAttributeListDeclarationInfo {
    pub numberOfAttributes: CFIndex,
    pub attributes: *mut CFXMLAttributeDeclarationInfo,
}
#[test]
fn bindgen_test_layout_CFXMLAttributeListDeclarationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLAttributeListDeclarationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLAttributeListDeclarationInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLAttributeListDeclarationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLAttributeListDeclarationInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CFXMLAttributeListDeclarationInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).numberOfAttributes) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeListDeclarationInfo),
            "::",
            stringify!(numberOfAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeListDeclarationInfo),
            "::",
            stringify!(attributes)
        )
    );
}
pub type CFXMLEntityTypeCode = CFIndex;
pub const kCFXMLEntityTypeParameter: _bindgen_ty_61 = 0;
pub const kCFXMLEntityTypeParsedInternal: _bindgen_ty_61 = 1;
pub const kCFXMLEntityTypeParsedExternal: _bindgen_ty_61 = 2;
pub const kCFXMLEntityTypeUnparsed: _bindgen_ty_61 = 3;
pub const kCFXMLEntityTypeCharacter: _bindgen_ty_61 = 4;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLEntityInfo {
    pub entityType: CFXMLEntityTypeCode,
    pub replacementText: CFStringRef,
    pub entityID: CFXMLExternalID,
    pub notationName: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLEntityInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLEntityInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLEntityInfo>(),
        40usize,
        concat!("Size of: ", stringify!(CFXMLEntityInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLEntityInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLEntityInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entityType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(entityType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replacementText) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(replacementText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entityID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(entityID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notationName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(notationName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLEntityReferenceInfo {
    pub entityType: CFXMLEntityTypeCode,
}
#[test]
fn bindgen_test_layout_CFXMLEntityReferenceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLEntityReferenceInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLEntityReferenceInfo>(),
        8usize,
        concat!("Size of: ", stringify!(CFXMLEntityReferenceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLEntityReferenceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLEntityReferenceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entityType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityReferenceInfo),
            "::",
            stringify!(entityType)
        )
    );
}
extern "C" {
    pub fn CFXMLNodeGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFXMLNodeCreate(
        alloc: CFAllocatorRef,
        xmlType: CFXMLNodeTypeCode,
        dataString: CFStringRef,
        additionalInfoPtr: *const ::std::os::raw::c_void,
        version: CFIndex,
    ) -> CFXMLNodeRef;
}
extern "C" {
    pub fn CFXMLNodeCreateCopy(
        alloc: CFAllocatorRef,
        origNode: CFXMLNodeRef,
    ) -> CFXMLNodeRef;
}
extern "C" {
    pub fn CFXMLNodeGetTypeCode(node: CFXMLNodeRef) -> CFXMLNodeTypeCode;
}
extern "C" {
    pub fn CFXMLNodeGetString(node: CFXMLNodeRef) -> CFStringRef;
}
extern "C" {
    pub fn CFXMLNodeGetInfoPtr(node: CFXMLNodeRef) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFXMLNodeGetVersion(node: CFXMLNodeRef) -> CFIndex;
}
extern "C" {
    pub fn CFXMLTreeCreateWithNode(
        allocator: CFAllocatorRef,
        node: CFXMLNodeRef,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeGetNode(xmlTree: CFXMLTreeRef) -> CFXMLNodeRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFXMLParser {
    _unused: [u8; 0],
}
pub type CFXMLParserRef = *mut __CFXMLParser;
pub type CFXMLParserOptions = CFOptionFlags;
pub const kCFXMLParserValidateDocument: _bindgen_ty_62 = 1;
pub const kCFXMLParserSkipMetaData: _bindgen_ty_62 = 2;
pub const kCFXMLParserReplacePhysicalEntities: _bindgen_ty_62 = 4;
pub const kCFXMLParserSkipWhitespace: _bindgen_ty_62 = 8;
pub const kCFXMLParserResolveExternalEntities: _bindgen_ty_62 = 16;
pub const kCFXMLParserAddImpliedAttributes: _bindgen_ty_62 = 32;
pub const kCFXMLParserAllOptions: _bindgen_ty_62 = 16777215;
pub const kCFXMLParserNoOptions: _bindgen_ty_62 = 0;
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
pub type CFXMLParserStatusCode = CFIndex;
pub const kCFXMLStatusParseNotBegun: _bindgen_ty_63 = -2;
pub const kCFXMLStatusParseInProgress: _bindgen_ty_63 = -1;
pub const kCFXMLStatusParseSuccessful: _bindgen_ty_63 = 0;
pub const kCFXMLErrorUnexpectedEOF: _bindgen_ty_63 = 1;
pub const kCFXMLErrorUnknownEncoding: _bindgen_ty_63 = 2;
pub const kCFXMLErrorEncodingConversionFailure: _bindgen_ty_63 = 3;
pub const kCFXMLErrorMalformedProcessingInstruction: _bindgen_ty_63 = 4;
pub const kCFXMLErrorMalformedDTD: _bindgen_ty_63 = 5;
pub const kCFXMLErrorMalformedName: _bindgen_ty_63 = 6;
pub const kCFXMLErrorMalformedCDSect: _bindgen_ty_63 = 7;
pub const kCFXMLErrorMalformedCloseTag: _bindgen_ty_63 = 8;
pub const kCFXMLErrorMalformedStartTag: _bindgen_ty_63 = 9;
pub const kCFXMLErrorMalformedDocument: _bindgen_ty_63 = 10;
pub const kCFXMLErrorElementlessDocument: _bindgen_ty_63 = 11;
pub const kCFXMLErrorMalformedComment: _bindgen_ty_63 = 12;
pub const kCFXMLErrorMalformedCharacterReference: _bindgen_ty_63 = 13;
pub const kCFXMLErrorMalformedParsedCharacterData: _bindgen_ty_63 = 14;
pub const kCFXMLErrorNoData: _bindgen_ty_63 = 15;
pub type _bindgen_ty_63 = ::std::os::raw::c_int;
pub type CFXMLParserCreateXMLStructureCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        nodeDesc: CFXMLNodeRef,
        info: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CFXMLParserAddChildCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        parent: *mut ::std::os::raw::c_void,
        child: *mut ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFXMLParserEndXMLStructureCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        xmlType: *mut ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFXMLParserResolveExternalEntityCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        extID: *mut CFXMLExternalID,
        info: *mut ::std::os::raw::c_void,
    ) -> CFDataRef,
>;
pub type CFXMLParserHandleErrorCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        error: CFXMLParserStatusCode,
        info: *mut ::std::os::raw::c_void,
    ) -> Boolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLParserCallBacks {
    pub version: CFIndex,
    pub createXMLStructure: CFXMLParserCreateXMLStructureCallBack,
    pub addChild: CFXMLParserAddChildCallBack,
    pub endXMLStructure: CFXMLParserEndXMLStructureCallBack,
    pub resolveExternalEntity: CFXMLParserResolveExternalEntityCallBack,
    pub handleError: CFXMLParserHandleErrorCallBack,
}
#[test]
fn bindgen_test_layout_CFXMLParserCallBacks() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLParserCallBacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLParserCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFXMLParserCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLParserCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLParserCallBacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).createXMLStructure) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(createXMLStructure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addChild) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(addChild)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endXMLStructure) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(endXMLStructure)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).resolveExternalEntity) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(resolveExternalEntity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleError) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(handleError)
        )
    );
}
pub type CFXMLParserRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFXMLParserReleaseCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>;
pub type CFXMLParserCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLParserContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: CFXMLParserRetainCallBack,
    pub release: CFXMLParserReleaseCallBack,
    pub copyDescription: CFXMLParserCopyDescriptionCallBack,
}
#[test]
fn bindgen_test_layout_CFXMLParserContext() {
    const UNINIT: ::std::mem::MaybeUninit<CFXMLParserContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CFXMLParserContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFXMLParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLParserContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
extern "C" {
    pub fn CFXMLParserGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFXMLParserCreate(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
        callBacks: *mut CFXMLParserCallBacks,
        context: *mut CFXMLParserContext,
    ) -> CFXMLParserRef;
}
extern "C" {
    pub fn CFXMLParserCreateWithDataFromURL(
        allocator: CFAllocatorRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
        callBacks: *mut CFXMLParserCallBacks,
        context: *mut CFXMLParserContext,
    ) -> CFXMLParserRef;
}
extern "C" {
    pub fn CFXMLParserGetContext(
        parser: CFXMLParserRef,
        context: *mut CFXMLParserContext,
    );
}
extern "C" {
    pub fn CFXMLParserGetCallBacks(
        parser: CFXMLParserRef,
        callBacks: *mut CFXMLParserCallBacks,
    );
}
extern "C" {
    pub fn CFXMLParserGetSourceURL(parser: CFXMLParserRef) -> CFURLRef;
}
extern "C" {
    pub fn CFXMLParserGetLocation(parser: CFXMLParserRef) -> CFIndex;
}
extern "C" {
    pub fn CFXMLParserGetLineNumber(parser: CFXMLParserRef) -> CFIndex;
}
extern "C" {
    pub fn CFXMLParserGetDocument(parser: CFXMLParserRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFXMLParserGetStatusCode(parser: CFXMLParserRef) -> CFXMLParserStatusCode;
}
extern "C" {
    pub fn CFXMLParserCopyErrorDescription(parser: CFXMLParserRef) -> CFStringRef;
}
extern "C" {
    pub fn CFXMLParserAbort(
        parser: CFXMLParserRef,
        errorCode: CFXMLParserStatusCode,
        errorDescription: CFStringRef,
    );
}
extern "C" {
    pub fn CFXMLParserParse(parser: CFXMLParserRef) -> Boolean;
}
extern "C" {
    pub fn CFXMLTreeCreateFromData(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeCreateFromDataWithError(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
        errorDict: *mut CFDictionaryRef,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeCreateWithDataFromURL(
        allocator: CFAllocatorRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeCreateXMLData(
        allocator: CFAllocatorRef,
        xmlTree: CFXMLTreeRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFXMLCreateStringByEscapingEntities(
        allocator: CFAllocatorRef,
        string: CFStringRef,
        entitiesDictionary: CFDictionaryRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFXMLCreateStringByUnescapingEntities(
        allocator: CFAllocatorRef,
        string: CFStringRef,
        entitiesDictionary: CFDictionaryRef,
    ) -> CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorDescription: CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorLineNumber: CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorLocation: CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorStatusCode: CFStringRef;
}
pub const JSType_kJSTypeUndefined: JSType = 0;
pub const JSType_kJSTypeNull: JSType = 1;
pub const JSType_kJSTypeBoolean: JSType = 2;
pub const JSType_kJSTypeNumber: JSType = 3;
pub const JSType_kJSTypeString: JSType = 4;
pub const JSType_kJSTypeObject: JSType = 5;
pub const JSType_kJSTypeSymbol: JSType = 6;
#[doc = "@enum JSType\n@abstract     A constant identifying the type of a JSValue.\n@constant     kJSTypeUndefined  The unique undefined value.\n@constant     kJSTypeNull       The unique null value.\n@constant     kJSTypeBoolean    A primitive boolean value, one of true or false.\n@constant     kJSTypeNumber     A primitive number value.\n@constant     kJSTypeString     A primitive string value.\n@constant     kJSTypeObject     An object value (meaning that this JSValueRef is a JSObjectRef).\n@constant     kJSTypeSymbol     A primitive symbol value."]
pub type JSType = ::std::os::raw::c_uint;
pub const JSTypedArrayType_kJSTypedArrayTypeInt8Array: JSTypedArrayType = 0;
pub const JSTypedArrayType_kJSTypedArrayTypeInt16Array: JSTypedArrayType = 1;
pub const JSTypedArrayType_kJSTypedArrayTypeInt32Array: JSTypedArrayType = 2;
pub const JSTypedArrayType_kJSTypedArrayTypeUint8Array: JSTypedArrayType = 3;
pub const JSTypedArrayType_kJSTypedArrayTypeUint8ClampedArray: JSTypedArrayType = 4;
pub const JSTypedArrayType_kJSTypedArrayTypeUint16Array: JSTypedArrayType = 5;
pub const JSTypedArrayType_kJSTypedArrayTypeUint32Array: JSTypedArrayType = 6;
pub const JSTypedArrayType_kJSTypedArrayTypeFloat32Array: JSTypedArrayType = 7;
pub const JSTypedArrayType_kJSTypedArrayTypeFloat64Array: JSTypedArrayType = 8;
pub const JSTypedArrayType_kJSTypedArrayTypeArrayBuffer: JSTypedArrayType = 9;
pub const JSTypedArrayType_kJSTypedArrayTypeNone: JSTypedArrayType = 10;
pub const JSTypedArrayType_kJSTypedArrayTypeBigInt64Array: JSTypedArrayType = 11;
pub const JSTypedArrayType_kJSTypedArrayTypeBigUint64Array: JSTypedArrayType = 12;
#[doc = "@enum JSTypedArrayType\n@abstract     A constant identifying the Typed Array type of a JSObjectRef.\n@constant     kJSTypedArrayTypeInt8Array            Int8Array\n@constant     kJSTypedArrayTypeInt16Array           Int16Array\n@constant     kJSTypedArrayTypeInt32Array           Int32Array\n@constant     kJSTypedArrayTypeUint8Array           Uint8Array\n@constant     kJSTypedArrayTypeUint8ClampedArray    Uint8ClampedArray\n@constant     kJSTypedArrayTypeUint16Array          Uint16Array\n@constant     kJSTypedArrayTypeUint32Array          Uint32Array\n@constant     kJSTypedArrayTypeFloat32Array         Float32Array\n@constant     kJSTypedArrayTypeFloat64Array         Float64Array\n@constant     kJSTypedArrayTypeBigInt64Array        BigInt64Array\n@constant     kJSTypedArrayTypeBigUint64Array       BigUint64Array\n@constant     kJSTypedArrayTypeArrayBuffer          ArrayBuffer\n@constant     kJSTypedArrayTypeNone                 Not a Typed Array\n"]
pub type JSTypedArrayType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "@function\n@abstract       Returns a JavaScript value's type.\n@param ctx  The execution context to use.\n@param value    The JSValue whose type you want to obtain.\n@result         A value of type JSType that identifies value's type."]
    pub fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the undefined type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the undefined type, otherwise false."]
    pub fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the null type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the null type, otherwise false."]
    pub fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the boolean type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the boolean type, otherwise false."]
    pub fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the number type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the number type, otherwise false."]
    pub fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the string type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the string type, otherwise false."]
    pub fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the symbol type.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the symbol type, otherwise false."]
    pub fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the object type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the object type, otherwise false."]
    pub fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether a JavaScript value is an object with a given class in its class chain.\n@param ctx The execution context to use.\n@param value The JSValue to test.\n@param jsClass The JSClass to test against.\n@result true if value is an object and has jsClass in its class chain, otherwise false."]
    pub fn JSValueIsObjectOfClass(
        ctx: JSContextRef,
        value: JSValueRef,
        jsClass: JSClassRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value is an array.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value is an array, otherwise false."]
    pub fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value is a date.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value is a date, otherwise false."]
    pub fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns a JavaScript value's Typed Array type.\n@param ctx          The execution context to use.\n@param value        The JSValue whose Typed Array type to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A value of type JSTypedArrayType that identifies value's Typed Array type, or kJSTypedArrayTypeNone if the value is not a Typed Array object."]
    pub fn JSValueGetTypedArrayType(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether two JavaScript values are equal, as compared by the JS == operator.\n@param ctx The execution context to use.\n@param a The first value to test.\n@param b The second value to test.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the two values are equal, false if they are not equal or an exception is thrown."]
    pub fn JSValueIsEqual(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether two JavaScript values are strict equal, as compared by the JS === operator.\n@param ctx  The execution context to use.\n@param a        The first value to test.\n@param b        The second value to test.\n@result         true if the two values are strict equal, otherwise false."]
    pub fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether a JavaScript value is an object constructed by a given constructor, as compared by the JS instanceof operator.\n@param ctx The execution context to use.\n@param value The JSValue to test.\n@param constructor The constructor to test against.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if value is an object constructed by constructor, as compared by the JS instanceof operator, otherwise false."]
    pub fn JSValueIsInstanceOfConstructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the undefined type.\n@param ctx  The execution context to use.\n@result         The unique undefined value."]
    pub fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the null type.\n@param ctx  The execution context to use.\n@result         The unique null value."]
    pub fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the boolean type.\n@param ctx  The execution context to use.\n@param boolean  The bool to assign to the newly created JSValue.\n@result         A JSValue of the boolean type, representing the value of boolean."]
    pub fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the number type.\n@param ctx  The execution context to use.\n@param number   The double to assign to the newly created JSValue.\n@result         A JSValue of the number type, representing the value of number."]
    pub fn JSValueMakeNumber(ctx: JSContextRef, number: f64) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the string type.\n@param ctx  The execution context to use.\n@param string   The JSString to assign to the newly created JSValue. The\nnewly created JSValue retains string, and releases it upon garbage collection.\n@result         A JSValue of the string type, representing the value of string."]
    pub fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract            Creates a JavaScript value of the symbol type.\n@param ctx           The execution context to use.\n@param description   A description of the newly created symbol value.\n@result              A unique JSValue of the symbol type, whose description matches the one provided."]
    pub fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value from a JSON formatted string.\n@param ctx      The execution context to use.\n@param string   The JSString containing the JSON string to be parsed.\n@result         A JSValue containing the parsed value, or NULL if the input is invalid."]
    pub fn JSValueMakeFromJSONString(
        ctx: JSContextRef,
        string: JSStringRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript string containing the JSON serialized representation of a JS value.\n@param ctx      The execution context to use.\n@param value    The value to serialize.\n@param indent   The number of spaces to indent when nesting.  If 0, the resulting JSON will not contains newlines.  The size of the indent is clamped to 10 spaces.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         A JSString with the result of serialization, or NULL if an exception is thrown."]
    pub fn JSValueCreateJSONString(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Converts a JavaScript value to boolean and returns the resulting boolean.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@result         The boolean result of conversion."]
    pub fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Converts a JavaScript value to number and returns the resulting number.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         The numeric result of conversion, or NaN if an exception is thrown."]
    pub fn JSValueToNumber(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> f64;
}
extern "C" {
    #[doc = "@function\n@abstract       Converts a JavaScript value to string and copies the result into a JavaScript string.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         A JSString with the result of conversion, or NULL if an exception is thrown. Ownership follows the Create Rule."]
    pub fn JSValueToStringCopy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract Converts a JavaScript value to object and returns the resulting object.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         The JSObject result of conversion, or NULL if an exception is thrown."]
    pub fn JSValueToObject(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Protects a JavaScript value from garbage collection.\n@param ctx The execution context to use.\n@param value The JSValue to protect.\n@discussion Use this method when you want to store a JSValue in a global or on the heap, where the garbage collector will not be able to discover your reference to it.\n\nA value may be protected multiple times and must be unprotected an equal number of times before becoming eligible for garbage collection."]
    pub fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
}
extern "C" {
    #[doc = "@function\n@abstract       Unprotects a JavaScript value from garbage collection.\n@param ctx      The execution context to use.\n@param value    The JSValue to unprotect.\n@discussion     A value may be protected multiple times and must be unprotected an\nequal number of times before becoming eligible for garbage collection."]
    pub fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
}
pub const kJSPropertyAttributeNone: _bindgen_ty_64 = 0;
pub const kJSPropertyAttributeReadOnly: _bindgen_ty_64 = 2;
pub const kJSPropertyAttributeDontEnum: _bindgen_ty_64 = 4;
pub const kJSPropertyAttributeDontDelete: _bindgen_ty_64 = 8;
#[doc = "@enum JSPropertyAttribute\n@constant kJSPropertyAttributeNone         Specifies that a property has no special attributes.\n@constant kJSPropertyAttributeReadOnly     Specifies that a property is read-only.\n@constant kJSPropertyAttributeDontEnum     Specifies that a property should not be enumerated by JSPropertyEnumerators and JavaScript for...in loops.\n@constant kJSPropertyAttributeDontDelete   Specifies that the delete operation should fail on a property."]
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
#[doc = "@typedef JSPropertyAttributes\n@abstract A set of JSPropertyAttributes. Combine multiple attributes by logically ORing them together."]
pub type JSPropertyAttributes = ::std::os::raw::c_uint;
pub const kJSClassAttributeNone: _bindgen_ty_65 = 0;
pub const kJSClassAttributeNoAutomaticPrototype: _bindgen_ty_65 = 2;
#[doc = "@enum JSClassAttribute\n@constant kJSClassAttributeNone Specifies that a class has no special attributes.\n@constant kJSClassAttributeNoAutomaticPrototype Specifies that a class should not automatically generate a shared prototype for its instance objects. Use kJSClassAttributeNoAutomaticPrototype in combination with JSObjectSetPrototype to manage prototypes manually."]
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
#[doc = "@typedef JSClassAttributes\n@abstract A set of JSClassAttributes. Combine multiple attributes by logically ORing them together."]
pub type JSClassAttributes = ::std::os::raw::c_uint;
#[doc = "@typedef JSObjectInitializeCallback\n@abstract The callback invoked when an object is first created.\n@param ctx The execution context to use.\n@param object The JSObject being created.\n@discussion If you named your function Initialize, you would declare it like this:\n\nvoid Initialize(JSContextRef ctx, JSObjectRef object);\n\nUnlike the other object callbacks, the initialize callback is called on the least\nderived class (the parent class) first, and the most derived class last."]
pub type JSObjectInitializeCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef)>;
#[doc = "@typedef InspectorMessageCallback\n@abstract The callback invoked when an inspector message is received.\n@param message The message received from the inspector.\n@discussion If you named your function InspectorMessage, you would declare it like this:\n\nvoid InspectorMessage(const char* message);\n\nThis callback is called when a message is received from the inspector."]
pub type InspectorMessageCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;

#[doc = "@typedef JSObjectFinalizeCallback\n@abstract The callback invoked when an object is finalized (prepared for garbage collection). An object may be finalized on any thread.\n@param object The JSObject being finalized.\n@discussion If you named your function Finalize, you would declare it like this:\n\nvoid Finalize(JSObjectRef object);\n\nThe finalize callback is called on the most derived class first, and the least\nderived class (the parent class) last.\n\nYou must not call any function that may cause a garbage collection or an allocation\nof a garbage collected object from within a JSObjectFinalizeCallback. This includes\nall functions that have a JSContextRef parameter."]
pub type JSObjectFinalizeCallback =
    ::std::option::Option<unsafe extern "C" fn(object: JSObjectRef)>;
#[doc = "@typedef JSObjectHasPropertyCallback\n@abstract The callback invoked when determining whether an object has a property.\n@param ctx The execution context to use.\n@param object The JSObject to search for the property.\n@param propertyName A JSString containing the name of the property look up.\n@result true if object has the property, otherwise false.\n@discussion If you named your function HasProperty, you would declare it like this:\n\nbool HasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName);\n\nIf this function returns false, the hasProperty request forwards to object's statically declared properties, then its parent class chain (which includes the default object class), then its prototype chain.\n\nThis callback enables optimization in cases where only a property's existence needs to be known, not its value, and computing its value would be expensive.\n\nIf this callback is NULL, the getProperty callback will be used to service hasProperty requests."]
pub type JSObjectHasPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectGetPropertyCallback\n@abstract The callback invoked when getting a property's value.\n@param ctx The execution context to use.\n@param object The JSObject to search for the property.\n@param propertyName A JSString containing the name of the property to get.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result The property's value if object has the property, otherwise NULL.\n@discussion If you named your function GetProperty, you would declare it like this:\n\nJSValueRef GetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);\n\nIf this function returns NULL, the get request forwards to object's statically declared properties, then its parent class chain (which includes the default object class), then its prototype chain."]
pub type JSObjectGetPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@typedef JSObjectSetPropertyCallback\n@abstract The callback invoked when setting a property's value.\n@param ctx The execution context to use.\n@param object The JSObject on which to set the property's value.\n@param propertyName A JSString containing the name of the property to set.\n@param value A JSValue to use as the property's value.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if the property was set, otherwise false.\n@discussion If you named your function SetProperty, you would declare it like this:\n\nbool SetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef* exception);\n\nIf this function returns false, the set request forwards to object's statically declared properties, then its parent class chain (which includes the default object class)."]
pub type JSObjectSetPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectDeletePropertyCallback\n@abstract The callback invoked when deleting a property.\n@param ctx The execution context to use.\n@param object The JSObject in which to delete the property.\n@param propertyName A JSString containing the name of the property to delete.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if propertyName was successfully deleted, otherwise false.\n@discussion If you named your function DeleteProperty, you would declare it like this:\n\nbool DeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);\n\nIf this function returns false, the delete request forwards to object's statically declared properties, then its parent class chain (which includes the default object class)."]
pub type JSObjectDeletePropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectGetPropertyNamesCallback\n@abstract The callback invoked when collecting the names of an object's properties.\n@param ctx The execution context to use.\n@param object The JSObject whose property names are being collected.\n@param propertyNames A JavaScript property name accumulator in which to accumulate the names of object's properties.\n@discussion If you named your function GetPropertyNames, you would declare it like this:\n\nvoid GetPropertyNames(JSContextRef ctx, JSObjectRef object, JSPropertyNameAccumulatorRef propertyNames);\n\nProperty name accumulators are used by JSObjectCopyPropertyNames and JavaScript for...in loops.\n\nUse JSPropertyNameAccumulatorAddName to add property names to accumulator. A class's getPropertyNames callback only needs to provide the names of properties that the class vends through a custom getProperty or setProperty callback. Other properties, including statically declared properties, properties vended by other classes, and properties belonging to object's prototype, are added independently."]
pub type JSObjectGetPropertyNamesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyNames: JSPropertyNameAccumulatorRef,
    ),
>;
#[doc = "@typedef JSObjectCallAsFunctionCallback\n@abstract The callback invoked when an object is called as a function.\n@param ctx The execution context to use.\n@param function A JSObject that is the function being called.\n@param thisObject A JSObject that is the 'this' variable in the function's scope.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of the  arguments passed to the function.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result A JSValue that is the function's return value.\n@discussion If you named your function CallAsFunction, you would declare it like this:\n\nJSValueRef CallAsFunction(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'myObject.myFunction()', function would be set to myFunction, and thisObject would be set to myObject.\n\nIf this callback is NULL, calling your object as a function will throw an exception."]
pub type JSObjectCallAsFunctionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        function: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@typedef JSObjectCallAsConstructorCallback\n@abstract The callback invoked when an object is used as a constructor in a 'new' expression.\n@param ctx The execution context to use.\n@param constructor A JSObject that is the constructor being called.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of the  arguments passed to the function.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result A JSObject that is the constructor's return value.\n@discussion If you named your function CallAsConstructor, you would declare it like this:\n\nJSObjectRef CallAsConstructor(JSContextRef ctx, JSObjectRef constructor, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'new myConstructor()', constructor would be set to myConstructor.\n\nIf this callback is NULL, using your object as a constructor in a 'new' expression will throw an exception."]
pub type JSObjectCallAsConstructorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        constructor: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
>;
#[doc = "@typedef JSObjectHasInstanceCallback\n@abstract hasInstance The callback invoked when an object is used as the target of an 'instanceof' expression.\n@param ctx The execution context to use.\n@param constructor The JSObject that is the target of the 'instanceof' expression.\n@param possibleInstance The JSValue being tested to determine if it is an instance of constructor.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if possibleInstance is an instance of constructor, otherwise false.\n@discussion If you named your function HasInstance, you would declare it like this:\n\nbool HasInstance(JSContextRef ctx, JSObjectRef constructor, JSValueRef possibleInstance, JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'someValue instanceof myObject', constructor would be set to myObject and possibleInstance would be set to someValue.\n\nIf this callback is NULL, 'instanceof' expressions that target your object will return false.\n\nStandard JavaScript practice calls for objects that implement the callAsConstructor callback to implement the hasInstance callback as well."]
pub type JSObjectHasInstanceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        constructor: JSObjectRef,
        possibleInstance: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectConvertToTypeCallback\n@abstract The callback invoked when converting an object to a particular JavaScript type.\n@param ctx The execution context to use.\n@param object The JSObject to convert.\n@param type A JSType specifying the JavaScript type to convert to.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result The objects's converted value, or NULL if the object was not converted.\n@discussion If you named your function ConvertToType, you would declare it like this:\n\nJSValueRef ConvertToType(JSContextRef ctx, JSObjectRef object, JSType type, JSValueRef* exception);\n\nIf this function returns false, the conversion request forwards to object's parent class chain (which includes the default object class).\n\nThis function is only invoked when converting an object to number or string. An object converted to boolean is 'true.' An object converted to object is itself."]
pub type JSObjectConvertToTypeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        type_: JSType,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@struct JSStaticValue\n@abstract This structure describes a statically declared value property.\n@field name A null-terminated UTF8 string containing the property's name.\n@field getProperty A JSObjectGetPropertyCallback to invoke when getting the property's value.\n@field setProperty A JSObjectSetPropertyCallback to invoke when setting the property's value. May be NULL if the ReadOnly attribute is set.\n@field attributes A logically ORed set of JSPropertyAttributes to give to the property."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSStaticValue {
    pub name: *const ::std::os::raw::c_char,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub attributes: JSPropertyAttributes,
}
#[test]
fn bindgen_test_layout_JSStaticValue() {
    const UNINIT: ::std::mem::MaybeUninit<JSStaticValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JSStaticValue>(),
        32usize,
        concat!("Size of: ", stringify!(JSStaticValue))
    );
    assert_eq!(
        ::std::mem::align_of::<JSStaticValue>(),
        8usize,
        concat!("Alignment of ", stringify!(JSStaticValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getProperty) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(getProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setProperty) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(setProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(attributes)
        )
    );
}
#[doc = "@struct JSStaticFunction\n@abstract This structure describes a statically declared function property.\n@field name A null-terminated UTF8 string containing the property's name.\n@field callAsFunction A JSObjectCallAsFunctionCallback to invoke when the property is called as a function.\n@field attributes A logically ORed set of JSPropertyAttributes to give to the property."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSStaticFunction {
    pub name: *const ::std::os::raw::c_char,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub attributes: JSPropertyAttributes,
}
#[test]
fn bindgen_test_layout_JSStaticFunction() {
    const UNINIT: ::std::mem::MaybeUninit<JSStaticFunction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JSStaticFunction>(),
        24usize,
        concat!("Size of: ", stringify!(JSStaticFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<JSStaticFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(JSStaticFunction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticFunction),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callAsFunction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticFunction),
            "::",
            stringify!(callAsFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSStaticFunction),
            "::",
            stringify!(attributes)
        )
    );
}
#[doc = "@struct JSClassDefinition\n@abstract This structure contains properties and callbacks that define a type of object. All fields other than the version field are optional. Any pointer may be NULL.\n@field version The version number of this structure. The current version is 0.\n@field attributes A logically ORed set of JSClassAttributes to give to the class.\n@field className A null-terminated UTF8 string containing the class's name.\n@field parentClass A JSClass to set as the class's parent class. Pass NULL use the default object class.\n@field staticValues A JSStaticValue array containing the class's statically declared value properties. Pass NULL to specify no statically declared value properties. The array must be terminated by a JSStaticValue whose name field is NULL.\n@field staticFunctions A JSStaticFunction array containing the class's statically declared function properties. Pass NULL to specify no statically declared function properties. The array must be terminated by a JSStaticFunction whose name field is NULL.\n@field initialize The callback invoked when an object is first created. Use this callback to initialize the object.\n@field finalize The callback invoked when an object is finalized (prepared for garbage collection). Use this callback to release resources allocated for the object, and perform other cleanup.\n@field hasProperty The callback invoked when determining whether an object has a property. If this field is NULL, getProperty is called instead. The hasProperty callback enables optimization in cases where only a property's existence needs to be known, not its value, and computing its value is expensive.\n@field getProperty The callback invoked when getting a property's value.\n@field setProperty The callback invoked when setting a property's value.\n@field deleteProperty The callback invoked when deleting a property.\n@field getPropertyNames The callback invoked when collecting the names of an object's properties.\n@field callAsFunction The callback invoked when an object is called as a function.\n@field hasInstance The callback invoked when an object is used as the target of an 'instanceof' expression.\n@field callAsConstructor The callback invoked when an object is used as a constructor in a 'new' expression.\n@field convertToType The callback invoked when converting an object to a particular JavaScript type.\n@discussion The staticValues and staticFunctions arrays are the simplest and most efficient means for vending custom properties. Statically declared properties autmatically service requests like getProperty, setProperty, and getPropertyNames. Property access callbacks are required only to implement unusual properties, like array indexes, whose names are not known at compile-time.\n\nIf you named your getter function \"GetX\" and your setter function \"SetX\", you would declare a JSStaticValue array containing \"X\" like this:\n\nJSStaticValue StaticValueArray[] = {\n{ \"X\", GetX, SetX, kJSPropertyAttributeNone },\n{ 0, 0, 0, 0 }\n};\n\nStandard JavaScript practice calls for storing function objects in prototypes, so they can be shared. The default JSClass created by JSClassCreate follows this idiom, instantiating objects with a shared, automatically generating prototype containing the class's function objects. The kJSClassAttributeNoAutomaticPrototype attribute specifies that a JSClass should not automatically generate such a prototype. The resulting JSClass instantiates objects with the default object prototype, and gives each instance object its own copy of the class's function objects.\n\nA NULL callback specifies that the default object callback should substitute, except in the case of hasProperty, where it specifies that getProperty should substitute.\n\nIt is not possible to use JS subclassing with objects created from a class definition that sets callAsConstructor by default. Subclassing is supported via the JSObjectMakeConstructor function, however."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClassDefinition {
    pub version: ::std::os::raw::c_int,
    pub attributes: JSClassAttributes,
    pub className: *const ::std::os::raw::c_char,
    pub parentClass: JSClassRef,
    pub staticValues: *const JSStaticValue,
    pub staticFunctions: *const JSStaticFunction,
    pub initialize: JSObjectInitializeCallback,
    pub finalize: JSObjectFinalizeCallback,
    pub hasProperty: JSObjectHasPropertyCallback,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub deleteProperty: JSObjectDeletePropertyCallback,
    pub getPropertyNames: JSObjectGetPropertyNamesCallback,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub callAsConstructor: JSObjectCallAsConstructorCallback,
    pub hasInstance: JSObjectHasInstanceCallback,
    pub convertToType: JSObjectConvertToTypeCallback,
}
#[test]
fn bindgen_test_layout_JSClassDefinition() {
    const UNINIT: ::std::mem::MaybeUninit<JSClassDefinition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JSClassDefinition>(),
        128usize,
        concat!("Size of: ", stringify!(JSClassDefinition))
    );
    assert_eq!(
        ::std::mem::align_of::<JSClassDefinition>(),
        8usize,
        concat!("Alignment of ", stringify!(JSClassDefinition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).className) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(className)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parentClass) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(parentClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staticValues) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(staticValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staticFunctions) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(staticFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasProperty) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(hasProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getProperty) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(getProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setProperty) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(setProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deleteProperty) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(deleteProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getPropertyNames) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(getPropertyNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callAsFunction) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(callAsFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callAsConstructor) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(callAsConstructor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasInstance) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(hasInstance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).convertToType) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(convertToType)
        )
    );
}
extern "C" {
    #[doc = "@const kJSClassDefinitionEmpty\n@abstract A JSClassDefinition structure of the current version, filled with NULL pointers and having no attributes.\n@discussion Use this constant as a convenience when creating class definitions. For example, to create a class definition with only a finalize method:\n\nJSClassDefinition definition = kJSClassDefinitionEmpty;\ndefinition.finalize = Finalize;"]
    pub static kJSClassDefinitionEmpty: JSClassDefinition;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript class suitable for use with JSObjectMake.\n@param definition A JSClassDefinition that defines the class.\n@result A JSClass with the given definition. Ownership follows the Create Rule."]
    pub fn JSClassCreate(definition: *const JSClassDefinition) -> JSClassRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a JavaScript class.\n@param jsClass The JSClass to retain.\n@result A JSClass that is the same as jsClass."]
    pub fn JSClassRetain(jsClass: JSClassRef) -> JSClassRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a JavaScript class.\n@param jsClass The JSClass to release."]
    pub fn JSClassRelease(jsClass: JSClassRef);
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript object.\n@param ctx The execution context to use.\n@param jsClass The JSClass to assign to the object. Pass NULL to use the default object class.\n@param data A void* to set as the object's private data. Pass NULL to specify no private data.\n@result A JSObject with the given class and private data.\n@discussion The default object class does not allocate storage for private data, so you must provide a non-NULL jsClass to JSObjectMake if you want your object to be able to store private data.\n\ndata is set on the created object before the intialize methods in its class chain are called. This enables the initialize methods to retrieve and manipulate data through JSObjectGetPrivate."]
    pub fn JSObjectMake(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        data: *mut ::std::os::raw::c_void,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Convenience method for creating a JavaScript function with a given callback as its implementation.\n@param ctx The execution context to use.\n@param name A JSString containing the function's name. This will be used when converting the function to string. Pass NULL to create an anonymous function.\n@param callAsFunction The JSObjectCallAsFunctionCallback to invoke when the function is called.\n@result A JSObject that is a function. The object's prototype will be the default function prototype."]
    pub fn JSObjectMakeFunctionWithCallback(
        ctx: JSContextRef,
        name: JSStringRef,
        callAsFunction: JSObjectCallAsFunctionCallback,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Convenience method for creating a JavaScript constructor.\n@param ctx The execution context to use.\n@param jsClass A JSClass that is the class your constructor will assign to the objects its constructs. jsClass will be used to set the constructor's .prototype property, and to evaluate 'instanceof' expressions. Pass NULL to use the default object class.\n@param callAsConstructor A JSObjectCallAsConstructorCallback to invoke when your constructor is used in a 'new' expression. Pass NULL to use the default object constructor.\n@result A JSObject that is a constructor. The object's prototype will be the default object prototype.\n@discussion The default object constructor takes no arguments and constructs an object of class jsClass with no private data. If the constructor is inherited via JS subclassing and the value returned from callAsConstructor was created with jsClass, then the returned object will have it's prototype overridden to the derived class's prototype."]
    pub fn JSObjectMakeConstructor(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        callAsConstructor: JSObjectCallAsConstructorCallback,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript Array object.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of data to populate the Array with. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an Array.\n@discussion The behavior of this function does not exactly match the behavior of the built-in Array constructor. Specifically, if one argument\nis supplied, this function returns an array with one element."]
    pub fn JSObjectMakeArray(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript Date object, as if by invoking the built-in Date constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the Date Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a Date."]
    pub fn JSObjectMakeDate(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript Error object, as if by invoking the built-in Error constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the Error Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an Error."]
    pub fn JSObjectMakeError(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript TypeError object, as if by invoking the built-in TypeError constructor.\n@param ctx The execution context to use.\n@param message A JSString containing the message for the TypeError's 'message' property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an TypeError."]
    pub fn JSObjectMakeTypeError(
        ctx: JSContextRef,
        message: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript RegExp object, as if by invoking the built-in RegExp constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the RegExp Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a RegExp."]
    pub fn JSObjectMakeRegExp(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript promise object by invoking the provided executor.\n@param ctx The execution context to use.\n@param resolve A pointer to a JSObjectRef in which to store the resolve function for the new promise. Pass NULL if you do not care to store the resolve callback.\n@param reject A pointer to a JSObjectRef in which to store the reject function for the new promise. Pass NULL if you do not care to store the reject callback.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a promise or NULL if an exception occurred."]
    pub fn JSObjectMakeDeferredPromise(
        ctx: JSContextRef,
        resolve: *mut JSObjectRef,
        reject: *mut JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a function with a given script as its body.\n@param ctx The execution context to use.\n@param name A JSString containing the function's name. This will be used when converting the function to string. Pass NULL to create an anonymous function.\n@param parameterCount An integer count of the number of parameter names in parameterNames.\n@param parameterNames A JSString array containing the names of the function's parameters. Pass NULL if parameterCount is 0.\n@param body A JSString containing the script to use as the function's body.\n@param sourceURL A JSString containing a URL for the script's source file. This is only used when reporting exceptions. Pass NULL if you do not care to include source file information in exceptions.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store a syntax error exception, if any. Pass NULL if you do not care to store a syntax error exception.\n@result A JSObject that is a function, or NULL if either body or parameterNames contains a syntax error. The object's prototype will be the default function prototype.\n@discussion Use this method when you want to execute a script repeatedly, to avoid the cost of re-parsing the script before each execution."]
    pub fn JSObjectMakeFunction(
        ctx: JSContextRef,
        name: JSStringRef,
        parameterCount: ::std::os::raw::c_uint,
        parameterNames: *const JSStringRef,
        body: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets an object's prototype.\n@param ctx  The execution context to use.\n@param object A JSObject whose prototype you want to get.\n@result A JSValue that is the object's prototype."]
    pub fn JSObjectGetPrototype(ctx: JSContextRef, object: JSObjectRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets an object's prototype.\n@param ctx  The execution context to use.\n@param object The JSObject whose prototype you want to set.\n@param value A JSValue to set as the object's prototype."]
    pub fn JSObjectSetPrototype(
        ctx: JSContextRef,
        object: JSObjectRef,
        value: JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object has a given property.\n@param object The JSObject to test.\n@param propertyName A JSString containing the property's name.\n@result true if the object has a property whose name matches propertyName, otherwise false."]
    pub fn JSObjectHasProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property from an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyName A JSString containing the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property, otherwise the undefined value."]
    pub fn JSObjectGetProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a property on an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyName A JSString containing the property's name.\n@param value A JSValueRef to use as the property's value.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSObjectSetProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Deletes a property from an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to delete.\n@param propertyName A JSString containing the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the delete operation succeeds, otherwise false (for example, if the property has the kJSPropertyAttributeDontDelete attribute set)."]
    pub fn JSObjectDeleteProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object has a given property using a JSValueRef as the property key.\n@param object The JSObject to test.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the object has a property whose name matches propertyKey, otherwise false.\n@discussion This function is the same as performing \"propertyKey in object\" from JavaScript."]
    pub fn JSObjectHasPropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property from an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property key, otherwise the undefined value.\n@discussion This function is the same as performing \"object[propertyKey]\" from JavaScript."]
    pub fn JSObjectGetPropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a property on an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param value A JSValueRef to use as the property's value.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@discussion This function is the same as performing \"object[propertyKey] = value\" from JavaScript."]
    pub fn JSObjectSetPropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Deletes a property from an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to delete.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the delete operation succeeds, otherwise false (for example, if the property has the kJSPropertyAttributeDontDelete attribute set).\n@discussion This function is the same as performing \"delete object[propertyKey]\" from JavaScript."]
    pub fn JSObjectDeletePropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Implement the async iterable protocol on an object.\n@param ctx The execution context to use.\n@param object The JSObject to implement the async iterable protocol on.\n@param value A zero-argument function that returns an object, conforming to the async iterator protocol.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSObjectSetAsyncIterator(
        ctx: JSContextRef,
        object: JSObjectRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Implement the iterator protocol on an object.\n@param ctx The execution context to use.\n@param object The JSObject to implement the iterator protocol on.\n@param value A zero-argument function that returns an object, conforming to the iterator protocol.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSObjectSetIterator(
        ctx: JSContextRef,
        object: JSObjectRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property from an object by numeric index.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyIndex An integer value that is the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property, otherwise the undefined value.\n@discussion Calling JSObjectGetPropertyAtIndex is equivalent to calling JSObjectGetProperty with a string containing propertyIndex, but JSObjectGetPropertyAtIndex provides optimized access to numeric properties."]
    pub fn JSObjectGetPropertyAtIndex(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a property on an object by numeric index.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyIndex The property's name as a number.\n@param value A JSValue to use as the property's value.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@discussion Calling JSObjectSetPropertyAtIndex is equivalent to calling JSObjectSetProperty with a string containing propertyIndex, but JSObjectSetPropertyAtIndex provides optimized access to numeric properties."]
    pub fn JSObjectSetPropertyAtIndex(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        value: JSValueRef,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Gets an object's private data.\n@param object A JSObject whose private data you want to get.\n@result A void* that is the object's private data, if the object has private data, otherwise NULL."]
    pub fn JSObjectGetPrivate(object: JSObjectRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a pointer to private data on an object.\n@param object The JSObject whose private data you want to set.\n@param data A void* to set as the object's private data.\n@result true if object can store private data, otherwise false.\n@discussion The default object class does not allocate storage for private data. Only objects created with a non-NULL JSClass can store private data."]
    pub fn JSObjectSetPrivate(
        object: JSObjectRef,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object can be called as a function.\n@param ctx  The execution context to use.\n@param object The JSObject to test.\n@result true if the object can be called as a function, otherwise false."]
    pub fn JSObjectIsFunction(ctx: JSContextRef, object: JSObjectRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Calls an object as a function.\n@param ctx The execution context to use.\n@param object The JSObject to call as a function.\n@param thisObject The object to use as \"this,\" or NULL to use the global object as \"this.\"\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the function. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSValue that results from calling object as a function, or NULL if an exception is thrown or object is not a function."]
    pub fn JSObjectCallAsFunction(
        ctx: JSContextRef,
        object: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object can be called as a constructor.\n@param ctx  The execution context to use.\n@param object The JSObject to test.\n@result true if the object can be called as a constructor, otherwise false."]
    pub fn JSObjectIsConstructor(ctx: JSContextRef, object: JSObjectRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Calls an object as a constructor.\n@param ctx The execution context to use.\n@param object The JSObject to call as a constructor.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSObject that results from calling object as a constructor, or NULL if an exception is thrown or object is not a constructor."]
    pub fn JSObjectCallAsConstructor(
        ctx: JSContextRef,
        object: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets the names of an object's enumerable properties.\n@param ctx The execution context to use.\n@param object The object whose property names you want to get.\n@result A JSPropertyNameArray containing the names object's enumerable properties. Ownership follows the Create Rule."]
    pub fn JSObjectCopyPropertyNames(
        ctx: JSContextRef,
        object: JSObjectRef,
    ) -> JSPropertyNameArrayRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a JavaScript property name array.\n@param array The JSPropertyNameArray to retain.\n@result A JSPropertyNameArray that is the same as array."]
    pub fn JSPropertyNameArrayRetain(
        array: JSPropertyNameArrayRef,
    ) -> JSPropertyNameArrayRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a JavaScript property name array.\n@param array The JSPropetyNameArray to release."]
    pub fn JSPropertyNameArrayRelease(array: JSPropertyNameArrayRef);
}
extern "C" {
    #[doc = "@function\n@abstract Gets a count of the number of items in a JavaScript property name array.\n@param array The array from which to retrieve the count.\n@result An integer count of the number of names in array."]
    pub fn JSPropertyNameArrayGetCount(array: JSPropertyNameArrayRef) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property name at a given index in a JavaScript property name array.\n@param array The array from which to retrieve the property name.\n@param index The index of the property name to retrieve.\n@result A JSStringRef containing the property name."]
    pub fn JSPropertyNameArrayGetNameAtIndex(
        array: JSPropertyNameArrayRef,
        index: usize,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract Adds a property name to a JavaScript property name accumulator.\n@param accumulator The accumulator object to which to add the property name.\n@param propertyName The property name to add."]
    pub fn JSPropertyNameAccumulatorAddName(
        accumulator: JSPropertyNameAccumulatorRef,
        propertyName: JSStringRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript context group.\n@discussion A JSContextGroup associates JavaScript contexts with one another.\nContexts in the same group may share and exchange JavaScript objects. Sharing and/or exchanging\nJavaScript objects between contexts in different groups will produce undefined behavior.\nWhen objects from the same context group are used in multiple threads, explicit\nsynchronization is required.\n\nA JSContextGroup may need to run deferred tasks on a run loop, such as garbage collection\nor resolving WebAssembly compilations. By default, calling JSContextGroupCreate will use\nthe run loop of the thread it was called on. Currently, there is no API to change a\nJSContextGroup's run loop once it has been created.\n@result The created JSContextGroup."]
    pub fn JSContextGroupCreate() -> JSContextGroupRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a JavaScript context group.\n@param group The JSContextGroup to retain.\n@result A JSContextGroup that is the same as group."]
    pub fn JSContextGroupRetain(group: JSContextGroupRef) -> JSContextGroupRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a JavaScript context group.\n@param group The JSContextGroup to release."]
    pub fn JSContextGroupRelease(group: JSContextGroupRef);
}
extern "C" {
    #[doc = "@function\n@abstract Creates a global JavaScript execution context.\n@discussion JSGlobalContextCreate allocates a global object and populates it with all the\nbuilt-in JavaScript objects, such as Object, Function, String, and Array.\n\nIn WebKit version 4.0 and later, the context is created in a unique context group.\nTherefore, scripts may execute in it concurrently with scripts executing in other contexts.\nHowever, you may not use values created in the context in other contexts.\n@param globalObjectClass The class to use when creating the global object. Pass\nNULL to use the default object class.\n@result A JSGlobalContext with a global object of class globalObjectClass."]
    pub fn JSGlobalContextCreate(globalObjectClass: JSClassRef) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a global JavaScript execution context in the context group provided.\n@discussion JSGlobalContextCreateInGroup allocates a global object and populates it with\nall the built-in JavaScript objects, such as Object, Function, String, and Array.\n@param globalObjectClass The class to use when creating the global object. Pass\nNULL to use the default object class.\n@param group The context group to use. The created global context retains the group.\nPass NULL to create a unique group for the context.\n@result A JSGlobalContext with a global object of class globalObjectClass and a context\ngroup equal to group."]
    pub fn JSGlobalContextCreateInGroup(
        group: JSContextGroupRef,
        globalObjectClass: JSClassRef,
    ) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a global JavaScript execution context.\n@param ctx The JSGlobalContext to retain.\n@result A JSGlobalContext that is the same as ctx."]
    pub fn JSGlobalContextRetain(ctx: JSGlobalContextRef) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a global JavaScript execution context.\n@param ctx The JSGlobalContext to release."]
    pub fn JSGlobalContextRelease(ctx: JSGlobalContextRef);
}
extern "C" {
    #[doc = "@function\n@abstract Gets the global object of a JavaScript execution context.\n@param ctx The JSContext whose global object you want to get.\n@result ctx's global object."]
    pub fn JSContextGetGlobalObject(ctx: JSContextRef) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets the shared data pointer\n@param ctx The JSContext whose global object you want to get.\n@param data A void* to set as the context's shared data. Pass NULL to specify no shared data."]
    pub fn JSContextSetSharedData(ctx: JSContextRef, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "@function\n@abstract Gets the shared data pointer\n@param ctx The JSContext whose global object you want to get.\n@result A void* that is the context's shared data, if the context has shared data, otherwise NULL."]
    pub fn JSContextGetSharedData(ctx: JSContextRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract Sets the callback function that will be called when an unhandled promise rejection occurs.\n@param ctx The JSGlobalContext whose unhandled promise rejection callback you want to set.\n@param function The JSObjectRef to call when an unhandled promise rejection occurs. Pass NULL to remove the callback.\n@param exception The exception to pass to the callback. Pass NULL to specify no exception."]
    pub fn JSGlobalContextSetUnhandledRejectionCallback(
        ctx: JSGlobalContextRef,
        function: JSObjectRef,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Sets the callback function that will be called when an uncaught exception occurs on the main thread.\n@param ctx The JSGlobalContext whose uncaught exception callback you want to set.\n@param callback The JSObjectRef to call when an uncaught exception occurs. Pass NULL to remove the callback."]
    pub fn JSGlobalContextSetUncaughtExceptionAtEventLoopCallback(
        ctx: JSGlobalContextRef,
        callback: JSUncaughtExceptionAtEventLoop,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Sets the callback function that will be called when an uncaught exception occurs.\n@param ctx The JSGlobalContext whose uncaught exception callback you want to set.\n@param callback The JSObjectRef to call when an uncaught exception occurs. Pass NULL to remove the callback."]
    pub fn JSGlobalContextSetUncaughtExceptionHandler(
        ctx: JSGlobalContextRef,
        handler: JSUncaughtExceptionHandler,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Gets the context group to which a JavaScript execution context belongs.\n@param ctx The JSContext whose group you want to get.\n@result ctx's group."]
    pub fn JSContextGetGroup(ctx: JSContextRef) -> JSContextGroupRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets the global context of a JavaScript execution context.\n@param ctx The JSContext whose global context you want to get.\n@result ctx's global context."]
    pub fn JSContextGetGlobalContext(ctx: JSContextRef) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a copy of the name of a context.\n@param ctx The JSGlobalContext whose name you want to get.\n@result The name for ctx.\n@discussion A JSGlobalContext's name is exposed when inspecting the context to make it easier to identify the context you would like to inspect."]
    pub fn JSGlobalContextCopyName(ctx: JSGlobalContextRef) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets the name exposed when inspecting a context.\n@param ctx The JSGlobalContext that you want to name.\n@param name The name to set on the context."]
    pub fn JSGlobalContextSetName(ctx: JSGlobalContextRef, name: JSStringRef);
}
extern "C" {
    #[doc = "@function\n@abstract Gets whether the context is inspectable in Web Inspector.\n@param ctx The JSGlobalContext that you want to change the inspectability of.\n@result Whether the context is inspectable in Web Inspector."]
    pub fn JSGlobalContextIsInspectable(ctx: JSGlobalContextRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Sets whether the context is inspectable in Web Inspector. Default value is NO.\n@param ctx The JSGlobalContext that you want to change the inspectability of.\n@param inspectable YES to allow Web Inspector to connect to the context, otherwise NO."]
    pub fn JSGlobalContextSetInspectable(ctx: JSGlobalContextRef, inspectable: bool);
}
extern "C" {
    #[doc = "@function\n@abstract Starts a remote inspector server.\n@param address The address to listen on.\n@param port The port to listen on."]
    pub fn JSRemoteInspectorServerStart(
        address: *const ::std::os::raw::c_char,
        port: u16,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Starts a remote inspector server."]
    pub fn JSRemoteInspectorStart();
}
extern "C" {
    #[doc = "@function\n@abstract Sets the callback to be called when the context is inspected in Web Inspector."]
    pub fn JSInspectorSetCallback(
        ctx: JSGlobalContextRef,
        callback: InspectorMessageCallback,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Sends a message to the Web Inspector."]
    pub fn JSInspectorSendMessage(
        ctx: JSGlobalContextRef,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Cleans up inspector resources.\n@deprecated Use JSInspectorDisconnect instead."]
    pub fn JSInspectorCleanup();
}
extern "C" {
    #[doc = "@function\n@abstract Disconnects the inspector frontend from the given context.\n@param ctx The JavaScript context to disconnect from the inspector."]
    pub fn JSInspectorDisconnect(ctx: JSGlobalContextRef);
}
extern "C" {
    #[doc = "@function\n@abstract Checks if the inspector is currently connected for the given context.\n@param ctx The JavaScript context to check.\n@return true if an inspector frontend is connected, false otherwise."]
    pub fn JSInspectorIsConnected(ctx: JSGlobalContextRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract         Converts a JSValue to a singed 32-bit integer and returns the resulting integer.\n@param ctx        The execution context to use.\n@param value      The JSValue to convert.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.\n@result           An int32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.\n@discussion       The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int32_t."]
    pub fn JSValueToInt32(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> i32;
}
extern "C" {
    #[doc = "@function\n@abstract         Converts a JSValue to an unsigned 32-bit integer and returns the resulting integer.\n@param ctx        The execution context to use.\n@param value      The JSValue to convert.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.\n@result           A uint32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.\n@discussion       The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint32_t."]
    pub fn JSValueToUInt32(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> u32;
}
extern "C" {
    #[doc = "@function\n@abstract         Converts a JSValue to a singed 64-bit integer and returns the resulting integer.\n@param ctx        The execution context to use.\n@param value      The JSValue to convert.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.\n@result           An int64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.\n@discussion       The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int64_t."]
    pub fn JSValueToInt64(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> i64;
}
extern "C" {
    #[doc = "@function\n@abstract         Converts a JSValue to an unsigned 64-bit integer and returns the resulting integer.\n@param ctx        The execution context to use.\n@param value      The JSValue to convert.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.\n@result           A uint64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.\n@discussion       The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint64_t."]
    pub fn JSValueToUInt64(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> u64;
}

#[doc = " The debugger has entered paused state (breakpoint hit, debugger statement, etc.)"]
pub const InspectorPauseEvent_InspectorPauseEventPaused: InspectorPauseEvent = 0;
#[doc = " The debugger has exited paused state and resumed execution"]
pub const InspectorPauseEvent_InspectorPauseEventResumed: InspectorPauseEvent = 1;
#[doc = " Tick event during paused state nested run loop (for processing commands)"]
pub const InspectorPauseEvent_InspectorPauseEventTick: InspectorPauseEvent = 2;
#[doc = " Enum representing the type of debugger pause-loop event."]
pub type InspectorPauseEvent = ::std::os::raw::c_uint;
#[doc = " Callback function type for debugger pause-loop events (paused/resumed/tick).\n\n @param ctx The JavaScript context (JSContextRef).\n @param event The event type (Paused, Resumed, or Tick)."]
pub type InspectorPauseEventCallback = ::std::option::Option<
    unsafe extern "C" fn(ctx: JSContextRef, event: InspectorPauseEvent),
>;
extern "C" {
    #[doc = " Sets the callback for debugger pause-loop events (paused/resumed/tick).\n\n This callback is invoked when:\n - The debugger enters paused state (event = InspectorPauseEventPaused)\n - The debugger exits paused state (event = InspectorPauseEventResumed)\n - During the paused state nested run loop (event = InspectorPauseEventTick)\n\n The context (JSContextRef) is passed directly to the callback.\n\n @param context The JavaScript context to configure.\n @param callback The pause-loop event callback, or NULL to disable."]
    pub fn JSInspectorSetPauseEventCallback(
        context: JSGlobalContextRef,
        callback: InspectorPauseEventCallback,
    );
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the BigInt type.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the BigInt type, otherwise false."]
    pub fn JSValueIsBigInt(ctx: JSContextRef, value: JSValueRef) -> bool;
}
#[doc = "@typedef JSChar\n@abstract A UTF-16 code unit. One, or a sequence of two, can encode any Unicode\ncharacter. As with all scalar types, endianness depends on the underlying\narchitecture."]
pub type JSChar = ::std::os::raw::c_ushort;
extern "C" {
    #[doc = "@function\n@abstract         Creates a JavaScript string from a buffer of Unicode characters.\n@param chars      The buffer of Unicode characters to copy into the new JSString.\n@param numChars   The number of characters to copy from the buffer pointed to by chars.\n@result           A JSString containing chars. Ownership follows the Create Rule."]
    pub fn JSStringCreateWithCharacters(
        chars: *const JSChar,
        numChars: usize,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Creates a JavaScript string from a null-terminated UTF8 string.\n@param string     The null-terminated UTF8 string to copy into the new JSString.\n@result           A JSString containing string. Ownership follows the Create Rule."]
    pub fn JSStringCreateWithUTF8CString(
        string: *const ::std::os::raw::c_char,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Retains a JavaScript string.\n@param string     The JSString to retain.\n@result           A JSString that is the same as string."]
    pub fn JSStringRetain(string: JSStringRef) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Releases a JavaScript string.\n@param string     The JSString to release."]
    pub fn JSStringRelease(string: JSStringRef);
}
extern "C" {
    #[doc = "@function\n@abstract         Returns the number of Unicode characters in a JavaScript string.\n@param string     The JSString whose length (in Unicode characters) you want to know.\n@result           The number of Unicode characters stored in string."]
    pub fn JSStringGetLength(string: JSStringRef) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract         Returns a pointer to the Unicode character buffer that\nserves as the backing store for a JavaScript string.\n@param string     The JSString whose backing store you want to access.\n@result           A pointer to the Unicode character buffer that serves as string's\nbacking store, which will be deallocated when string is deallocated."]
    pub fn JSStringGetCharactersPtr(string: JSStringRef) -> *const JSChar;
}
extern "C" {
    #[doc = "@function\n@abstract Returns the maximum number of bytes a JavaScript string will\ntake up if converted into a null-terminated UTF8 string.\n@param string The JSString whose maximum converted size (in bytes) you\nwant to know.\n@result The maximum number of bytes that could be required to convert string into a\nnull-terminated UTF8 string. The number of bytes that the conversion actually ends\nup requiring could be less than this, but never more."]
    pub fn JSStringGetMaximumUTF8CStringSize(string: JSStringRef) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract Converts a JavaScript string into a null-terminated UTF8 string,\nand copies the result into an external byte buffer.\n@param string The source JSString.\n@param buffer The destination byte buffer into which to copy a null-terminated\nUTF8 representation of string. On return, buffer contains a UTF8 string\nrepresentation of string. If bufferSize is too small, buffer will contain only\npartial results. If buffer is not at least bufferSize bytes in size,\nbehavior is undefined.\n@param bufferSize The size of the external buffer in bytes.\n@result The number of bytes written into buffer (including the null-terminator byte)."]
    pub fn JSStringGetUTF8CString(
        string: JSStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract     Tests whether two JavaScript strings match.\n@param a      The first JSString to test.\n@param b      The second JSString to test.\n@result       true if the two strings match, otherwise false."]
    pub fn JSStringIsEqual(a: JSStringRef, b: JSStringRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract     Tests whether a JavaScript string matches a null-terminated UTF8 string.\n@param a      The JSString to test.\n@param b      The null-terminated UTF8 string to test.\n@result       true if the two strings match, otherwise false."]
    pub fn JSStringIsEqualToUTF8CString(
        a: JSStringRef,
        b: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object with the given number of elements.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param length       The number of elements to be in the new Typed Array.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array with all elements set to zero or NULL if there was an error."]
    pub fn JSObjectMakeTypedArray(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract                 Creates a JavaScript Typed Array object from an existing pointer.\n@param ctx                The execution context to use.\n@param arrayType          A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param bytes              A pointer to the byte buffer to be used as the backing store of the Typed Array object.\n@param byteLength         The number of bytes pointed to by the parameter bytes.\n@param bytesDeallocator   The allocator to use to deallocate the external buffer when the JSTypedArrayData object is deallocated.\n@param deallocatorContext A pointer to pass back to the deallocator.\n@param exception          A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result                   A JSObjectRef Typed Array whose backing store is the same as the one pointed to by bytes or NULL if there was an error.\n@discussion               If an exception is thrown during this function the bytesDeallocator will always be called."]
    pub fn JSObjectMakeTypedArrayWithBytesNoCopy(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object from an existing JavaScript Array Buffer object.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param buffer       An Array Buffer object that should be used as the backing store for the created JavaScript Typed Array object.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array or NULL if there was an error. The backing store of the Typed Array will be buffer."]
    pub fn JSObjectMakeTypedArrayWithArrayBuffer(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object from an existing JavaScript Array Buffer object with the given offset and length.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param buffer       An Array Buffer object that should be used as the backing store for the created JavaScript Typed Array object.\n@param byteOffset   The byte offset for the created Typed Array. byteOffset should aligned with the element size of arrayType.\n@param length       The number of elements to include in the Typed Array.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array or NULL if there was an error. The backing store of the Typed Array will be buffer."]
    pub fn JSObjectMakeTypedArrayWithArrayBufferAndOffset(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        byteOffset: usize,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns a temporary pointer to the backing store of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose backing store pointer to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A pointer to the raw data buffer that serves as object's backing store or NULL if object is not a Typed Array object.\n@discussion         The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub fn JSObjectGetTypedArrayBytesPtr(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the length of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose length to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The length of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub fn JSObjectGetTypedArrayLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the byte length of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose byte length to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The byte length of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub fn JSObjectGetTypedArrayByteLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the byte offset of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose byte offset to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The byte offset of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub fn JSObjectGetTypedArrayByteOffset(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the JavaScript Array Buffer object that is used as the backing of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The JSObjectRef whose Typed Array type data pointer to obtain.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef with a JSTypedArrayType of kJSTypedArrayTypeArrayBuffer or NULL if object is not a Typed Array."]
    pub fn JSObjectGetTypedArrayBuffer(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract                 Creates a JavaScript Array Buffer object from an existing pointer.\n@param ctx                The execution context to use.\n@param bytes              A pointer to the byte buffer to be used as the backing store of the Typed Array object.\n@param byteLength         The number of bytes pointed to by the parameter bytes.\n@param bytesDeallocator   The allocator to use to deallocate the external buffer when the Typed Array data object is deallocated.\n@param deallocatorContext A pointer to pass back to the deallocator.\n@param exception          A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result                   A JSObjectRef Array Buffer whose backing store is the same as the one pointed to by bytes or NULL if there was an error.\n@discussion               If an exception is thrown during this function the bytesDeallocator will always be called."]
    pub fn JSObjectMakeArrayBufferWithBytesNoCopy(
        ctx: JSContextRef,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns a boolean value indicating whether or not a JavaScript value is a detached Typed Array object.\n@param ctx          The execution context to use.\n@param objectRef    The JSObjectRef whose Typed Array type data pointer to obtain.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A boolean value indicating whether or not objectRef is a detached Typed Array object."]
    pub fn JSObjectIsDetachedBuffer(
        ctx: JSContextRef,
        objectRef: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract         Returns a pointer to the data buffer that serves as the backing store for a JavaScript Typed Array object.\n@param object     The Array Buffer object whose internal backing store pointer to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           A pointer to the raw data buffer that serves as object's backing store or NULL if object is not an Array Buffer object.\n@discussion       The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub fn JSObjectGetArrayBufferBytesPtr(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract         Returns a pointer to the data buffer that serves as the backing store for a JavaScript Array Buffer object.\n@param object     The Array Buffer object whose internal backing store pointer to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           A pointer to the raw data buffer that serves as object's backing store or NULL if object is not an Array Buffer object.\n@discussion       The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub fn JSValueFastUFT8Encoding(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C" {
    #[doc = "@function\n@abstract         Returns a pointer to the data buffer that serves as the backing store for a JavaScript Array Buffer object.\n@param object     The Array Buffer object whose internal backing store pointer to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           A pointer to the raw data buffer that serves as object's backing store or NULL if object is not an Array Buffer object.\n@discussion       The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub fn JSValueGetTypedArrayBytesPtrFromValue(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
        offset: *mut usize,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    #[doc = "@function\n@abstract         Returns the number of bytes in a JavaScript data object.\n@param ctx        The execution context to use.\n@param object     The JS Arary Buffer object whose length in bytes to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           The number of bytes stored in the data object."]
    pub fn JSObjectGetArrayBufferByteLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract         Creates a JavaScript string from a CFString.\n@discussion       This function is optimized to take advantage of cases when\nCFStringGetCharactersPtr returns a valid pointer.\n@param string     The CFString to copy into the new JSString.\n@result           A JSString containing string. Ownership follows the Create Rule."]
    pub fn JSStringCreateWithCFString(string: CFStringRef) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Creates a CFString from a JavaScript string.\n@param alloc      The alloc parameter to pass to CFStringCreate.\n@param string     The JSString to copy into the new CFString.\n@result           A CFString containing string. Ownership follows the Create Rule."]
    pub fn JSStringCopyCFString(
        alloc: CFAllocatorRef,
        string: JSStringRef,
    ) -> CFStringRef;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _os_object_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_object_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_group_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_source_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_channel_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_mach_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_mach_msg_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_semaphore_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_io_s {
    pub _address: u8,
}
